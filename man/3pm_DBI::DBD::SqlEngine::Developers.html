<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Mon Aug  8 15:52:54 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DBI::DBD::SqlEngine::Developers</title>

</head>
<body>

<h1 align="center">DBI::DBD::SqlEngine::Developers</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CLASSES">CLASSES</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">DBI::DBD::SqlEngine::Developers
&minus; Developers documentation for DBI::DBD::SqlEngine</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    package DBD::myDriver;
    use base qw(DBI::DBD::SqlEngine);
    sub driver
    {
        ...
        my $drh = $proto&minus;&gt;SUPER::driver($attr);
        ...
        return $drh&minus;&gt;{class};
    }
    sub CLONE { ... }
    package DBD::myDriver::dr;
    @ISA = qw(DBI::DBD::SqlEngine::dr);
    sub data_sources { ... }
    ...
    package DBD::myDriver::db;
    @ISA = qw(DBI::DBD::SqlEngine::db);
    sub init_valid_attributes { ... }
    sub init_default_attributes { ... }
    sub set_versions { ... }
    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
    sub get_myd_versions { ... }
    sub get_avail_tables { ... }
    package DBD::myDriver::st;
    @ISA = qw(DBI::DBD::SqlEngine::st);
    sub FETCH { ... }
    sub STORE { ... }
    package DBD::myDriver::Statement;
    @ISA = qw(DBI::DBD::SqlEngine::Statement);
    sub open_table { ... }
    package DBD::myDriver::Table;
    @ISA = qw(DBI::DBD::SqlEngine::Table);
    my %reset_on_modify = (
                            myd_abc =&gt; &quot;myd_foo&quot;,
                            myd_mno =&gt; &quot;myd_bar&quot;,
                          );
    __PACKAGE__&minus;&gt;register_reset_on_modify( \%reset_on_modify );
    my %compat_map = (
                       abc =&gt; 'foo_abc',
                       xyz =&gt; 'foo_xyz',
                     );
    __PACKAGE__&minus;&gt;register_compat_map( \%compat_map );
    sub bootstrap_table_meta { ... }
    sub init_table_meta { ... }
    sub table_meta_attr_changed { ... }
    sub open_data { ... }
    sub new { ... }
    sub fetch_row { ... }
    sub push_row { ... }
    sub push_names { ... }
    sub seek { ... }
    sub truncate { ... }
    sub drop { ... }
    # optimize the SQL engine by add one or more of
    sub update_current_row { ... }
    # or
    sub update_specific_row { ... }
    # or
    sub update_one_row { ... }
    # or
    sub insert_new_row { ... }
    # or
    sub delete_current_row { ... }
    # or
    sub delete_one_row { ... }</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
describes the interface of DBI::DBD::SqlEngine for
<small>DBD</small> developers who write DBI::DBD::SqlEngine
based <small>DBI</small> drivers. It supplements
<small>DBI::DBD</small> and DBI::DBD::SqlEngine::HowTo,
which you should read first.</p>

<h2>CLASSES
<a name="CLASSES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Each
<small>DBI</small> driver must provide a package global
<tt>&quot;driver&quot;</tt> method and three
<small>DBI</small> related classes: <br>
DBI::DBD::SqlEngine::dr</p>

<p style="margin-left:17%;">Driver package, contains the
methods <small>DBI</small> calls indirectly via
<small>DBI</small> interface:</p>

<pre style="margin-left:17%; margin-top: 1em">  DBI&minus;&gt;connect ('DBI:DBM:', undef, undef, {})
  # invokes
  package DBD::DBM::dr;
  @DBD::DBM::dr::ISA = qw(DBI::DBD::SqlEngine::dr);
  sub connect ($$;$$$)
  {
      ...
  }</pre>


<p style="margin-left:17%; margin-top: 1em">Similar for
<tt>&quot;data_sources ()&quot;</tt> and
<tt>&quot;disconnect_all()&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Pure Perl
<small>DBI</small> drivers derived from DBI::DBD::SqlEngine
usually don&rsquo;t need to override any of the methods
provided through the DBD::XXX::dr package. However if you
need additional initialization not fitting in
<tt>&quot;init_valid_attributes()&quot;</tt> and
<tt>&quot;init_default_attributes()&quot;</tt> of
you&rsquo;re ::db class, the connect method might be the
final place to be modified.</p>

<p style="margin-left:11%;">DBI::DBD::SqlEngine::db</p>

<p style="margin-left:17%;">Contains the methods which are
called through <small>DBI</small> database handles
(<tt>$dbh</tt>). e.g.,</p>

<pre style="margin-left:17%; margin-top: 1em">  $sth = $dbh&minus;&gt;prepare (&quot;select * from foo&quot;);
  # returns the f_encoding setting for table foo
  $dbh&minus;&gt;csv_get_meta (&quot;foo&quot;, &quot;f_encoding&quot;);</pre>



<p style="margin-left:17%; margin-top: 1em">DBI::DBD::SqlEngine
provides the typical methods required here. Developers who
write <small>DBI</small> drivers based on
DBI::DBD::SqlEngine need to override the methods
<tt>&quot;set_versions&quot;</tt> and
<tt>&quot;init_valid_attributes&quot;</tt>.</p>


<p style="margin-left:11%;">DBI::DBD::SqlEngine::TieMeta;</p>

<p style="margin-left:17%;">Provides the tie-magic for
<tt>&quot;$dbh&minus;&gt;{$drv_pfx .
&quot;_meta&quot;}&quot;</tt>. Routes
<tt>&quot;STORE&quot;</tt> through
<tt>&quot;$drv&minus;&gt;set_sql_engine_meta()&quot;</tt>
and <tt>&quot;FETCH&quot;</tt> through
<tt>&quot;$drv&minus;&gt;get_sql_engine_meta()&quot;</tt>.
<tt>&quot;DELETE&quot;</tt> is not supported, you have to
execute a <tt>&quot;DROP TABLE&quot;</tt> statement, where
applicable.</p>


<p style="margin-left:11%;">DBI::DBD::SqlEngine::TieTables;</p>

<p style="margin-left:17%;">Provides the tie-magic for
tables in <tt>&quot;$dbh&minus;&gt;{$drv_pfx .
&quot;_meta&quot;}&quot;</tt>. Routes
<tt>&quot;STORE&quot;</tt> though
<tt>&quot;$tblClass&minus;&gt;set_table_meta_attr()&quot;</tt>
and <tt>&quot;FETCH&quot;</tt> though
<tt>&quot;$tblClass&minus;&gt;get_table_meta_attr()&quot;</tt>.
<tt>&quot;DELETE&quot;</tt> removes an attribute from the
<i>meta object</i> retrieved by
<tt>&quot;$tblClass&minus;&gt;get_table_meta()&quot;</tt>.</p>

<p style="margin-left:11%;">DBI::DBD::SqlEngine::st</p>

<p style="margin-left:17%;">Contains the methods to deal
with prepared statement handles. e.g.,</p>

<pre style="margin-left:17%; margin-top: 1em">  $sth&minus;&gt;execute () or die $sth&minus;&gt;errstr;</pre>



<p style="margin-left:11%;">DBI::DBD::SqlEngine::TableSource;</p>

<p style="margin-left:17%;">Base class for 3rd party table
sources:</p>

<pre style="margin-left:17%; margin-top: 1em">  $dbh&minus;&gt;{sql_table_source} = &quot;DBD::Foo::TableSource&quot;;</pre>



<p style="margin-left:11%;">DBI::DBD::SqlEngine::DataSource;</p>

<p style="margin-left:17%;">Base class for 3rd party data
sources:</p>

<pre style="margin-left:17%; margin-top: 1em">  $dbh&minus;&gt;{sql_data_source} = &quot;DBD::Foo::DataSource&quot;;</pre>



<p style="margin-left:11%;">DBI::DBD::SqlEngine::Statement;</p>

<p style="margin-left:17%;">Base class for derived drivers
statement engine. Implements
<tt>&quot;open_table&quot;</tt>.</p>


<p style="margin-left:11%;">DBI::DBD::SqlEngine::Table;</p>

<p style="margin-left:17%;">Contains tailoring between
<small>SQL</small> engine&rsquo;s requirements and
<tt>&quot;DBI::DBD::SqlEngine&quot;</tt> magic for finding
the right tables and storage. Builds bridges between
<tt>&quot;sql_meta&quot;</tt> handling of
<tt>&quot;DBI::DBD::SqlEngine::db&quot;</tt>, table
initialization for <small>SQL</small> engines and <i>meta
object</i>&rsquo;s attribute management for derived
drivers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DBI::DBD::SqlEngine</b>
<br>
This is the main package containing the routines to
initialize DBI::DBD::SqlEngine based <small>DBI</small>
drivers. Primarily the
<tt>&quot;DBI::DBD::SqlEngine::driver&quot;</tt> method is
invoked, either directly from <small>DBI</small> when the
driver is initialized or from the derived class.</p>

<pre style="margin-left:11%; margin-top: 1em">  package DBD::DBM;
  use base qw( DBI::DBD::SqlEngine );
  sub driver
  {
      my ( $class, $attr ) = @_;
      ...
      my $drh = $class&minus;&gt;SUPER::driver( $attr );
      ...
      return $drh;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">It is not
necessary to implement your own driver method as long as
additional initialization (e.g. installing more private
driver methods) is not required. You do not need to call
<tt>&quot;setup_driver&quot;</tt> as DBI::DBD::SqlEngine
takes care of it.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DBI::DBD::SqlEngine::dr</b>
<br>
The driver package contains the methods <small>DBI</small>
calls indirectly via the <small>DBI</small> interface (see
&quot; <small>DBI</small> Class Methods&quot; in
<small>DBI</small> ).</p>


<p style="margin-left:11%; margin-top: 1em">DBI::DBD::SqlEngine
based <small>DBI</small> drivers usually do not need to
implement anything here, it is enough to do the basic
initialization:</p>

<pre style="margin-left:11%; margin-top: 1em">  package DBD:XXX::dr;
  @DBD::XXX::dr::ISA = qw (DBI::DBD::SqlEngine::dr);
  $DBD::XXX::dr::imp_data_size     = 0;
  $DBD::XXX::dr::data_sources_attr = undef;
  $DBD::XXX::ATTRIBUTION = &quot;DBD::XXX $DBD::XXX::VERSION by Hans Mustermann&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Methods
provided by &quot;DBI::DBD::SqlEngine::dr&quot;:</i> <br>
connect</p>

<p style="margin-left:17%;">Supervises the driver bootstrap
when calling</p>

<pre style="margin-left:17%; margin-top: 1em">  DBI&minus;&gt;connect( &quot;dbi:Foo&quot;, , , { ... } );</pre>


<p style="margin-left:17%; margin-top: 1em">First it
instantiates a new driver using
<tt>&quot;DBI::_new_dbh&quot;</tt>. After that, initial
bootstrap of the newly instantiated driver is done by</p>

<pre style="margin-left:17%; margin-top: 1em">  $dbh&minus;&gt;func( 0, &quot;init_default_attributes&quot; );</pre>


<p style="margin-left:17%; margin-top: 1em">The first
argument (<tt>0</tt>) signals that this is the very first
call to <tt>&quot;init_default_attributes&quot;</tt>. Modern
drivers understand that and do early stage setup here after
calling</p>

<pre style="margin-left:17%; margin-top: 1em">  package DBD::Foo::db;
  our @DBD::Foo::db::ISA = qw(DBI::DBD::SqlEngine::db);
  sub init_default_attributes
  {
    my ($dbh, $phase) = @_;
    $dbh&minus;&gt;SUPER::init_default_attributes($phase);
    ...; # own setup code, maybe separated by phases
  }</pre>


<p style="margin-left:17%; margin-top: 1em">When the
<tt>$phase</tt> argument is passed down until
<tt>&quot;DBI::DBD::SqlEngine::db::init_default_attributes&quot;</tt>,
<tt>&quot;connect()&quot;</tt> recognizes a <i>modern</i>
driver and initializes the attributes from
<i><small>DSN</small></i> and <i>$attr</i> arguments passed
via <tt>&quot;DBI&minus;&gt;connect( $dsn, $user, $pass,
\%attr )&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">At the end of
the attribute initialization after <i>phase 0</i>,
<tt>&quot;connect()&quot;</tt> invoked
<tt>&quot;init_default_attributes&quot;</tt> again for
<i>phase 1</i>:</p>

<pre style="margin-left:17%; margin-top: 1em">  $dbh&minus;&gt;func( 1, &quot;init_default_attributes&quot; );</pre>


<p style="margin-left:11%;">data_sources</p>

<p style="margin-left:17%;">Returns a list of
<i><small>DSN</small></i> &rsquo;s using the
<tt>&quot;data_sources&quot;</tt> method of the class
specified in
<tt>&quot;$dbh&minus;&gt;{sql_table_source}&quot;</tt> or
via <tt>&quot;\%attr&quot;</tt>:</p>

<pre style="margin-left:17%; margin-top: 1em">  @ary = DBI&minus;&gt;data_sources($driver);
  @ary = DBI&minus;&gt;data_sources($driver, \%attr);</pre>


<p style="margin-left:11%;">disconnect_all</p>


<p style="margin-left:17%;"><tt>&quot;DBI::DBD::SqlEngine&quot;</tt>
doesn&rsquo;t have an overall driver cache, so nothing
happens here at all.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DBI::DBD::SqlEngine::db</b>
<br>
This package defines the database methods, which are called
via the <small>DBI</small> database handle
<tt>$dbh</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Methods
provided by &quot;DBI::DBD::SqlEngine::db&quot;:</i> <br>
ping</p>

<p style="margin-left:17%;">Simply returns the content of
the <tt>&quot;Active&quot;</tt> attribute. Override when
your driver needs more complicated actions here.</p>

<p style="margin-left:11%;">prepare</p>

<p style="margin-left:17%;">Prepares a new
<small>SQL</small> statement to execute. Returns a statement
handle, <tt>$sth</tt> &minus; instance of the DBD:XXX::st.
It is neither required nor recommended to override this
method.</p>

<p style="margin-left:11%;">validate_FETCH_attr</p>

<p style="margin-left:17%;">Called by
<tt>&quot;FETCH&quot;</tt> to allow inherited drivers do
their own attribute name validation. Calling convention is
similar to <tt>&quot;FETCH&quot;</tt> and the return value
is the approved attribute name.</p>

<pre style="margin-left:17%; margin-top: 1em">    return $validated_attribute_name;</pre>


<p style="margin-left:17%; margin-top: 1em">In case of
validation fails (e.g. accessing private attribute or
similar), <tt>&quot;validate_FETCH_attr&quot;</tt> is
permitted to throw an exception.</p>

<p style="margin-left:11%;"><small>FETCH</small></p>

<p style="margin-left:17%;">Fetches an attribute of a
<small>DBI</small> database object. Private handle
attributes must have a prefix (this is mandatory). If a
requested attribute is detected as a private attribute
without a valid prefix, the driver prefix (written as
<tt>$drv_prefix</tt>) is added.</p>

<p style="margin-left:17%; margin-top: 1em">The driver
prefix is extracted from the attribute name and verified
against <tt>&quot;$dbh&minus;&gt;{ $drv_prefix .
&quot;valid_attrs&quot; }&quot;</tt> (when it exists). If
the requested attribute value is not listed as a valid
attribute, this method croaks. If the attribute is valid and
readonly (listed in <tt>&quot;$dbh&minus;&gt;{ $drv_prefix .
&quot;readonly_attrs&quot; }&quot;</tt> when it exists), a
real copy of the attribute value is returned. So it&rsquo;s
not possible to modify <tt>&quot;f_valid_attrs&quot;</tt>
from outside of DBI::DBD::SqlEngine::db or a derived
class.</p>

<p style="margin-left:11%;">validate_STORE_attr</p>

<p style="margin-left:17%;">Called by
<tt>&quot;STORE&quot;</tt> to allow inherited drivers do
their own attribute name validation. Calling convention is
similar to <tt>&quot;STORE&quot;</tt> and the return value
is the approved attribute name followed by the approved new
value.</p>

<pre style="margin-left:17%; margin-top: 1em">    return ($validated_attribute_name, $validated_attribute_value);</pre>


<p style="margin-left:17%; margin-top: 1em">In case of
validation fails (e.g. accessing private attribute or
similar), <tt>&quot;validate_STORE_attr&quot;</tt> is
permitted to throw an exception
(<tt>&quot;DBI::DBD::SqlEngine::db::validate_STORE_attr&quot;</tt>
throws an exception when someone tries to assign value other
than <tt>&quot;SQL_IC_UPPER .. SQL_IC_MIXED&quot;</tt> to
<tt>&quot;$dbh&minus;&gt;{sql_identifier_case}&quot;</tt> or
<tt>&quot;$dbh&minus;&gt;{sql_quoted_identifier_case}&quot;</tt>).</p>

<p style="margin-left:11%;"><small>STORE</small></p>

<p style="margin-left:17%;">Stores a database private
attribute. Private handle attributes must have a prefix
(this is mandatory). If a requested attribute is detected as
a private attribute without a valid prefix, the driver
prefix (written as <tt>$drv_prefix</tt>) is added. If the
database handle has an attribute
<tt>&quot;${drv_prefix}_valid_attrs&quot;</tt> &minus; for
attribute names which are not listed in that hash, this
method croaks. If the database handle has an attribute
<tt>&quot;${drv_prefix}_readonly_attrs&quot;</tt>, only
attributes which are not listed there can be stored (once
they are initialized). Trying to overwrite such an immutable
attribute forces this method to croak.</p>

<p style="margin-left:17%; margin-top: 1em">An example of a
valid attributes list can be found in
<tt>&quot;DBI::DBD::SqlEngine::db::init_valid_attributes&quot;</tt>.</p>

<p style="margin-left:11%;">set_versions</p>

<p style="margin-left:17%;">This method sets the attributes
<tt>&quot;f_version&quot;</tt>,
<tt>&quot;sql_nano_version&quot;</tt>,
<tt>&quot;sql_statement_version&quot;</tt> and (if not
prohibited by a restrictive
<tt>&quot;${prefix}_valid_attrs&quot;</tt>)
<tt>&quot;${prefix}_version&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">This method is
called at the end of the <tt>&quot;connect ()&quot;</tt>
phase.</p>

<p style="margin-left:17%; margin-top: 1em">When overriding
this method, do not forget to invoke the superior one.</p>

<p style="margin-left:11%;">init_valid_attributes</p>

<p style="margin-left:17%;">This method is called after the
database handle is instantiated as the first attribute
initialization.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;DBI::DBD::SqlEngine::db::init_valid_attributes&quot;</tt>
initializes the attributes
<tt>&quot;sql_valid_attrs&quot;</tt> and
<tt>&quot;sql_readonly_attrs&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">When overriding
this method, do not forget to invoke the superior one,
preferably before doing anything else.</p>

<p style="margin-left:11%;">init_default_attributes</p>

<p style="margin-left:17%;">This method is called after the
database handle is instantiated to initialize the default
attributes. It expects one argument: <tt>$phase</tt>. If
<tt>$phase</tt> is not given, <tt>&quot;connect&quot;</tt>
of <tt>&quot;DBI::DBD::SqlEngine::dr&quot;</tt> expects this
is an old-fashioned driver which isn&rsquo;t capable of
multi-phased initialization.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;DBI::DBD::SqlEngine::db::init_default_attributes&quot;</tt>
initializes the attributes
<tt>&quot;sql_identifier_case&quot;</tt>,
<tt>&quot;sql_quoted_identifier_case&quot;</tt>,
<tt>&quot;sql_handler&quot;</tt>,
<tt>&quot;sql_init_order&quot;</tt>,
<tt>&quot;sql_meta&quot;</tt>,
<tt>&quot;sql_engine_version&quot;</tt>,
<tt>&quot;sql_nano_version&quot;</tt> and
<tt>&quot;sql_statement_version&quot;</tt> when
SQL::Statement is available.</p>

<p style="margin-left:17%; margin-top: 1em">It sets
<tt>&quot;sql_init_order&quot;</tt> to the given
<tt>$phase</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">When the
derived implementor class provides the attribute to validate
attributes (e.g. <tt>&quot;$dbh&minus;&gt;{dbm_valid_attrs}
= {...};&quot;</tt>) or the attribute containing the
immutable attributes (e.g.
<tt>&quot;$dbh&minus;&gt;{dbm_readonly_attrs} =
{...};&quot;</tt>), the attributes
<tt>&quot;drv_valid_attrs&quot;</tt>,
<tt>&quot;drv_readonly_attrs&quot;</tt> and
<tt>&quot;drv_version&quot;</tt> are added (when available)
to the list of valid and immutable attributes (where
<tt>&quot;drv_&quot;</tt> is interpreted as the driver
prefix).</p>

<p style="margin-left:11%;">get_versions</p>

<p style="margin-left:17%;">This method is called by the
code injected into the instantiated driver to provide the
user callable driver method
<tt>&quot;${prefix}versions&quot;</tt> (e.g.
<tt>&quot;dbm_versions&quot;</tt>,
<tt>&quot;csv_versions&quot;</tt>, ...).</p>

<p style="margin-left:17%; margin-top: 1em">The
DBI::DBD::SqlEngine implementation returns all version
information known by DBI::DBD::SqlEngine (e.g.
<small>DBI</small> version, Perl version,
DBI::DBD::SqlEngine version and the <small>SQL</small>
handler version).</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;get_versions&quot;</tt>
takes the <tt>$dbh</tt> as the first argument and optionally
a second argument containing a table name. The second
argument is not evaluated in
<tt>&quot;DBI::DBD::SqlEngine::db::get_versions&quot;</tt>
itself &minus; but might be in the future.</p>

<p style="margin-left:17%; margin-top: 1em">If the derived
implementor class provides a method named
<tt>&quot;get_${drv_prefix}versions&quot;</tt>, this is
invoked and the return value of it is associated to the
derived driver name:</p>

<pre style="margin-left:17%; margin-top: 1em">    if (my $dgv = $dbh&minus;&gt;{ImplementorClass}&minus;&gt;can (&quot;get_&quot; . $drv_prefix . &quot;versions&quot;) {
        (my $derived_driver = $dbh&minus;&gt;{ImplementorClass}) =~ s/::db$//;
        $versions{$derived_driver} = &amp;$dgv ($dbh, $table);
    }</pre>


<p style="margin-left:17%; margin-top: 1em">Override it to
add more version information about your module, (e.g. some
kind of parser version in case of <small>DBD::CSV,
...</small> ), if one line is not enough room to provide all
relevant information.</p>

<p style="margin-left:11%;">sql_parser_object</p>

<p style="margin-left:17%;">Returns a SQL::Parser instance,
when <tt>&quot;sql_handler&quot;</tt> is set to
&quot;SQL::Statement&quot;. The parser instance is stored in
<tt>&quot;sql_parser_object&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">It is not
recommended to override this method.</p>

<p style="margin-left:11%;">disconnect</p>

<p style="margin-left:17%;">Disconnects from a database.
All local table information is discarded and the
<tt>&quot;Active&quot;</tt> attribute is set to 0.</p>

<p style="margin-left:11%;">type_info_all</p>

<p style="margin-left:17%;">Returns information about all
the types supported by DBI::DBD::SqlEngine.</p>

<p style="margin-left:11%;">table_info</p>

<p style="margin-left:17%;">Returns a statement handle
which is prepared to deliver information about all known
tables.</p>

<p style="margin-left:11%;">list_tables</p>

<p style="margin-left:17%;">Returns a list of all known
table names.</p>

<p style="margin-left:11%;">quote</p>

<p style="margin-left:17%;">Quotes a string for use in
<small>SQL</small> statements.</p>

<p style="margin-left:11%;">commit</p>

<p style="margin-left:17%;">Warns about a useless call (if
warnings enabled) and returns. DBI::DBD::SqlEngine is
typically a driver which commits every action instantly when
executed.</p>

<p style="margin-left:11%;">rollback</p>

<p style="margin-left:17%;">Warns about a useless call (if
warnings enabled) and returns. DBI::DBD::SqlEngine is
typically a driver which commits every action instantly when
executed.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Attributes
used by &quot;DBI::DBD::SqlEngine::db&quot;:</i></p>

<p style="margin-left:11%; margin-top: 1em">This section
describes attributes which are important to developers of
<small>DBI</small> Database Drivers derived from
<tt>&quot;DBI::DBD::SqlEngine&quot;</tt>. <br>
sql_init_order</p>

<p style="margin-left:17%;">This attribute contains a hash
with priorities as key and an array containing the
<tt>$dbh</tt> attributes to be initialized during
before/after other attributes.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;DBI::DBD::SqlEngine&quot;</tt>
initializes following attributes:</p>

<pre style="margin-left:17%; margin-top: 1em">  $dbh&minus;&gt;{sql_init_order} = {
       0 =&gt; [qw( Profile RaiseError PrintError AutoCommit )],
      90 =&gt; [ &quot;sql_meta&quot;, $dbh&minus;&gt;{$drv_pfx_meta} ? $dbh&minus;&gt;{$drv_pfx_meta} : () ]
  }</pre>


<p style="margin-left:17%; margin-top: 1em">The default
priority of not listed attribute keys is <tt>50</tt>. It is
well known that a lot of attributes needed to be set before
some table settings are initialized. For example, for
<small>DBD::DBM</small> , when using</p>

<pre style="margin-left:17%; margin-top: 1em">  my $dbh = DBI&minus;&gt;connect( &quot;dbi:DBM:&quot;, undef, undef, {
      f_dir =&gt; &quot;/path/to/dbm/databases&quot;,
      dbm_type =&gt; &quot;BerkeleyDB&quot;,
      dbm_mldbm =&gt; &quot;JSON&quot;, # use MLDBM::Serializer::JSON
      dbm_tables =&gt; {
          quick =&gt; {
              dbm_type =&gt; &quot;GDBM_File&quot;,
              dbm_MLDBM =&gt; &quot;FreezeThaw&quot;
          }
      }
  });</pre>


<p style="margin-left:17%; margin-top: 1em">This defines a
known table <tt>&quot;quick&quot;</tt> which uses the
GDBM_File backend and FreezeThaw as serializer instead of
the overall default BerkeleyDB and <small>JSON</small> .
<b>But</b> all files containing the table data have to be
searched in <tt>&quot;$dbh&minus;&gt;{f_dir}&quot;</tt>,
which requires <tt>&quot;$dbh&minus;&gt;{f_dir}&quot;</tt>
must be initialized before
<tt>&quot;$dbh&minus;&gt;{sql_meta}&minus;&gt;{quick}&quot;</tt>
is initialized by <tt>&quot;bootstrap_table_meta&quot;</tt>
method of &quot;DBI::DBD::SqlEngine::Table&quot; to get
<tt>&quot;$dbh&minus;&gt;{sql_meta}&minus;&gt;{quick}&minus;&gt;{f_dir}&quot;</tt>
being initialized properly.</p>

<p style="margin-left:11%;">sql_init_phase</p>

<p style="margin-left:17%;">This attribute is only set
during the initialization steps of the <small>DBI</small>
Database Driver. It contains the value of the currently run
initialization phase. Currently supported phases are
<i>phase 0</i> and <i>phase 1</i>. This attribute is set in
<tt>&quot;init_default_attributes&quot;</tt> and removed in
<tt>&quot;init_done&quot;</tt>.</p>

<p style="margin-left:11%;">sql_engine_in_gofer</p>

<p style="margin-left:17%;">This value has a true value in
case of this driver is operated via DBD::Gofer. The impact
of being operated via Gofer is a read-only driver (not
read-only databases!), so you cannot modify any attributes
later &minus; neither any table settings. <b>But</b> you
won&rsquo;t get an error in cases you modify table
attributes, so please carefully watch
<tt>&quot;sql_engine_in_gofer&quot;</tt>.</p>

<p style="margin-left:11%;">sql_table_source</p>

<p style="margin-left:17%;">Names a class which is
responsible for delivering <i>data sources</i> and
<i>available tables</i> (Database Driver related). <i>data
sources</i> here refers to &quot;data_sources&quot; in
<small>DBI</small> , not
<tt>&quot;sql_data_source&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;DBI::DBD::SqlEngine::TableSource&quot; for
details.</p>

<p style="margin-left:11%;">sql_data_source</p>

<p style="margin-left:17%;">Name a class which is
responsible for handling table resources open and completing
table names requested via <small>SQL</small> statements.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;DBI::DBD::SqlEngine::DataSource&quot; for details.</p>

<p style="margin-left:11%;">sql_dialect</p>

<p style="margin-left:17%;">Controls the dialect understood
by SQL::Parser. Possible values (delivery state of
SQL::Statement):</p>

<pre style="margin-left:17%; margin-top: 1em">  * ANSI
  * CSV
  * AnyData</pre>


<p style="margin-left:17%; margin-top: 1em">Defaults to
&quot; <small>CSV&quot;.</small> Because an SQL::Parser is
instantiated only once and SQL::Parser doesn&rsquo;t allow
to modify the dialect once instantiated, it&rsquo;s strongly
recommended to set this flag before any statement is
executed (best place is connect attribute hash).</p>


<p style="margin-left:11%; margin-top: 1em"><b>DBI::DBD::SqlEngine::st</b>
<br>
Contains the methods to deal with prepared statement
handles: <br>
bind_param</p>

<p style="margin-left:17%;">Common routine to bind
placeholders to a statement for execution. It is dangerous
to override this method without detailed knowledge about the
DBI::DBD::SqlEngine internal storage structure.</p>

<p style="margin-left:11%;">execute</p>

<p style="margin-left:17%;">Executes a previously prepared
statement (with placeholders, if any).</p>

<p style="margin-left:11%;">finish</p>

<p style="margin-left:17%;">Finishes a statement handle,
discards all buffered results. The prepared statement is not
discarded so the statement can be executed again.</p>

<p style="margin-left:11%;">fetch</p>

<p style="margin-left:17%;">Fetches the next row from the
result-set. This method may be rewritten in a later version
and if it&rsquo;s overridden in a derived class, the derived
implementation should not rely on the storage details.</p>

<p style="margin-left:11%;">fetchrow_arrayref</p>

<p style="margin-left:17%;">Alias for
<tt>&quot;fetch&quot;</tt>.</p>

<p style="margin-left:11%;"><small>FETCH</small></p>

<p style="margin-left:17%;">Fetches statement handle
attributes. Supported attributes (for full overview see
&quot;Statement Handle Attributes&quot; in
<small>DBI</small> ) are <tt>&quot;NAME&quot;</tt>,
<tt>&quot;TYPE&quot;</tt>, <tt>&quot;PRECISION&quot;</tt>
and <tt>&quot;NULLABLE&quot;</tt>. Each column is returned
as <tt>&quot;NULLABLE&quot;</tt> which might be wrong
depending on the derived backend storage. If the statement
handle has private attributes, they can be fetched using
this method, too. <b>Note</b> that statement attributes are
not associated with any table used in this statement.</p>

<p style="margin-left:17%; margin-top: 1em">This method
usually requires extending in a derived implementation. See
<small>DBD::CSV</small> or <small>DBD::DBM</small> for some
example.</p>

<p style="margin-left:11%;"><small>STORE</small></p>

<p style="margin-left:17%;">Allows storing of statement
private attributes. No special handling is currently
implemented here.</p>

<p style="margin-left:11%;">rows</p>

<p style="margin-left:17%;">Returns the number of rows
affected by the last execute. This method might return
<tt>&quot;undef&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DBI::DBD::SqlEngine::TableSource</b>
<br>
Provides data sources and table information on database
driver and database handle level.</p>

<pre style="margin-left:11%; margin-top: 1em">  package DBI::DBD::SqlEngine::TableSource;
  sub data_sources ($;$)
  {
    my ( $class, $drh, $attrs ) = @_;
    ...
  }
  sub avail_tables
  {
    my ( $class, $drh ) = @_;
    ...
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;data_sources&quot;</tt> method is called when the
user invokes any of the following:</p>

<pre style="margin-left:11%; margin-top: 1em">  @ary = DBI&minus;&gt;data_sources($driver);
  @ary = DBI&minus;&gt;data_sources($driver, \%attr);
  @ary = $dbh&minus;&gt;data_sources();
  @ary = $dbh&minus;&gt;data_sources(\%attr);</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;avail_tables&quot;</tt> method is called when the
user invokes any of the following:</p>

<pre style="margin-left:11%; margin-top: 1em">  @names = $dbh&minus;&gt;tables( $catalog, $schema, $table, $type );
  $sth = $dbh&minus;&gt;table_info( $catalog, $schema, $table, $type );
  $sth = $dbh&minus;&gt;table_info( $catalog, $schema, $table, $type, \%attr );
  $dbh&minus;&gt;func( &quot;list_tables&quot; );</pre>


<p style="margin-left:11%; margin-top: 1em">Every time
where an <tt>&quot;\%attr&quot;</tt> argument can be
specified, this <tt>&quot;\%attr&quot;</tt> object&rsquo;s
<tt>&quot;sql_table_source&quot;</tt> attribute is preferred
over the <tt>$dbh</tt> attribute or the driver default.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DBI::DBD::SqlEngine::DataSource</b>
<br>
Provides base functionality for dealing with tables. It is
primarily designed for allowing transparent access to files
on disk or already opened (file&minus;)streams (e.g. for
<small>DBD::CSV</small> ).</p>

<p style="margin-left:11%; margin-top: 1em">Derived classes
shall be restricted to similar functionality, too (e.g.
opening streams from an archive, transparently
compress/uncompress log files before parsing them,</p>

<pre style="margin-left:11%; margin-top: 1em">  package DBI::DBD::SqlEngine::DataSource;
  sub complete_table_name ($$;$)
  {
    my ( $self, $meta, $table, $respect_case ) = @_;
    ...
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The method
<tt>&quot;complete_table_name&quot;</tt> is called when
first setting up the <i>meta information</i> for a
table:</p>

<pre style="margin-left:11%; margin-top: 1em">  &quot;SELECT user.id, user.name, user.shell FROM user WHERE ...&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">results in
opening the table <tt>&quot;user&quot;</tt>. First step of
the table open process is completing the name. Let&rsquo;s
imagine you&rsquo;re having a <small>DBD::CSV</small> handle
with following settings:</p>

<pre style="margin-left:11%; margin-top: 1em">  $dbh&minus;&gt;{sql_identifier_case} = SQL_IC_LOWER;
  $dbh&minus;&gt;{f_ext} = '.lst';
  $dbh&minus;&gt;{f_dir} = '/data/web/adrmgr';</pre>


<p style="margin-left:11%; margin-top: 1em">Those settings
will result in looking for files matching
<tt>&quot;[Uu][Ss][Ee][Rr](\.lst)?$&quot;</tt> in
<tt>&quot;/data/web/adrmgr/&quot;</tt>. The scanning of the
directory <tt>&quot;/data/web/adrmgr/&quot;</tt> and the
pattern match check will be done in
<tt>&quot;DBD::File::DataSource::File&quot;</tt> by the
<tt>&quot;complete_table_name&quot;</tt> method.</p>

<p style="margin-left:11%; margin-top: 1em">If you intend
to provide other sources of data streams than files, in
addition to provide an appropriate
<tt>&quot;complete_table_name&quot;</tt> method, a method to
open the resource is required:</p>

<pre style="margin-left:11%; margin-top: 1em">  package DBI::DBD::SqlEngine::DataSource;
  sub open_data ($)
  {
    my ( $self, $meta, $attrs, $flags ) = @_;
    ...
  }</pre>


<p style="margin-left:11%; margin-top: 1em">After the
method <tt>&quot;open_data&quot;</tt> has been run
successfully, the table&rsquo;s meta information are in a
state which allows the table&rsquo;s data accessor methods
will be able to fetch/store row information. Implementation
details heavily depends on the table implementation, whereby
the most famous is surely DBD::File::Table.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DBI::DBD::SqlEngine::Statement</b>
<br>
Derives from DBI::SQL::Nano::Statement for unified naming
when deriving new drivers. No additional feature is provided
from here.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DBI::DBD::SqlEngine::Table</b>
<br>
Derives from DBI::SQL::Nano::Table for unified naming when
deriving new drivers.</p>

<p style="margin-left:11%; margin-top: 1em">You should
consult the documentation of
<tt>&quot;SQL::Eval::Table&quot;</tt> (see SQL::Eval) to get
more information about the abstract methods of the
table&rsquo;s base class you have to override and a
description of the table meta information expected by the
<small>SQL</small> engines. <br>
bootstrap_table_meta</p>

<p style="margin-left:17%;">Initializes a table meta
structure. Can be safely overridden in a derived class, as
long as the <tt>&quot;SUPER&quot;</tt> method is called at
the end of the overridden method.</p>

<p style="margin-left:17%; margin-top: 1em">It copies the
following attributes from the database into the table meta
data <tt>&quot;$dbh&minus;&gt;{ReadOnly}&quot;</tt> into
<tt>&quot;$meta&minus;&gt;{readonly}&quot;</tt>,
<tt>&quot;sql_identifier_case&quot;</tt> and
<tt>&quot;sql_data_source&quot;</tt> and makes them sticky
to the table.</p>

<p style="margin-left:17%; margin-top: 1em">This method
should be called before you attempt to map between file name
and table name to ensure the correct directory, extension
etc. are used.</p>

<p style="margin-left:11%;">init_table_meta</p>

<p style="margin-left:17%;">Initializes more attributes of
the table meta data &minus; usually more expensive ones
(e.g. those which require class instantiations) &minus; when
the file name and the table name could mapped.</p>

<p style="margin-left:11%;">get_table_meta</p>

<p style="margin-left:17%;">Returns the table meta data. If
there are none for the required table, a new one is
initialized. When after bootstrapping a new
<i>table_meta</i> and completing the table name a mapping
can be established between an existing <i>table_meta</i> and
the new bootstrapped one, the already existing is used and a
mapping shortcut between the recent used table name and the
already known table name is hold in
<tt>&quot;$dbh&minus;&gt;{sql_meta_map}&quot;</tt>. When it
fails, nothing is returned. On success, the name of the
table and the meta data structure is returned.</p>

<p style="margin-left:11%;">get_table_meta_attr</p>

<p style="margin-left:17%;">Returns a single attribute from
the table meta data. If the attribute name appears in
<tt>%compat_map</tt>, the attribute name is updated from
there.</p>

<p style="margin-left:11%;">set_table_meta_attr</p>

<p style="margin-left:17%;">Sets a single attribute in the
table meta data. If the attribute name appears in
<tt>%compat_map</tt>, the attribute name is updated from
there.</p>

<p style="margin-left:11%;">table_meta_attr_changed</p>

<p style="margin-left:17%;">Called when an attribute of the
meta data is modified.</p>

<p style="margin-left:17%; margin-top: 1em">If the modified
attribute requires to reset a calculated attribute, the
calculated attribute is reset (deleted from meta data
structure) and the <i>initialized</i> flag is removed, too.
The decision is made based on
<tt>%register_reset_on_modify</tt>.</p>

<p style="margin-left:11%;">register_reset_on_modify</p>

<p style="margin-left:17%;">Allows
<tt>&quot;set_table_meta_attr&quot;</tt> to reset meta
attributes when special attributes are modified. For
DBD::File, modifying one of <tt>&quot;f_file&quot;</tt>,
<tt>&quot;f_dir&quot;</tt>, <tt>&quot;f_ext&quot;</tt> or
<tt>&quot;f_lockfile&quot;</tt> will reset
<tt>&quot;f_fqfn&quot;</tt>. <small>DBD::DBM</small> extends
the list for <tt>&quot;dbm_type&quot;</tt> and
<tt>&quot;dbm_mldbm&quot;</tt> to reset the value of
<tt>&quot;dbm_tietype&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If your
<small>DBD</small> has calculated values in the meta data
area, then call
<tt>&quot;register_reset_on_modify&quot;</tt>:</p>

<pre style="margin-left:17%; margin-top: 1em">    my %reset_on_modify = ( &quot;xxx_foo&quot; =&gt; &quot;xxx_bar&quot; );
    __PACKAGE__&minus;&gt;register_reset_on_modify( \%reset_on_modify );</pre>


<p style="margin-left:11%;">register_compat_map</p>

<p style="margin-left:17%;">Allows
<tt>&quot;get_table_meta_attr&quot;</tt> and
<tt>&quot;set_table_meta_attr&quot;</tt> to update the
attribute name to the current favored one:</p>

<pre style="margin-left:17%; margin-top: 1em">    # from DBD::DBM
    my %compat_map = ( &quot;dbm_ext&quot; =&gt; &quot;f_ext&quot; );
    __PACKAGE__&minus;&gt;register_compat_map( \%compat_map );</pre>


<p style="margin-left:11%;">open_data</p>

<p style="margin-left:17%;">Called to open the
table&rsquo;s data storage. This is silently forwarded to
<tt>&quot;$meta&minus;&gt;{sql_data_source}&minus;&gt;open_data()&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">After this is
done, a derived class might add more steps in an overridden
<tt>&quot;open_file&quot;</tt> method.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>new</p></td>
<td width="2%"></td>
<td width="74%">


<p>Instantiates the table. This is done in 3 steps:</p></td>
<td width="9%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> 1. get the table meta data
 2. open the data file
 3. bless the table data structure using inherited constructor new</pre>


<p style="margin-left:17%; margin-top: 1em">It is not
recommended to override the constructor of the table class.
Find a reasonable place to add you extensions in one of the
above four methods.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The module
DBI::DBD::SqlEngine is currently maintained by</p>

<p style="margin-left:11%; margin-top: 1em">H.Merijn Brand
&lt; h.m.brand at xs4all.nl &gt; and Jens Rehsack &lt;
rehsack at googlemail.com &gt;</p>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2010 by H.Merijn Brand &amp; Jens Rehsack</p>

<p style="margin-left:11%; margin-top: 1em">All rights
reserved.</p>

<p style="margin-left:11%; margin-top: 1em">You may freely
distribute and/or modify this module under the terms of
either the <small>GNU</small> General Public License (
<small>GPL</small> ) or the Artistic License, as specified
in the Perl <small>README</small> file.</p>
<hr>
</body>
</html>
