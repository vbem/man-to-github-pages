<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:00 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLDATA</title>

</head>
<body>

<h1 align="center">PERLDATA</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perldata
&minus; Perl data types</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Variable
names</b> <br>
Perl has three built-in data types: scalars, arrays of
scalars, and associative arrays of scalars, known as
&quot;hashes&quot;. A scalar is a single string (of any
size, limited only by the available memory), number, or a
reference to something (which will be discussed in perlref).
Normal arrays are ordered lists of scalars indexed by
number, starting with 0. Hashes are unordered collections of
scalar values indexed by their associated string key.</p>

<p style="margin-left:11%; margin-top: 1em">Values are
usually referred to by name, or through a named reference.
The first character of the name tells you to what sort of
data structure it refers. The rest of the name tells you the
particular value to which it refers. Usually this name is a
single <i>identifier</i>, that is, a string beginning with a
letter or underscore, and containing letters, underscores,
and digits. In some cases, it may be a chain of identifiers,
separated by <tt>&quot;::&quot;</tt> (or by the slightly
archaic <tt>&quot;'&quot;</tt>); all but the last are
interpreted as names of packages, to locate the namespace in
which to look up the final identifier (see
&quot;Packages&quot; in perlmod for details). It&rsquo;s
possible to substitute for a simple identifier, an
expression that produces a reference to the value at
runtime. This is described in more detail below and in
perlref.</p>

<p style="margin-left:11%; margin-top: 1em">Perl also has
its own built-in variables whose names don&rsquo;t follow
these rules. They have strange names so they don&rsquo;t
accidentally collide with one of your normal variables.
Strings that match parenthesized parts of a regular
expression are saved under names containing only digits
after the <tt>&quot;$&quot;</tt> (see perlop and perlre). In
addition, several special variables that provide windows
into the inner working of Perl have names containing
punctuation characters and control characters. These are
documented in perlvar.</p>

<p style="margin-left:11%; margin-top: 1em">Scalar values
are always named with &rsquo;$&rsquo;, even when referring
to a scalar that is part of an array or a hash. The
&rsquo;$&rsquo; symbol works semantically like the English
word &quot;the&quot; in that it indicates a single value is
expected.</p>

<pre style="margin-left:11%; margin-top: 1em">    $days               # the simple scalar value &quot;days&quot;
    $days[28]           # the 29th element of array @days
    $days{'Feb'}        # the 'Feb' value from hash %days
    $#days              # the last index of array @days</pre>


<p style="margin-left:11%; margin-top: 1em">Entire arrays
(and slices of arrays and hashes) are denoted by
&rsquo;@&rsquo;, which works much as the word
&quot;these&quot; or &quot;those&quot; does in English, in
that it indicates multiple values are expected.</p>

<pre style="margin-left:11%; margin-top: 1em">    @days               # ($days[0], $days[1],... $days[n])
    @days[3,4,5]        # same as ($days[3],$days[4],$days[5])
    @days{'a','c'}      # same as ($days{'a'},$days{'c'})</pre>


<p style="margin-left:11%; margin-top: 1em">Entire hashes
are denoted by &rsquo;%&rsquo;:</p>

<pre style="margin-left:11%; margin-top: 1em">    %days               # (key1, val1, key2, val2 ...)</pre>


<p style="margin-left:11%; margin-top: 1em">In addition,
subroutines are named with an initial &rsquo;&amp;&rsquo;,
though this is optional when unambiguous, just as the word
&quot;do&quot; is often redundant in English. Symbol table
entries can be named with an initial &rsquo;*&rsquo;, but
you don&rsquo;t really care about that yet (if ever
:&minus;).</p>

<p style="margin-left:11%; margin-top: 1em">Every variable
type has its own namespace, as do several non-variable
identifiers. This means that you can, without fear of
conflict, use the same name for a scalar variable, an array,
or a hash--or, for that matter, for a filehandle, a
directory handle, a subroutine name, a format name, or a
label. This means that <tt>$foo</tt> and <tt>@foo</tt> are
two different variables. It also means that <tt>$foo[1]</tt>
is a part of <tt>@foo</tt>, not a part of <tt>$foo</tt>.
This may seem a bit weird, but that&rsquo;s okay, because it
is weird.</p>

<p style="margin-left:11%; margin-top: 1em">Because
variable references always start with &rsquo;$&rsquo;,
&rsquo;@&rsquo;, or &rsquo;%&rsquo;, the
&quot;reserved&quot; words aren&rsquo;t in fact reserved
with respect to variable names. They <i>are</i> reserved
with respect to labels and filehandles, however, which
don&rsquo;t have an initial special character. You
can&rsquo;t have a filehandle named &quot;log&quot;, for
instance. Hint: you could say
<tt>&quot;open(LOG,'logfile')&quot;</tt> rather than
<tt>&quot;open(log,'logfile')&quot;</tt>. Using uppercase
filehandles also improves readability and protects you from
conflict with future reserved words. Case <i>is</i>
significant&minus;&minus;&quot; <small>FOO</small> &quot;,
&quot;Foo&quot;, and &quot;foo&quot; are all different
names. Names that start with a letter or underscore may also
contain digits and underscores.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to replace such an alphanumeric name with an expression that
returns a reference to the appropriate type. For a
description of this, see perlref.</p>

<p style="margin-left:11%; margin-top: 1em">Names that
start with a digit may contain only more digits. Names that
do not start with a letter, underscore, digit or a caret
(i.e. a control character) are limited to one character,
e.g., <tt>$%</tt> or <tt>$$</tt>. (Most of these one
character names have a predefined significance to Perl. For
instance, <tt>$$</tt> is the current process id.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Context</b>
<br>
The interpretation of operations and values in Perl
sometimes depends on the requirements of the context around
the operation or value. There are two major contexts: list
and scalar. Certain operations return list values in
contexts wanting a list, and scalar values otherwise. If
this is true of an operation it will be mentioned in the
documentation for that operation. In other words, Perl
overloads certain operations based on whether the expected
return value is singular or plural. Some words in English
work this way, like &quot;fish&quot; and
&quot;sheep&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">In a reciprocal
fashion, an operation provides either a scalar or a list
context to each of its arguments. For example, if you
say</p>

<pre style="margin-left:11%; margin-top: 1em">    int( &lt;STDIN&gt; )</pre>


<p style="margin-left:11%; margin-top: 1em">the integer
operation provides scalar context for the &lt;&gt; operator,
which responds by reading one line from <small>STDIN</small>
and passing it back to the integer operation, which will
then find the integer value of that line and return that.
If, on the other hand, you say</p>

<pre style="margin-left:11%; margin-top: 1em">    sort( &lt;STDIN&gt; )</pre>


<p style="margin-left:11%; margin-top: 1em">then the sort
operation provides list context for &lt;&gt;, which will
proceed to read every line available up to the end of file,
and pass that list of lines back to the sort routine, which
will then sort those lines and return them as a list to
whatever the context of the sort was.</p>

<p style="margin-left:11%; margin-top: 1em">Assignment is a
little bit special in that it uses its left argument to
determine the context for the right argument. Assignment to
a scalar evaluates the right-hand side in scalar context,
while assignment to an array or hash evaluates the righthand
side in list context. Assignment to a list (or slice, which
is just a list anyway) also evaluates the right-hand side in
list context.</p>

<p style="margin-left:11%; margin-top: 1em">When you use
the <tt>&quot;use warnings&quot;</tt> pragma or Perl&rsquo;s
<b>&minus;w</b> command-line option, you may see warnings
about useless uses of constants or functions in &quot;void
context&quot;. Void context just means the value has been
discarded, such as a statement containing only
<tt>&quot;&quot;fred&quot;;&quot;</tt> or
<tt>&quot;getpwuid(0);&quot;</tt>. It still counts as scalar
context for functions that care whether or not they&rsquo;re
being called in list context.</p>

<p style="margin-left:11%; margin-top: 1em">User-defined
subroutines may choose to care whether they are being called
in a void, scalar, or list context. Most subroutines do not
need to bother, though. That&rsquo;s because both scalars
and lists are automatically interpolated into lists. See
&quot;wantarray&quot; in perlfunc for how you would
dynamically discern your function&rsquo;s calling
context.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Scalar
values</b> <br>
All data in Perl is a scalar, an array of scalars, or a hash
of scalars. A scalar may contain one single value in any of
three different flavors: a number, a string, or a reference.
In general, conversion from one form to another is
transparent. Although a scalar may not directly hold
multiple values, it may contain a reference to an array or
hash which in turn contains multiple values.</p>

<p style="margin-left:11%; margin-top: 1em">Scalars
aren&rsquo;t necessarily one thing or another. There&rsquo;s
no place to declare a scalar variable to be of type
&quot;string&quot;, type &quot;number&quot;, type
&quot;reference&quot;, or anything else. Because of the
automatic conversion of scalars, operations that return
scalars don&rsquo;t need to care (and in fact, cannot care)
whether their caller is looking for a string, a number, or a
reference. Perl is a contextually polymorphic language whose
scalars can be strings, numbers, or references (which
includes objects). Although strings and numbers are
considered pretty much the same thing for nearly all
purposes, references are strongly-typed, uncastable pointers
with builtin reference-counting and destructor
invocation.</p>

<p style="margin-left:11%; margin-top: 1em">A scalar value
is interpreted as <small>FALSE</small> in the Boolean sense
if it is undefined, the null string or the number 0 (or its
string equivalent, &quot;0&quot;), and <small>TRUE</small>
if it is anything else. The Boolean context is just a
special kind of scalar context where no conversion to a
string or a number is ever performed.</p>

<p style="margin-left:11%; margin-top: 1em">There are
actually two varieties of null strings (sometimes referred
to as &quot;empty&quot; strings), a defined one and an
undefined one. The defined version is just a string of
length zero, such as <tt>&quot;&quot;</tt>. The undefined
version is the value that indicates that there is no real
value for something, such as when there was an error, or at
end of file, or when you refer to an uninitialized variable
or element of an array or hash. Although in early versions
of Perl, an undefined scalar could become defined when first
used in a place expecting a defined value, this no longer
happens except for rare cases of autovivification as
explained in perlref. You can use the <i>defined()</i>
operator to determine whether a scalar value is defined
(this has no meaning on arrays or hashes), and the
<i>undef()</i> operator to produce an undefined value.</p>

<p style="margin-left:11%; margin-top: 1em">To find out
whether a given string is a valid non-zero number,
it&rsquo;s sometimes enough to test it against both numeric
0 and also lexical &quot;0&quot; (although this will cause
noises if warnings are on). That&rsquo;s because strings
that aren&rsquo;t numbers count as 0, just as they do in
<b>awk</b>:</p>

<pre style="margin-left:11%; margin-top: 1em">    if ($str == 0 &amp;&amp; $str ne &quot;0&quot;)  {
        warn &quot;That doesn't look like a number&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">That method may
be best because otherwise you won&rsquo;t treat
<small>IEEE</small> notations like <tt>&quot;NaN&quot;</tt>
or <tt>&quot;Infinity&quot;</tt> properly. At other times,
you might prefer to determine whether string data can be
used numerically by calling the <i>POSIX::strtod()</i>
function or by inspecting your string with a regular
expression (as documented in perlre).</p>

<pre style="margin-left:11%; margin-top: 1em">    warn &quot;has nondigits&quot;        if     /\D/;
    warn &quot;not a natural number&quot; unless /^\d+$/;             # rejects &minus;3
    warn &quot;not an integer&quot;       unless /^&minus;?\d+$/;           # rejects +3
    warn &quot;not an integer&quot;       unless /^[+&minus;]?\d+$/;
    warn &quot;not a decimal number&quot; unless /^&minus;?\d+\.?\d*$/;     # rejects .2
    warn &quot;not a decimal number&quot; unless /^&minus;?(?:\d+(?:\.\d*)?|\.\d+)$/;
    warn &quot;not a C float&quot;
        unless /^([+&minus;]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+&minus;]?\d+))?$/;</pre>


<p style="margin-left:11%; margin-top: 1em">The length of
an array is a scalar value. You may find the length of array
<tt>@days</tt> by evaluating <tt>$#days</tt>, as in
<b>csh</b>. However, this isn&rsquo;t the length of the
array; it&rsquo;s the subscript of the last element, which
is a different value since there is ordinarily a 0th
element. Assigning to <tt>$#days</tt> actually changes the
length of the array. Shortening an array this way destroys
intervening values. Lengthening an array that was previously
shortened does not recover values that were in those
elements. (It used to do so in Perl 4, but we had to break
this to make sure destructors were called when
expected.)</p>

<p style="margin-left:11%; margin-top: 1em">You can also
gain some minuscule measure of efficiency by pre-extending
an array that is going to get big. You can also extend an
array by assigning to an element that is off the end of the
array. You can truncate an array down to nothing by
assigning the null list () to it. The following are
equivalent:</p>

<pre style="margin-left:11%; margin-top: 1em">    @whatever = ();
    $#whatever = &minus;1;</pre>


<p style="margin-left:11%; margin-top: 1em">If you evaluate
an array in scalar context, it returns the length of the
array. (Note that this is not true of lists, which return
the last value, like the C comma operator, nor of built-in
functions, which return whatever they feel like returning.)
The following is always true:</p>

<pre style="margin-left:11%; margin-top: 1em">    scalar(@whatever) == $#whatever + 1;</pre>


<p style="margin-left:11%; margin-top: 1em">Some
programmers choose to use an explicit conversion so as to
leave nothing to doubt:</p>

<pre style="margin-left:11%; margin-top: 1em">    $element_count = scalar(@whatever);</pre>


<p style="margin-left:11%; margin-top: 1em">If you evaluate
a hash in scalar context, it returns false if the hash is
empty. If there are any key/value pairs, it returns true;
more precisely, the value returned is a string consisting of
the number of used buckets and the number of allocated
buckets, separated by a slash. This is pretty much useful
only to find out whether Perl&rsquo;s internal hashing
algorithm is performing poorly on your data set. For
example, you stick 10,000 things in a hash, but evaluating
<tt>%HASH</tt> in scalar context reveals
<tt>&quot;1/16&quot;</tt>, which means only one out of
sixteen buckets has been touched, and presumably contains
all 10,000 of your items. This isn&rsquo;t supposed to
happen. If a tied hash is evaluated in scalar context, the
<tt>&quot;SCALAR&quot;</tt> method is called (with a
fallback to <tt>&quot;FIRSTKEY&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">You can
preallocate space for a hash by assigning to the
<i>keys()</i> function. This rounds up the allocated buckets
to the next power of two:</p>

<pre style="margin-left:11%; margin-top: 1em">    keys(%users) = 1000;                # allocate 1024 buckets</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Scalar value
constructors</b> <br>
Numeric literals are specified in any of the following
floating point or integer formats:</p>

<pre style="margin-left:11%; margin-top: 1em">    12345
    12345.67
    .23E&minus;10             # a very small number
    3.14_15_92          # a very important number
    4_294_967_296       # underscore for legibility
    0xff                # hex
    0xdead_beef         # more hex
    0377                # octal (only numbers, begins with 0)
    0b011011            # binary</pre>


<p style="margin-left:11%; margin-top: 1em">You are allowed
to use underscores (underbars) in numeric literals between
digits for legibility (but not multiple underscores in a
row: <tt>&quot;23__500&quot;</tt> is not legal;
<tt>&quot;23_500&quot;</tt> is). You could, for example,
group binary digits by threes (as for a Unix-style mode
argument such as 0b110_100_100) or by fours (to represent
nibbles, as in 0b1010_0110) or in other groups.</p>

<p style="margin-left:11%; margin-top: 1em">String literals
are usually delimited by either single or double quotes.
They work much like quotes in the standard Unix shells:
double-quoted string literals are subject to backslash and
variable substitution; single-quoted strings are not (except
for <tt>&quot;\'&quot;</tt> and <tt>&quot;\\&quot;</tt>).
The usual C&minus;style backslash rules apply for making
characters such as newline, tab, etc., as well as some more
exotic forms. See &quot;Quote and Quote-like Operators&quot;
in perlop for a list.</p>

<p style="margin-left:11%; margin-top: 1em">Hexadecimal,
octal, or binary, representations in string literals (e.g.
&rsquo;0xff&rsquo;) are not automatically converted to their
integer representation. The <i>hex()</i> and <i>oct()</i>
functions make these conversions for you. See
&quot;hex&quot; in perlfunc and &quot;oct&quot; in perlfunc
for more details.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
embed newlines directly in your strings, i.e., they can end
on a different line than they begin. This is nice, but if
you forget your trailing quote, the error will not be
reported until Perl finds another line containing the quote
character, which may be much further on in the script.
Variable substitution inside strings is limited to scalar
variables, arrays, and array or hash slices. (In other
words, names beginning with $ or @, followed by an optional
bracketed expression as a subscript.) The following code
segment prints out &quot;The price is
<tt>$100</tt>.&quot;</p>

<pre style="margin-left:11%; margin-top: 1em">    $Price = '$100';    # not interpolated
    print &quot;The price is $Price.\n&quot;;     # interpolated</pre>


<p style="margin-left:11%; margin-top: 1em">There is no
double interpolation in Perl, so the <tt>$100</tt> is left
as is.</p>

<p style="margin-left:11%; margin-top: 1em">By default
floating point numbers substituted inside strings use the
dot (&quot;.&quot;) as the decimal separator. If
<tt>&quot;use locale&quot;</tt> is in effect, and
<i>POSIX::setlocale()</i> has been called, the character
used for the decimal separator is affected by the
<small>LC_NUMERIC</small> locale. See perllocale and
<small>POSIX</small> .</p>

<p style="margin-left:11%; margin-top: 1em">As in some
shells, you can enclose the variable name in braces to
disambiguate it from following alphanumerics (and
underscores). You must also do this when interpolating a
variable into a string to separate the variable name from a
following double-colon or an apostrophe, since these would
be otherwise treated as a package separator:</p>

<pre style="margin-left:11%; margin-top: 1em">    $who = &quot;Larry&quot;;
    print PASSWD &quot;${who}::0:0:Superuser:/:/bin/perl\n&quot;;
    print &quot;We use ${who}speak when ${who}'s here.\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">Without the
braces, Perl would have looked for a <tt>$whospeak</tt>, a
<tt>$who::0</tt>, and a <tt>&quot;$who's&quot;</tt>
variable. The last two would be the <tt>$0</tt> and the
<tt>$s</tt> variables in the (presumably) non-existent
package <tt>&quot;who&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In fact, an
identifier within such curlies is forced to be a string, as
is any simple identifier within a hash subscript. Neither
need quoting. Our earlier example, <tt>$days{'Feb'}</tt> can
be written as <tt>$days{Feb}</tt> and the quotes will be
assumed automatically. But anything more complicated in the
subscript will be interpreted as an expression. This means
for example that <tt>&quot;$version{2.0}++&quot;</tt> is
equivalent to <tt>&quot;$version{2}++&quot;</tt>, not to
<tt>&quot;$version{'2.0'}++&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Version
Strings</i></p>

<p style="margin-left:11%; margin-top: 1em">A literal of
the form <tt>&quot;v1.20.300.4000&quot;</tt> is parsed as a
string composed of characters with the specified ordinals.
This form, known as v&minus;strings, provides an
alternative, more readable way to construct strings, rather
than use the somewhat less readable interpolation form
<tt>&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;</tt>. This is
useful for representing Unicode strings, and for comparing
version &quot;numbers&quot; using the string comparison
operators, <tt>&quot;cmp&quot;</tt>,
<tt>&quot;gt&quot;</tt>, <tt>&quot;lt&quot;</tt> etc. If
there are two or more dots in the literal, the leading
<tt>&quot;v&quot;</tt> may be omitted.</p>

<pre style="margin-left:11%; margin-top: 1em">    print v9786;              # prints SMILEY, &quot;\x{263a}&quot;
    print v102.111.111;       # prints &quot;foo&quot;
    print 102.111.111;        # same</pre>


<p style="margin-left:11%; margin-top: 1em">Such literals
are accepted by both <tt>&quot;require&quot;</tt> and
<tt>&quot;use&quot;</tt> for doing a version check. Note
that using the v&minus;strings for IPv4 addresses is not
portable unless you also use the
<i>inet_aton()</i>/<i>inet_ntoa()</i> routines of the Socket
package.</p>

<p style="margin-left:11%; margin-top: 1em">Note that since
Perl 5.8.1 the single-number v&minus;strings (like
<tt>&quot;v65&quot;</tt>) are not v&minus;strings before the
<tt>&quot;=&gt;&quot;</tt> operator (which is usually used
to separate a hash key from a hash value); instead they are
interpreted as literal strings (&rsquo;v65&rsquo;). They
were v&minus;strings from Perl 5.6.0 to Perl 5.8.0, but that
caused more confusion and breakage than good. Multi-number
v&minus;strings like <tt>&quot;v65.66&quot;</tt> and
<tt>65.66.67</tt> continue to be v&minus;strings always.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Special
Literals</i></p>

<p style="margin-left:11%; margin-top: 1em">The special
literals __FILE__, __LINE__, and __PACKAGE__ represent the
current filename, line number, and package name at that
point in your program. __SUB__ gives a reference to the
current subroutine. They may be used only as separate
tokens; they will not be interpolated into strings. If there
is no current package (due to an empty
<tt>&quot;package;&quot;</tt> directive), __PACKAGE__ is the
undefined value. (But the empty
<tt>&quot;package;&quot;</tt> is no longer supported, as of
version 5.10.) Outside of a subroutine, __SUB__ is the
undefined value. __SUB__ is only available in 5.16 or
higher, and only with a <tt>&quot;use v5.16&quot;</tt> or
<tt>&quot;use feature &quot;current_sub&quot;&quot;</tt>
declaration.</p>

<p style="margin-left:11%; margin-top: 1em">The two control
characters ^D and ^Z, and the tokens __END__ and __DATA__
may be used to indicate the logical end of the script before
the actual end of file. Any following text is ignored.</p>

<p style="margin-left:11%; margin-top: 1em">Text after
__DATA__ may be read via the filehandle
<tt>&quot;PACKNAME::DATA&quot;</tt>, where
<tt>&quot;PACKNAME&quot;</tt> is the package that was
current when the __DATA__ token was encountered. The
filehandle is left open pointing to the line after __DATA__.
The program should <tt>&quot;close DATA&quot;</tt> when it
is done reading from it. (Leaving it open leaks filehandles
if the module is reloaded for any reason, so it&rsquo;s a
safer practice to close it.) For compatibility with older
scripts written before __DATA__ was introduced, __END__
behaves like __DATA__ in the top level script (but not in
files loaded with <tt>&quot;require&quot;</tt> or
<tt>&quot;do&quot;</tt>) and leaves the remaining contents
of the file accessible via
<tt>&quot;main::DATA&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">See SelfLoader
for more description of __DATA__, and an example of its use.
Note that you cannot read from the <small>DATA</small>
filehandle in a <small>BEGIN</small> block: the
<small>BEGIN</small> block is executed as soon as it is seen
(during compilation), at which point the corresponding
__DATA__ (or __END__) token has not yet been seen.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Barewords</i></p>

<p style="margin-left:11%; margin-top: 1em">A word that has
no other interpretation in the grammar will be treated as if
it were a quoted string. These are known as
&quot;barewords&quot;. As with filehandles and labels, a
bareword that consists entirely of lowercase letters risks
conflict with future reserved words, and if you use the
<tt>&quot;use warnings&quot;</tt> pragma or the
<b>&minus;w</b> switch, Perl will warn you about any such
words. Perl limits barewords (like identifiers) to about 250
characters. Future versions of Perl are likely to eliminate
these arbitrary limitations.</p>

<p style="margin-left:11%; margin-top: 1em">Some people may
wish to outlaw barewords entirely. If you say</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict 'subs';</pre>


<p style="margin-left:11%; margin-top: 1em">then any
bareword that would <small>NOT</small> be interpreted as a
subroutine call produces a compile-time error instead. The
restriction lasts to the end of the enclosing block. An
inner block may countermand this by saying <tt>&quot;no
strict 'subs'&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Array
Interpolation</i></p>

<p style="margin-left:11%; margin-top: 1em">Arrays and
slices are interpolated into double-quoted strings by
joining the elements with the delimiter specified in the
<tt>$&quot;</tt> variable (<tt>$LIST_SEPARATOR</tt> if
&quot;use English;&quot; is specified), space by default.
The following are equivalent:</p>

<pre style="margin-left:11%; margin-top: 1em">    $temp = join($&quot;, @ARGV);
    system &quot;echo $temp&quot;;
    system &quot;echo @ARGV&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">Within search
patterns (which also undergo double-quotish substitution)
there is an unfortunate ambiguity: Is
<tt>&quot;/$foo[bar]/&quot;</tt> to be interpreted as
<tt>&quot;/${foo}[bar]/&quot;</tt> (where
<tt>&quot;[bar]&quot;</tt> is a character class for the
regular expression) or as <tt>&quot;/${foo[bar]}/&quot;</tt>
(where <tt>&quot;[bar]&quot;</tt> is the subscript to array
<tt>@foo</tt>)? If <tt>@foo</tt> doesn&rsquo;t otherwise
exist, then it&rsquo;s obviously a character class. If
<tt>@foo</tt> exists, Perl takes a good guess about
<tt>&quot;[bar]&quot;</tt>, and is almost always right. If
it does guess wrong, or if you&rsquo;re just plain paranoid,
you can force the correct interpretation with curly braces
as above.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
looking for the information on how to use here-documents,
which used to be here, that&rsquo;s been moved to
&quot;Quote and Quote-like Operators&quot; in perlop.</p>

<p style="margin-left:11%; margin-top: 1em"><b>List value
constructors</b> <br>
List values are denoted by separating individual values by
commas (and enclosing the list in parentheses where
precedence requires it):</p>

<pre style="margin-left:11%; margin-top: 1em">    (LIST)</pre>


<p style="margin-left:11%; margin-top: 1em">In a context
not requiring a list value, the value of what appears to be
a list literal is simply the value of the final element, as
with the C comma operator. For example,</p>

<pre style="margin-left:11%; margin-top: 1em">    @foo = ('cc', '&minus;E', $bar);</pre>


<p style="margin-left:11%; margin-top: 1em">assigns the
entire list value to array <tt>@foo</tt>, but</p>

<pre style="margin-left:11%; margin-top: 1em">    $foo = ('cc', '&minus;E', $bar);</pre>


<p style="margin-left:11%; margin-top: 1em">assigns the
value of variable <tt>$bar</tt> to the scalar variable
<tt>$foo</tt>. Note that the value of an actual array in
scalar context is the length of the array; the following
assigns the value 3 to <tt>$foo:</tt></p>

<p style="margin-left:11%; margin-top: 1em"><tt>@foo =
('cc', '&minus;E', $bar); <br>
$foo = @foo; # $foo gets 3</tt></p>

<p style="margin-left:11%; margin-top: 1em">You may have an
optional comma before the closing parenthesis of a list
literal, so that you can say:</p>

<pre style="margin-left:11%; margin-top: 1em">    @foo = (
        1,
        2,
        3,
    );</pre>


<p style="margin-left:11%; margin-top: 1em">To use a
here-document to assign an array, one line per element, you
might use an approach like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    @sauces = &lt;&lt;End_Lines =~ m/(\S.*\S)/g;
        normal tomato
        spicy tomato
        green chile
        pesto
        white wine
    End_Lines</pre>


<p style="margin-left:11%; margin-top: 1em">LISTs do
automatic interpolation of sublists. That is, when a
<small>LIST</small> is evaluated, each element of the list
is evaluated in list context, and the resulting list value
is interpolated into <small>LIST</small> just as if each
individual element were a member of <small>LIST</small> .
Thus arrays and hashes lose their identity in a LIST--the
list</p>

<pre style="margin-left:11%; margin-top: 1em">    (@foo,@bar,&amp;SomeSub,%glarch)</pre>


<p style="margin-left:11%; margin-top: 1em">contains all
the elements of <tt>@foo</tt> followed by all the elements
of <tt>@bar</tt>, followed by all the elements returned by
the subroutine named SomeSub called in list context,
followed by the key/value pairs of <tt>%glarch</tt>. To make
a list reference that does <i><small>NOT</small></i>
interpolate, see perlref.</p>

<p style="margin-left:11%; margin-top: 1em">The null list
is represented by (). Interpolating it in a list has no
effect. Thus ((),(),()) is equivalent to (). Similarly,
interpolating an array with no elements is the same as if no
array had been interpolated at that point.</p>

<p style="margin-left:11%; margin-top: 1em">This
interpolation combines with the facts that the opening and
closing parentheses are optional (except when necessary for
precedence) and lists may end with an optional comma to mean
that multiple commas within lists are legal syntax. The list
<tt>&quot;1,,3&quot;</tt> is a concatenation of two lists,
<tt>&quot;1,&quot;</tt> and <tt>3</tt>, the first of which
ends with that optional comma. <tt>&quot;1,,3&quot;</tt> is
<tt>&quot;(1,),(3)&quot;</tt> is <tt>&quot;1,3&quot;</tt>
(And similarly for <tt>&quot;1,,,3&quot;</tt> is
<tt>&quot;(1,),(,),3&quot;</tt> is <tt>&quot;1,3&quot;</tt>
and so on.) Not that we&rsquo;d advise you to use this
obfuscation.</p>

<p style="margin-left:11%; margin-top: 1em">A list value
may also be subscripted like a normal array. You must put
the list in parentheses to avoid ambiguity. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    # Stat returns list value.
    $time = (stat($file))[8];
    # SYNTAX ERROR HERE.
    $time = stat($file)[8];  # OOPS, FORGOT PARENTHESES
    # Find a hex digit.
    $hexdigit = ('a','b','c','d','e','f')[$digit&minus;10];
    # A &quot;reverse comma operator&quot;.
    return (pop(@foo),pop(@foo))[0];</pre>


<p style="margin-left:11%; margin-top: 1em">Lists may be
assigned to only when each element of the list is itself
legal to assign to:</p>

<pre style="margin-left:11%; margin-top: 1em">    ($a, $b, $c) = (1, 2, 3);
    ($map{'red'}, $map{'blue'}, $map{'green'}) = (0x00f, 0x0f0, 0xf00);</pre>


<p style="margin-left:11%; margin-top: 1em">An exception to
this is that you may assign to <tt>&quot;undef&quot;</tt> in
a list. This is useful for throwing away some of the return
values of a function:</p>

<pre style="margin-left:11%; margin-top: 1em">    ($dev, $ino, undef, undef, $uid, $gid) = stat($file);</pre>


<p style="margin-left:11%; margin-top: 1em">List assignment
in scalar context returns the number of elements produced by
the expression on the right side of the assignment:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = (($foo,$bar) = (3,2,1));       # set $x to 3, not 2
    $x = (($foo,$bar) = f());           # set $x to f()'s return count</pre>


<p style="margin-left:11%; margin-top: 1em">This is handy
when you want to do a list assignment in a Boolean context,
because most list functions return a null list when
finished, which when assigned produces a 0, which is
interpreted as <small>FALSE</small> .</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s also
the source of a useful idiom for executing a function or
performing an operation in list context and then counting
the number of return values, by assigning to an empty list
and then using that assignment in scalar context. For
example, this code:</p>

<pre style="margin-left:11%; margin-top: 1em">    $count = () = $string =~ /\d+/g;</pre>


<p style="margin-left:11%; margin-top: 1em">will place into
<tt>$count</tt> the number of digit groups found in
<tt>$string</tt>. This happens because the pattern match is
in list context (since it is being assigned to the empty
list), and will therefore return a list of all matching
parts of the string. The list assignment in scalar context
will translate that into the number of elements (here, the
number of times the pattern matched) and assign that to
<tt>$count</tt>. Note that simply using</p>

<pre style="margin-left:11%; margin-top: 1em">    $count = $string =~ /\d+/g;</pre>


<p style="margin-left:11%; margin-top: 1em">would not have
worked, since a pattern match in scalar context will only
return true or false, rather than a count of matches.</p>

<p style="margin-left:11%; margin-top: 1em">The final
element of a list assignment may be an array or a hash:</p>

<pre style="margin-left:11%; margin-top: 1em">    ($a, $b, @rest) = split;
    my($a, $b, %rest) = @_;</pre>


<p style="margin-left:11%; margin-top: 1em">You can
actually put an array or hash anywhere in the list, but the
first one in the list will soak up all the values, and
anything after it will become undefined. This may be useful
in a <i>my()</i> or <i>local()</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A hash can be
initialized using a literal list holding pairs of items to
be interpreted as a key and a value:</p>

<pre style="margin-left:11%; margin-top: 1em">    # same as map assignment above
    %map = ('red',0x00f,'blue',0x0f0,'green',0xf00);</pre>


<p style="margin-left:11%; margin-top: 1em">While literal
lists and named arrays are often interchangeable,
that&rsquo;s not the case for hashes. Just because you can
subscript a list value like a normal array does not mean
that you can subscript a list value as a hash. Likewise,
hashes included as parts of other lists (including
parameters lists and return lists from functions) always
flatten out into key/value pairs. That&rsquo;s why
it&rsquo;s good to use references sometimes.</p>

<p style="margin-left:11%; margin-top: 1em">It is often
more readable to use the <tt>&quot;=&gt;&quot;</tt> operator
between key/value pairs. The <tt>&quot;=&gt;&quot;</tt>
operator is mostly just a more visually distinctive synonym
for a comma, but it also arranges for its left-hand operand
to be interpreted as a string if it&rsquo;s a bareword that
would be a legal simple identifier.
<tt>&quot;=&gt;&quot;</tt> doesn&rsquo;t quote compound
identifiers, that contain double colons. This makes it nice
for initializing hashes:</p>

<pre style="margin-left:11%; margin-top: 1em">    %map = (
                 red   =&gt; 0x00f,
                 blue  =&gt; 0x0f0,
                 green =&gt; 0xf00,
   );</pre>


<p style="margin-left:11%; margin-top: 1em">or for
initializing hash references to be used as records:</p>

<pre style="margin-left:11%; margin-top: 1em">    $rec = {
                witch =&gt; 'Mable the Merciless',
                cat   =&gt; 'Fluffy the Ferocious',
                date  =&gt; '10/31/1776',
    };</pre>


<p style="margin-left:11%; margin-top: 1em">or for using
call-by-named-parameter to complicated functions:</p>

<pre style="margin-left:11%; margin-top: 1em">   $field = $query&minus;&gt;radio_group(
               name      =&gt; 'group_name',
               values    =&gt; ['eenie','meenie','minie'],
               default   =&gt; 'meenie',
               linebreak =&gt; 'true',
               labels    =&gt; \%labels
   );</pre>


<p style="margin-left:11%; margin-top: 1em">Note that just
because a hash is initialized in that order doesn&rsquo;t
mean that it comes out in that order. See &quot;sort&quot;
in perlfunc for examples of how to arrange for an output
ordering.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Subscripts</b>
<br>
An array can be accessed one scalar at a time by specifying
a dollar sign (<tt>&quot;$&quot;</tt>), then the name of the
array (without the leading <tt>&quot;@&quot;</tt>), then the
subscript inside square brackets. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    @myarray = (5, 50, 500, 5000);
    print &quot;The Third Element is&quot;, $myarray[2], &quot;\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">The array
indices start with 0. A negative subscript retrieves its
value from the end. In our example,
<tt>$myarray[&minus;1]</tt> would have been 5000, and
<tt>$myarray[&minus;2]</tt> would have been 500.</p>

<p style="margin-left:11%; margin-top: 1em">Hash subscripts
are similar, only instead of square brackets curly brackets
are used. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    %scientists =
    (
        &quot;Newton&quot; =&gt; &quot;Isaac&quot;,
        &quot;Einstein&quot; =&gt; &quot;Albert&quot;,
        &quot;Darwin&quot; =&gt; &quot;Charles&quot;,
        &quot;Feynman&quot; =&gt; &quot;Richard&quot;,
    );
    print &quot;Darwin's First Name is &quot;, $scientists{&quot;Darwin&quot;}, &quot;\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
subscript a list to get a single element from it:</p>

<pre style="margin-left:11%; margin-top: 1em">    $dir = (getpwnam(&quot;daemon&quot;))[7];</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Multi-dimensional
array emulation</b> <br>
Multidimensional arrays may be emulated by subscripting a
hash with a list. The elements of the list are joined with
the subscript separator (see &quot;$;&quot; in perlvar).</p>

<pre style="margin-left:11%; margin-top: 1em">    $foo{$a,$b,$c}</pre>


<p style="margin-left:11%; margin-top: 1em">is equivalent
to</p>

<pre style="margin-left:11%; margin-top: 1em">    $foo{join($;, $a, $b, $c)}</pre>


<p style="margin-left:11%; margin-top: 1em">The default
subscript separator is &quot;\034&quot;, the same as
<small>SUBSEP</small> in <b>awk</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Slices</b>
<br>
A slice accesses several elements of a list, an array, or a
hash simultaneously using a list of subscripts. It&rsquo;s
more convenient than writing out the individual elements as
a list of separate scalar values.</p>

<pre style="margin-left:11%; margin-top: 1em">    ($him, $her)   = @folks[0,&minus;1];              # array slice
    @them          = @folks[0 .. 3];            # array slice
    ($who, $home)  = @ENV{&quot;USER&quot;, &quot;HOME&quot;};      # hash slice
    ($uid, $dir)   = (getpwnam(&quot;daemon&quot;))[2,7]; # list slice</pre>


<p style="margin-left:11%; margin-top: 1em">Since you can
assign to a list of variables, you can also assign to an
array or hash slice.</p>

<pre style="margin-left:11%; margin-top: 1em">    @days[3..5]    = qw/Wed Thu Fri/;
    @colors{'red','blue','green'}
                   = (0xff0000, 0x0000ff, 0x00ff00);
    @folks[0, &minus;1]  = @folks[&minus;1, 0];</pre>


<p style="margin-left:11%; margin-top: 1em">The previous
assignments are exactly equivalent to</p>

<pre style="margin-left:11%; margin-top: 1em">    ($days[3], $days[4], $days[5]) = qw/Wed Thu Fri/;
    ($colors{'red'}, $colors{'blue'}, $colors{'green'})
                   = (0xff0000, 0x0000ff, 0x00ff00);
    ($folks[0], $folks[&minus;1]) = ($folks[&minus;1], $folks[0]);</pre>


<p style="margin-left:11%; margin-top: 1em">Since changing
a slice changes the original array or hash that it&rsquo;s
slicing, a <tt>&quot;foreach&quot;</tt> construct will alter
some--or even all--of the values of the array or hash.</p>

<pre style="margin-left:11%; margin-top: 1em">    foreach (@array[ 4 .. 10 ]) { s/peter/paul/ }
    foreach (@hash{qw[key1 key2]}) {
        s/^\s+//;           # trim leading whitespace
        s/\s+$//;           # trim trailing whitespace
        s/(\w+)/\u\L$1/g;   # &quot;titlecase&quot; words
    }</pre>


<p style="margin-left:11%; margin-top: 1em">A slice of an
empty list is still an empty list. Thus:</p>

<pre style="margin-left:11%; margin-top: 1em">    @a = ()[1,0];           # @a has no elements
    @b = (@a)[0,1];         # @b has no elements
    @c = (0,1)[2,3];        # @c has no elements</pre>


<p style="margin-left:11%; margin-top: 1em">But:</p>

<pre style="margin-left:11%; margin-top: 1em">    @a = (1)[1,0];          # @a has two elements
    @b = (1,undef)[1,0,2];  # @b has three elements</pre>


<p style="margin-left:11%; margin-top: 1em">This makes it
easy to write loops that terminate when a null list is
returned:</p>

<pre style="margin-left:11%; margin-top: 1em">    while ( ($home, $user) = (getpwent)[7,0]) {
        printf &quot;%&minus;8s %s\n&quot;, $user, $home;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">As noted
earlier in this document, the scalar sense of list
assignment is the number of elements on the right-hand side
of the assignment. The null list contains no elements, so
when the password file is exhausted, the result is 0, not
2.</p>

<p style="margin-left:11%; margin-top: 1em">Slices in
scalar context return the last item of the slice.</p>

<pre style="margin-left:11%; margin-top: 1em">    @a = qw/first second third/;
    %h = (first =&gt; 'A', second =&gt; 'B');
    $t = @a[0, 1];                  # $t is now 'second'
    $u = @h{'first', 'second'};     # $u is now 'B'</pre>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
confused about why you use an &rsquo;@&rsquo; there on a
hash slice instead of a &rsquo;%&rsquo;, think of it like
this. The type of bracket (square or curly) governs whether
it&rsquo;s an array or a hash being looked at. On the other
hand, the leading symbol (&rsquo;$&rsquo; or
&rsquo;@&rsquo;) on the array or hash indicates whether you
are getting back a singular value (a scalar) or a plural one
(a list).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Typeglobs
and Filehandles</b> <br>
Perl uses an internal type called a <i>typeglob</i> to hold
an entire symbol table entry. The type prefix of a typeglob
is a <tt>&quot;*&quot;</tt>, because it represents all
types. This used to be the preferred way to pass arrays and
hashes by reference into a function, but now that we have
real references, this is seldom needed.</p>

<p style="margin-left:11%; margin-top: 1em">The main use of
typeglobs in modern Perl is create symbol table aliases.
This assignment:</p>

<pre style="margin-left:11%; margin-top: 1em">    *this = *that;</pre>


<p style="margin-left:11%; margin-top: 1em">makes
<tt>$this</tt> an alias for <tt>$that</tt>, <tt>@this</tt>
an alias for <tt>@that</tt>, <tt>%this</tt> an alias for
<tt>%that</tt>, &amp;this an alias for &amp;that, etc. Much
safer is to use a reference. This:</p>

<pre style="margin-left:11%; margin-top: 1em">    local *Here::blue = \$There::green;</pre>


<p style="margin-left:11%; margin-top: 1em">temporarily
makes <tt>$Here::blue</tt> an alias for
<tt>$There::green</tt>, but doesn&rsquo;t make
<tt>@Here::blue</tt> an alias for <tt>@There::green</tt>, or
<tt>%Here::blue</tt> an alias for <tt>%There::green</tt>,
etc. See &quot;Symbol Tables&quot; in perlmod for more
examples of this. Strange though this may seem, this is the
basis for the whole module import/export system.</p>

<p style="margin-left:11%; margin-top: 1em">Another use for
typeglobs is to pass filehandles into a function or to
create new filehandles. If you need to use a typeglob to
save away a filehandle, do it this way:</p>

<pre style="margin-left:11%; margin-top: 1em">    $fh = *STDOUT;</pre>


<p style="margin-left:11%; margin-top: 1em">or perhaps as a
real reference, like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $fh = \*STDOUT;</pre>


<p style="margin-left:11%; margin-top: 1em">See perlsub for
examples of using these as indirect filehandles in
functions.</p>

<p style="margin-left:11%; margin-top: 1em">Typeglobs are
also a way to create a local filehandle using the
<i>local()</i> operator. These last until their block is
exited, but may be passed back. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub newopen {
        my $path = shift;
        local  *FH;  # not my!
        open   (FH, $path)          or  return undef;
        return *FH;
    }
    $fh = newopen('/etc/passwd');</pre>


<p style="margin-left:11%; margin-top: 1em">Now that we
have the <tt>*foo{THING}</tt> notation, typeglobs
aren&rsquo;t used as much for filehandle manipulations,
although they&rsquo;re still needed to pass brand new file
and directory handles into or out of functions. That&rsquo;s
because <tt>*HANDLE{IO}</tt> only works if
<small>HANDLE</small> has already been used as a handle. In
other words, <tt>*FH</tt> must be used to create new symbol
table entries; <tt>*foo{THING}</tt> cannot. When in doubt,
use <tt>*FH</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">All functions
that are capable of creating filehandles (<i>open()</i>,
<i>opendir()</i>, <i>pipe()</i>, <i>socketpair()</i>,
<i>sysopen()</i>, <i>socket()</i>, and <i>accept()</i>)
automatically create an anonymous filehandle if the handle
passed to them is an uninitialized scalar variable. This
allows the constructs such as <tt>&quot;open(my $fh,
...)&quot;</tt> and <tt>&quot;open(local $fh,...)&quot;</tt>
to be used to create filehandles that will conveniently be
closed automatically when the scope ends, provided there are
no other references to them. This largely eliminates the
need for typeglobs when opening filehandles that must be
passed around, as in the following example:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub myopen {
        open my $fh, &quot;@_&quot;
             or die &quot;Can't open '@_': $!&quot;;
        return $fh;
    }
    {
        my $f = myopen(&quot;&lt;/etc/motd&quot;);
        print &lt;$f&gt;;
        # $f implicitly closed here
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Note that if an
initialized scalar variable is used instead the result is
different: <tt>&quot;my $fh='zzz'; open($fh, ...)&quot;</tt>
is equivalent to <tt>&quot;open( *{'zzz'}, ...)&quot;</tt>.
<tt>&quot;use strict 'refs'&quot;</tt> forbids such
practice.</p>

<p style="margin-left:11%; margin-top: 1em">Another way to
create anonymous filehandles is with the Symbol module or
with the IO::Handle module and its ilk. These modules have
the advantage of not hiding different types of the same name
during the <i>local()</i>. See the bottom of
&quot;open&quot; in perlfunc for an example.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See perlvar for
a description of Perl&rsquo;s built-in variables and a
discussion of legal variable names. See perlref, perlsub,
and &quot;Symbol Tables&quot; in perlmod for more discussion
on typeglobs and the <tt>*foo{THING}</tt> syntax.</p>
<hr>
</body>
</html>
