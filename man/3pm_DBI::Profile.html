<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Mon Aug  8 15:52:56 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DBI::Profile</title>

</head>
<body>

<h1 align="center">DBI::Profile</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OVERVIEW">OVERVIEW</a><br>
<a href="#ENABLING A PROFILE">ENABLING A PROFILE</a><br>
<a href="#THE PROFILE OBJECT">THE PROFILE OBJECT</a><br>
<a href="#REPORTING">REPORTING</a><br>
<a href="#CHILD HANDLES">CHILD HANDLES</a><br>
<a href="#PROFILE OBJECT METHODS">PROFILE OBJECT METHODS</a><br>
<a href="#CUSTOM DATA MANIPULATION">CUSTOM DATA MANIPULATION</a><br>
<a href="#CUSTOM DATA COLLECTION">CUSTOM DATA COLLECTION</a><br>
<a href="#SUBCLASSING">SUBCLASSING</a><br>
<a href="#CAVEATS">CAVEATS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">DBI::Profile
&minus; Performance profiling and benchmarking for the
DBI</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The easiest way
to enable <small>DBI</small> profiling is to set the
<small>DBI_PROFILE</small> environment variable to 2 and
then run your code as usual:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBI_PROFILE=2 prog.pl</pre>


<p style="margin-left:11%; margin-top: 1em">This will
profile your program and then output a textual summary
grouped by query when the program exits. You can also enable
profiling by setting the Profile attribute of any
<small>DBI</small> handle:</p>

<pre style="margin-left:11%; margin-top: 1em">  $dbh&minus;&gt;{Profile} = 2;</pre>


<p style="margin-left:11%; margin-top: 1em">Then the
summary will be printed when the handle is destroyed.</p>

<p style="margin-left:11%; margin-top: 1em">Many other
values apart from are possible &minus; see &quot;
<small>ENABLING A PROFILE&quot;</small> below.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
DBI::Profile module provides a simple interface to collect
and report performance and benchmarking data from the
<small>DBI.</small></p>

<p style="margin-left:11%; margin-top: 1em">For a more
elaborate interface, suitable for larger programs, see
DBI::ProfileDumper and dbiprof. For Apache/mod_perl
applications see DBI::ProfileDumper::Apache.</p>

<h2>OVERVIEW
<a name="OVERVIEW"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Performance
data collection for the <small>DBI</small> is built around
several concepts which are important to understand clearly.
<br>
Method Dispatch</p>

<p style="margin-left:17%;">Every method call on a
<small>DBI</small> handle passes through a single
&rsquo;dispatch&rsquo; function which manages all the common
aspects of <small>DBI</small> method calls, such as handling
the RaiseError attribute.</p>

<p style="margin-left:11%;">Data Collection</p>

<p style="margin-left:17%;">If profiling is enabled for a
handle then the dispatch code takes a high-resolution
timestamp soon after it is entered. Then, after calling the
appropriate method and just before returning, it takes
another high-resolution timestamp and calls a function to
record the information. That function is passed the two
timestamps plus the <small>DBI</small> handle and the name
of the method that was called. That data about a single
<small>DBI</small> method call is called a <i>profile
sample</i>.</p>

<p style="margin-left:11%;">Data Filtering</p>

<p style="margin-left:17%;">If the method call was invoked
by the <small>DBI</small> or by a driver then the call is
ignored for profiling because the time spent will be
accounted for by the original &rsquo;outermost&rsquo; call
for your code.</p>

<p style="margin-left:17%; margin-top: 1em">For example,
the calls that the <i>selectrow_arrayref()</i> method makes
to <i>prepare()</i> and <i>execute()</i> etc. are not
counted individually because the time spent in those methods
is going to be allocated to the <i>selectrow_arrayref()</i>
method when it returns. If this was not done then it would
be very easy to double count time spent inside the
<small>DBI.</small></p>

<p style="margin-left:11%;">Data Storage Tree</p>

<p style="margin-left:17%;">The profile data is accumulated
as &rsquo;leaves on a tree&rsquo;. The &rsquo;path&rsquo;
through the branches of the tree to a particular leaf is
determined dynamically for each sample. This is a key
feature of <small>DBI</small> profiling.</p>

<p style="margin-left:17%; margin-top: 1em">For each
profiled method call the <small>DBI</small> walks along the
Path and uses each value in the Path to step into and grow
the Data tree.</p>

<p style="margin-left:17%; margin-top: 1em">For example, if
the Path is</p>

<pre style="margin-left:17%; margin-top: 1em">  [ 'foo', 'bar', 'baz' ]</pre>


<p style="margin-left:17%; margin-top: 1em">then the new
profile sample data will be <i>merged</i> into the tree
at</p>

<pre style="margin-left:17%; margin-top: 1em">  $h&minus;&gt;{Profile}&minus;&gt;{Data}&minus;&gt;{foo}&minus;&gt;{bar}&minus;&gt;{baz}</pre>


<p style="margin-left:17%; margin-top: 1em">But it&rsquo;s
not very useful to merge all the call data into one leaf
node (except to get an overall &rsquo;time spent inside the
<small>DBI</small> &rsquo; total). It&rsquo;s more common to
want the Path to include dynamic values such as the current
statement text and/or the name of the method called to show
what the time spent inside the <small>DBI</small> was
for.</p>

<p style="margin-left:17%; margin-top: 1em">The Path can
contain some &rsquo;magic cookie&rsquo; values that are
automatically replaced by corresponding dynamic values when
they&rsquo;re used. These magic cookies always start with a
punctuation character.</p>

<p style="margin-left:17%; margin-top: 1em">For example a
value of &rsquo;<tt>&quot;!MethodName&quot;</tt>&rsquo; in
the Path causes the corresponding entry in the Data to be
the name of the method that was called. For example, if the
Path was:</p>

<pre style="margin-left:17%; margin-top: 1em">  [ 'foo', '!MethodName', 'bar' ]</pre>


<p style="margin-left:17%; margin-top: 1em">and the
<i>selectall_arrayref()</i> method was called, then the
profile sample data for that call will be merged into the
tree at:</p>

<pre style="margin-left:17%; margin-top: 1em">  $h&minus;&gt;{Profile}&minus;&gt;{Data}&minus;&gt;{foo}&minus;&gt;{selectall_arrayref}&minus;&gt;{bar}</pre>


<p style="margin-left:11%;">Profile Data</p>

<p style="margin-left:17%;">Profile data is stored at the
&rsquo;leaves&rsquo; of the tree as references to an array
of numeric values. For example:</p>

<pre style="margin-left:17%; margin-top: 1em">  [
    106,                  # 0: count of samples at this node
    0.0312958955764771,   # 1: total duration
    0.000490069389343262, # 2: first duration
    0.000176072120666504, # 3: shortest duration
    0.00140702724456787,  # 4: longest duration
    1023115819.83019,     # 5: time of first sample
    1023115819.86576,     # 6: time of last sample
  ]</pre>


<p style="margin-left:17%; margin-top: 1em">After the first
sample, later samples always update elements 0, 1, and 6,
and may update 3 or 4 depending on the duration of the
sampled call.</p>

<h2>ENABLING A PROFILE
<a name="ENABLING A PROFILE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Profiling is
enabled for a handle by assigning to the Profile attribute.
For example:</p>

<pre style="margin-left:11%; margin-top: 1em">  $h&minus;&gt;{Profile} = DBI::Profile&minus;&gt;new();</pre>


<p style="margin-left:11%; margin-top: 1em">The Profile
attribute holds a blessed reference to a hash object that
contains the profile data and attributes relating to it.</p>

<p style="margin-left:11%; margin-top: 1em">The class the
Profile object is blessed into is expected to provide at
least a <small>DESTROY</small> method which will dump the
profile data to the <small>DBI</small> trace file handle (
<small>STDERR</small> by default).</p>

<p style="margin-left:11%; margin-top: 1em">All these
examples have the same effect as each other:</p>

<pre style="margin-left:11%; margin-top: 1em">  $h&minus;&gt;{Profile} = 0;
  $h&minus;&gt;{Profile} = &quot;/DBI::Profile&quot;;
  $h&minus;&gt;{Profile} = DBI::Profile&minus;&gt;new();
  $h&minus;&gt;{Profile} = {};
  $h&minus;&gt;{Profile} = { Path =&gt; [] };</pre>


<p style="margin-left:11%; margin-top: 1em">Similarly,
these examples have the same effect as each other:</p>

<pre style="margin-left:11%; margin-top: 1em">  $h&minus;&gt;{Profile} = 6;
  $h&minus;&gt;{Profile} = &quot;6/DBI::Profile&quot;;
  $h&minus;&gt;{Profile} = &quot;!Statement:!MethodName/DBI::Profile&quot;;
  $h&minus;&gt;{Profile} = { Path =&gt; [ '!Statement', '!MethodName' ] };</pre>


<p style="margin-left:11%; margin-top: 1em">If a
non-blessed hash reference is given then the DBI::Profile
module is automatically <tt>&quot;require&quot;</tt>&rsquo;d
and the reference is blessed into that class.</p>

<p style="margin-left:11%; margin-top: 1em">If a string is
given then it is processed like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    ($path, $module, $args) = split /\//, $string, 3
    @path = split /:/, $path
    @args = split /:/, $args
    eval &quot;require $module&quot; if $module
    $module ||= &quot;DBI::Profile&quot;
    $module&minus;&gt;new( Path =&gt; \@Path, @args )</pre>


<p style="margin-left:11%; margin-top: 1em">So the first
value is used to select the Path to be used (see below). The
second value, if present, is used as the name of a module
which will be loaded and it&rsquo;s <tt>&quot;new&quot;</tt>
method called. If not present it defaults to DBI::Profile.
Any other values are passed as arguments to the
<tt>&quot;new&quot;</tt> method. For example:
&quot;<tt>&quot;2/DBIx::OtherProfile/Foo:42&quot;</tt>&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Numbers can be
used as a shorthand way to enable common Path values. The
simplest way to explain how the values are interpreted is to
show the code:</p>

<pre style="margin-left:11%; margin-top: 1em">    push @Path, &quot;DBI&quot;           if $path_elem &amp; 0x01;
    push @Path, &quot;!Statement&quot;    if $path_elem &amp; 0x02;
    push @Path, &quot;!MethodName&quot;   if $path_elem &amp; 0x04;
    push @Path, &quot;!MethodClass&quot;  if $path_elem &amp; 0x08;
    push @Path, &quot;!Caller2&quot;      if $path_elem &amp; 0x10;</pre>


<p style="margin-left:11%; margin-top: 1em">So
&quot;2&quot; is the same as &quot;!Statement&quot; and
&quot;6&quot; (2+4) is the same as
&quot;!Statement:!Method&quot;. Those are the two most
commonly used values. Using a negative number will reverse
the path. Thus &quot;&minus;6&quot; will group by method
name then statement.</p>

<p style="margin-left:11%; margin-top: 1em">The splitting
and parsing of string values assigned to the Profile
attribute may seem a little odd, but there&rsquo;s a good
reason for it. Remember that attributes can be embedded in
the Data Source Name string which can be passed in to a
script as a parameter. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    dbi:DriverName(Profile=&gt;2):dbname
    dbi:DriverName(Profile=&gt;{Username}:!Statement/MyProfiler/Foo:42):dbname</pre>


<p style="margin-left:11%; margin-top: 1em">And also, if
the <tt>&quot;DBI_PROFILE&quot;</tt> environment variable is
set then The <small>DBI</small> arranges for every driver
handle to share the same profile object. When perl exits a
single profile summary will be generated that reflects (as
nearly as practical) the total use of the <small>DBI</small>
by the application.</p>

<h2>THE PROFILE OBJECT
<a name="THE PROFILE OBJECT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>DBI</small> core expects the Profile attribute value
to be a hash reference and if the following values
don&rsquo;t exist it will create them as needed:</p>

<p style="margin-left:11%; margin-top: 1em"><b>Data</b>
<br>
A reference to a hash containing the collected profile
data.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Path</b>
<br>
The Path value is a reference to an array. Each element
controls the value to use at the corresponding level of the
profile Data tree.</p>

<p style="margin-left:11%; margin-top: 1em">If the value of
Path is anything other than an array reference, it is
treated as if it was:</p>

<pre style="margin-left:11%; margin-top: 1em">        [ '!Statement' ]</pre>


<p style="margin-left:11%; margin-top: 1em">The elements of
Path array can be one of the following types:</p>

<p style="margin-left:11%; margin-top: 1em"><i>Special
Constant</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>!Statement</b></p>

<p style="margin-left:11%; margin-top: 1em">Use the current
Statement text. Typically that&rsquo;s the value of the
Statement attribute for the handle the method was called
with. Some methods, like <i>commit()</i> and
<i>rollback()</i>, are unrelated to a particular statement.
For those methods !Statement records an empty string.</p>

<p style="margin-left:11%; margin-top: 1em">For statement
handles this is always simply the string that was given to
<i>prepare()</i> when the handle was created. For database
handles this is the statement that was last prepared or
executed on that database handle. That can lead to a little
&rsquo;fuzzyness&rsquo; because, for example, calls to the
<i>quote()</i> method to build a new statement will
typically be associated with the previous statement. In
practice this isn&rsquo;t a significant issue and the
dynamic Path mechanism can be used to setup your own
rules.</p>


<p style="margin-left:11%; margin-top: 1em"><b>!MethodName</b></p>

<p style="margin-left:11%; margin-top: 1em">Use the name of
the <small>DBI</small> method that the profile sample
relates to.</p>


<p style="margin-left:11%; margin-top: 1em"><b>!MethodClass</b></p>

<p style="margin-left:11%; margin-top: 1em">Use the fully
qualified name of the <small>DBI</small> method, including
the package, that the profile sample relates to. This shows
you where the method was implemented. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">  'DBD::_::db::selectrow_arrayref' =&gt;
      0.022902s
  'DBD::mysql::db::selectrow_arrayref' =&gt;
      2.244521s / 99 = 0.022445s avg (first 0.022813s, min 0.022051s, max 0.028932s)</pre>


<p style="margin-left:11%; margin-top: 1em">The
&quot;DBD::_::db::selectrow_arrayref&quot; shows that the
driver has inherited the selectrow_arrayref method provided
by the <small>DBI.</small></p>

<p style="margin-left:11%; margin-top: 1em">But
you&rsquo;ll note that there is only one call to
DBD::_::db::selectrow_arrayref but another 99 to
DBD::mysql::db::selectrow_arrayref. Currently the first call
doesn&rsquo;t record the true location. That may change.</p>


<p style="margin-left:11%; margin-top: 1em"><b>!Caller</b></p>

<p style="margin-left:11%; margin-top: 1em">Use a string
showing the filename and line number of the code calling the
method.</p>


<p style="margin-left:11%; margin-top: 1em"><b>!Caller2</b></p>

<p style="margin-left:11%; margin-top: 1em">Use a string
showing the filename and line number of the code calling the
method, as for !Caller, but also include filename and line
number of the code that called that. Calls from
<small>DBI::</small> and <small>DBD::</small> packages are
skipped.</p>


<p style="margin-left:11%; margin-top: 1em"><b>!File</b></p>

<p style="margin-left:11%; margin-top: 1em">Same as !Caller
above except that only the filename is included, not the
line number.</p>


<p style="margin-left:11%; margin-top: 1em"><b>!File2</b></p>

<p style="margin-left:11%; margin-top: 1em">Same as
!Caller2 above except that only the filenames are included,
not the line number.</p>


<p style="margin-left:11%; margin-top: 1em"><b>!Time</b></p>

<p style="margin-left:11%; margin-top: 1em">Use the current
value of <i>time()</i>. Rarely used. See the more useful
<tt>&quot;!Time~N&quot;</tt> below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>!Time~N</b></p>

<p style="margin-left:11%; margin-top: 1em">Where
<tt>&quot;N&quot;</tt> is an integer. Use the current value
of <i>time()</i> but with reduced precision. The value used
is determined in this way:</p>

<pre style="margin-left:11%; margin-top: 1em">    int( time() / N ) * N</pre>


<p style="margin-left:11%; margin-top: 1em">This is a
useful way to segregate a profile into time slots. For
example:</p>

<pre style="margin-left:11%; margin-top: 1em">    [ '!Time~60', '!Statement' ]</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Code
Reference</i></p>

<p style="margin-left:11%; margin-top: 1em">The subroutine
is passed the handle it was called on and the
<small>DBI</small> method name. The current Statement is in
<tt>$_</tt>. The statement string should not be modified, so
most subs start with <tt>&quot;local $_ =
$_;&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The list of
values it returns is used at that point in the Profile
Path.</p>

<p style="margin-left:11%; margin-top: 1em">The sub can
&rsquo;veto&rsquo; (reject) a profile sample by including a
reference to undef in the returned list. That can be useful
when you want to only profile statements that match a
certain pattern, or only profile certain methods.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Subroutine
Specifier</i></p>

<p style="margin-left:11%; margin-top: 1em">A Path element
that begins with &rsquo;<tt>&quot;&amp;&quot;</tt>&rsquo; is
treated as the name of a subroutine in the DBI::ProfileSubs
namespace and replaced with the corresponding code
reference.</p>

<p style="margin-left:11%; margin-top: 1em">Currently this
only works when the Path is specified by the
<tt>&quot;DBI_PROFILE&quot;</tt> environment variable.</p>

<p style="margin-left:11%; margin-top: 1em">Also,
currently, the only subroutine in the DBI::ProfileSubs
namespace is <tt>'&amp;norm_std_n3'</tt>. That&rsquo;s a
very handy subroutine when profiling code that doesn&rsquo;t
use placeholders. See DBI::ProfileSubs for more
information.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Attribute
Specifier</i></p>

<p style="margin-left:11%; margin-top: 1em">A string
enclosed in braces, such as
&rsquo;<tt>&quot;{Username}&quot;</tt>&rsquo;, specifies
that the current value of the corresponding database handle
attribute should be used at that point in the Path.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Reference to
a Scalar</i></p>

<p style="margin-left:11%; margin-top: 1em">Specifies that
the current value of the referenced scalar be used at that
point in the Path. This provides an efficient way to get
&rsquo;contextual&rsquo; values into your profile.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Other
Values</i></p>

<p style="margin-left:11%; margin-top: 1em">Any other
values are stringified and used literally.</p>

<p style="margin-left:11%; margin-top: 1em">(References,
and values that begin with punctuation characters are
reserved.)</p>

<h2>REPORTING
<a name="REPORTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Report
Format</b> <br>
The current accumulated profile data can be formatted and
output using</p>

<pre style="margin-left:11%; margin-top: 1em">    print $h&minus;&gt;{Profile}&minus;&gt;format;</pre>


<p style="margin-left:11%; margin-top: 1em">To discard the
profile data and start collecting fresh data you can do:</p>

<pre style="margin-left:11%; margin-top: 1em">    $h&minus;&gt;{Profile}&minus;&gt;{Data} = undef;</pre>


<p style="margin-left:11%; margin-top: 1em">The default
results format looks like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBI::Profile: 0.001015s 42.7% (5 calls) programname @ YYYY&minus;MM&minus;DD HH:MM:SS
  '' =&gt;
      0.000024s / 2 = 0.000012s avg (first 0.000015s, min 0.000009s, max 0.000015s)
  'SELECT mode,size,name FROM table' =&gt;
      0.000991s / 3 = 0.000330s avg (first 0.000678s, min 0.000009s, max 0.000678s)</pre>


<p style="margin-left:11%; margin-top: 1em">Which shows the
total time spent inside the <small>DBI,</small> with a count
of the total number of method calls and the name of the
script being run, then a formatted version of the profile
data tree.</p>

<p style="margin-left:11%; margin-top: 1em">If the results
are being formatted when the perl process is exiting (which
is usually the case when the <small>DBI_PROFILE</small>
environment variable is used) then the percentage of time
the process spent inside the <small>DBI</small> is also
shown. If the process is not exiting then the percentage is
calculated using the time between the first and last call to
the <small>DBI.</small></p>

<p style="margin-left:11%; margin-top: 1em">In the example
above the paths in the tree are only one level deep and use
the Statement text as the value (that&rsquo;s the default
behaviour).</p>

<p style="margin-left:11%; margin-top: 1em">The merged
profile data at the &rsquo;leaves&rsquo; of the tree are
presented as total time spent, count, average time spent
(which is simply total time divided by the count), then the
time spent on the first call, the time spent on the fastest
call, and finally the time spent on the slowest call.</p>

<p style="margin-left:11%; margin-top: 1em">The
&rsquo;avg&rsquo;, &rsquo;first&rsquo;, &rsquo;min&rsquo;
and &rsquo;max&rsquo; times are not particularly useful when
the profile data path only contains the statement text.
Here&rsquo;s an extract of a more detailed example using
both statement text and method name in the path:</p>

<pre style="margin-left:11%; margin-top: 1em">  'SELECT mode,size,name FROM table' =&gt;
      'FETCH' =&gt;
          0.000076s
      'fetchrow_hashref' =&gt;
          0.036203s / 108 = 0.000335s avg (first 0.000490s, min 0.000152s, max 0.002786s)</pre>


<p style="margin-left:11%; margin-top: 1em">Here you can
see the &rsquo;avg&rsquo;, &rsquo;first&rsquo;,
&rsquo;min&rsquo; and &rsquo;max&rsquo; for the 108 calls to
<i>fetchrow_hashref()</i> become rather more interesting.
Also the data for <small>FETCH</small> just shows a time
value because it was only called once.</p>

<p style="margin-left:11%; margin-top: 1em">Currently the
profile data is output sorted by branch names. That may
change in a later version so the leaf nodes are sorted by
total time per leaf node.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Report
Destination</b> <br>
The default method of reporting is for the
<small>DESTROY</small> method of the Profile object to
format the results and write them using:</p>

<pre style="margin-left:11%; margin-top: 1em">    DBI&minus;&gt;trace_msg($results, 0);  # see $ON_DESTROY_DUMP below</pre>


<p style="margin-left:11%; margin-top: 1em">to write them
to the <small>DBI</small> <i>trace()</i> filehandle (which
defaults to <small>STDERR</small> ). To direct the
<small>DBI</small> trace filehandle to write to a file
without enabling tracing the <i>trace()</i> method can be
called with a trace level of 0. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    DBI&minus;&gt;trace(0, $filename);</pre>


<p style="margin-left:11%; margin-top: 1em">The same effect
can be achieved without changing the code by setting the
<tt>&quot;DBI_TRACE&quot;</tt> environment variable to
<tt>&quot;0=filename&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$DBI::Profile::ON_DESTROY_DUMP</tt> variable holds a
code ref that&rsquo;s called to perform the output of the
formatted results. The default value is:</p>

<pre style="margin-left:11%; margin-top: 1em">  $ON_DESTROY_DUMP = sub { DBI&minus;&gt;trace_msg($results, 0) };</pre>


<p style="margin-left:11%; margin-top: 1em">Apart from
making it easy to send the dump elsewhere, it can also be
useful as a simple way to disable dumping results.</p>

<h2>CHILD HANDLES
<a name="CHILD HANDLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Child handles
inherit a reference to the Profile attribute value of their
parent. So if profiling is enabled for a database handle
then by default the statement handles created from it all
contribute to the same merged profile data tree.</p>

<h2>PROFILE OBJECT METHODS
<a name="PROFILE OBJECT METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>format</b>
<br>
See &quot; <small>REPORTING&quot;</small> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>as_node_path_list</b></p>


<pre style="margin-left:11%;">  @ary = $dbh&minus;&gt;{Profile}&minus;&gt;as_node_path_list();
  @ary = $dbh&minus;&gt;{Profile}&minus;&gt;as_node_path_list($node, $path);</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
collected data ($dbh&minus;&gt;{Profile}{Data}) restructured
into a list of array refs, one for each leaf node in the
Data tree. This &rsquo;flat&rsquo; structure is often much
simpler for applications to work with.</p>

<p style="margin-left:11%; margin-top: 1em">The first
element of each array ref is a reference to the leaf node.
The remaining elements are the &rsquo;path&rsquo; through
the data tree to that node.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
given a data tree like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    {key1a}{key2a}[node1]
    {key1a}{key2b}[node2]
    {key1b}{key2a}{key3a}[node3]</pre>


<p style="margin-left:11%; margin-top: 1em">The
<i>as_node_path_list()</i> method will return this list:</p>

<pre style="margin-left:11%; margin-top: 1em">    [ [node1], 'key1a', 'key2a' ]
    [ [node2], 'key1a', 'key2b' ]
    [ [node3], 'key1b', 'key2a', 'key3a' ]</pre>


<p style="margin-left:11%; margin-top: 1em">The nodes are
ordered by key, depth-first.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$node</tt> argument can be used to focus on a sub-tree.
If not specified it defaults to
<tt>$dbh</tt>&minus;&gt;{Profile}{Data}.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$path</tt> argument can be used to specify a list of
path elements that will be added to each element of the
returned list. If not specified it defaults to a a ref to an
empty array.</p>


<p style="margin-left:11%; margin-top: 1em"><b>as_text</b></p>


<pre style="margin-left:11%;">  @txt = $dbh&minus;&gt;{Profile}&minus;&gt;as_text();
  $txt = $dbh&minus;&gt;{Profile}&minus;&gt;as_text({
      node      =&gt; undef,
      path      =&gt; [],
      separator =&gt; &quot; &gt; &quot;,
      format    =&gt; '%1$s: %11$fs / %10$d = %2$fs avg (first %12$fs, min %13$fs, max %14$fs)'.&quot;\n&quot;;
      sortsub   =&gt; sub { ... },
  );</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
collected data ($dbh&minus;&gt;{Profile}{Data}) reformatted
into a list of formatted strings. In scalar context the list
is returned as a single concatenated string.</p>

<p style="margin-left:11%; margin-top: 1em">A hashref can
be used to pass in arguments, the default values are shown
in the example above.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;node&quot;</tt> and &lt;path&gt; arguments are
passed to <i>as_node_path_list()</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;separator&quot;</tt> argument is used to join the
elements of the path for each leaf node.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;sortsub&quot;</tt> argument is used to pass in a
ref to a sub that will order the list. The subroutine will
be passed a reference to the array returned by
<i>as_node_path_list()</i> and should sort the contents of
the array in place. The return value from the sub is
ignored. For example, to sort the nodes by the second level
key you could use:</p>

<pre style="margin-left:11%; margin-top: 1em">  sortsub =&gt; sub { my $ary=shift; @$ary = sort { $a&minus;&gt;[2] cmp $b&minus;&gt;[2] } @$ary }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;format&quot;</tt> argument is a
<tt>&quot;sprintf&quot;</tt> format string that specifies
the format to use for each leaf node. It uses the explicit
format parameter index mechanism to specify which of the
arguments should appear where in the string. The arguments
to sprintf are:</p>

<pre style="margin-left:11%; margin-top: 1em">     1:  path to node, joined with the separator
     2:  average duration (total duration/count)
         (3 thru 9 are currently unused)
    10:  count
    11:  total duration
    12:  first duration
    13:  smallest duration
    14:  largest duration
    15:  time of first call
    16:  time of first call</pre>


<h2>CUSTOM DATA MANIPULATION
<a name="CUSTOM DATA MANIPULATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Recall that
<tt>&quot;$h&minus;&gt;{Profile}&minus;&gt;{Data}&quot;</tt>
is a reference to the collected data. Either to a
&rsquo;leaf&rsquo; array (when the Path is empty, i.e.,
<small>DBI_PROFILE</small> env var is 1), or a reference to
hash containing values that are either further hash
references or leaf array references.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes
it&rsquo;s useful to be able to summarise some or all of the
collected data. The <i>dbi_profile_merge_nodes()</i>
function can be used to merge leaf node values.</p>


<p style="margin-left:11%; margin-top: 1em"><b>dbi_profile_merge_nodes</b></p>


<pre style="margin-left:11%;">  use DBI qw(dbi_profile_merge_nodes);
  $time_in_dbi = dbi_profile_merge_nodes(my $totals=[], @$leaves);</pre>


<p style="margin-left:11%; margin-top: 1em">Merges profile
data node. Given a reference to a destination array, and
zero or more references to profile data, merges the profile
data into the destination array. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">  $time_in_dbi = dbi_profile_merge_nodes(
      my $totals=[],
      [ 10, 0.51, 0.11, 0.01, 0.22, 1023110000, 1023110010 ],
      [ 15, 0.42, 0.12, 0.02, 0.23, 1023110005, 1023110009 ],
  );</pre>


<p style="margin-left:11%; margin-top: 1em">$totals will
then contain</p>

<pre style="margin-left:11%; margin-top: 1em">  [ 25, 0.93, 0.11, 0.01, 0.23, 1023110000, 1023110010 ]</pre>


<p style="margin-left:11%; margin-top: 1em">and
<tt>$time_in_dbi</tt> will be 0.93;</p>

<p style="margin-left:11%; margin-top: 1em">The second
argument need not be just leaf nodes. If given a reference
to a hash then the hash is recursively searched for for leaf
nodes and all those found are merged.</p>

<p style="margin-left:11%; margin-top: 1em">For example, to
get the time spent &rsquo;inside&rsquo; the
<small>DBI</small> during an http request, your logging code
run at the end of the request (i.e. mod_perl LogHandler)
could use:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $time_in_dbi = 0;
  if (my $Profile = $dbh&minus;&gt;{Profile}) { # if DBI profiling is enabled
      $time_in_dbi = dbi_profile_merge_nodes(my $total=[], $Profile&minus;&gt;{Data});
      $Profile&minus;&gt;{Data} = {}; # reset the profile data
  }</pre>


<p style="margin-left:11%; margin-top: 1em">If profiling
has been enabled then <tt>$time_in_dbi</tt> will hold the
time spent inside the <small>DBI</small> for that handle
(and any other handles that share the same profile data)
since the last request.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to
<small>DBI 1.56</small> the <i>dbi_profile_merge_nodes()</i>
function was called <i>dbi_profile_merge()</i>. That name
still exists as an alias.</p>

<h2>CUSTOM DATA COLLECTION
<a name="CUSTOM DATA COLLECTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Using The
Path Attribute</b></p>

<pre style="margin-left:11%;">  XXX example to be added later using a selectall_arrayref call
  XXX nested inside a fetch loop where the first column of the
  XXX outer loop is bound to the profile Path using
  XXX bind_column(1, \${ $dbh&minus;&gt;{Profile}&minus;&gt;{Path}&minus;&gt;[0] })
  XXX so you end up with separate profiles for each loop
  XXX (patches welcome to add this to the docs :)</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Adding Your
Own Samples</b> <br>
The <i>dbi_profile()</i> function can be used to add extra
sample data into the profile data tree. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    use DBI;
    use DBI::Profile (dbi_profile dbi_time);
    my $t1 = dbi_time(); # floating point high&minus;resolution time
    ... execute code you want to profile here ...
    my $t2 = dbi_time();
    dbi_profile($h, $statement, $method, $t1, $t2);</pre>


<p style="margin-left:11%; margin-top: 1em">The <tt>$h</tt>
parameter is the handle the extra profile sample should be
associated with. The <tt>$statement</tt> parameter is the
string to use where the Path specifies !Statement. If
<tt>$statement</tt> is undef then
<tt>$h</tt>&minus;&gt;{Statement} will be used. Similarly
<tt>$method</tt> is the string to use if the Path specifies
!MethodName. There is no default value for
<tt>$method</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$h</tt>&minus;&gt;{Profile}{Path} attribute is processed
by <i>dbi_profile()</i> in the usual way.</p>

<p style="margin-left:11%; margin-top: 1em">The <tt>$h</tt>
parameter is usually a <small>DBI</small> handle but it can
also be a reference to a hash, in which case the
<i>dbi_profile()</i> acts on each defined value in the hash.
This is an efficient way to update multiple profiles with a
single sample, and is used by the DashProfiler module.</p>

<h2>SUBCLASSING
<a name="SUBCLASSING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Alternate
profile modules must subclass DBI::Profile to help ensure
they work with future versions of the
<small>DBI.</small></p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Applications
which generate many different statement strings (typically
because they don&rsquo;t use placeholders) and profile with
!Statement in the Path (the default) will consume memory in
the Profile Data structure for each statement. Use a code
ref in the Path to return an edited (simplified) form of the
statement.</p>

<p style="margin-left:11%; margin-top: 1em">If a method
throws an exception itself (not via RaiseError) then it
won&rsquo;t be counted in the profile.</p>

<p style="margin-left:11%; margin-top: 1em">If a
HandleError subroutine throws an exception (rather than
returning 0 and letting RaiseError do it) then the method
call won&rsquo;t be counted in the profile.</p>

<p style="margin-left:11%; margin-top: 1em">Time spent in
<small>DESTROY</small> is added to the profile of the parent
handle.</p>

<p style="margin-left:11%; margin-top: 1em">Time spent in
<small>DBI&minus;</small> &gt;*() methods is not counted.
The time spent in the driver connect method,
<tt>$drh</tt>&minus;&gt;<i>connect()</i>, when it&rsquo;s
called by <small>DBI&minus;</small> &gt;connect is counted
if the <small>DBI_PROFILE</small> environment variable is
set.</p>

<p style="margin-left:11%; margin-top: 1em">Time spent
fetching tied variables, <tt>$DBI::errstr</tt>, is
counted.</p>

<p style="margin-left:11%; margin-top: 1em">Time spent in
<small>FETCH</small> for <tt>$h</tt>&minus;&gt;{Profile} is
not counted, so getting the profile data doesn&rsquo;t alter
it.</p>

<p style="margin-left:11%; margin-top: 1em">DBI::PurePerl
does not support profiling (though it could in theory).</p>

<p style="margin-left:11%; margin-top: 1em">For
asynchronous queries, time spent while the query is running
on the backend is not counted.</p>

<p style="margin-left:11%; margin-top: 1em">A few platforms
don&rsquo;t support the <i>gettimeofday()</i> high
resolution time function used by the <small>DBI</small> (and
available via the <i>dbi_time()</i> function). In which case
you&rsquo;ll get integer resolution time which is mostly
useless.</p>

<p style="margin-left:11%; margin-top: 1em">On Windows
platforms the <i>dbi_time()</i> function is limited to
millisecond resolution. Which isn&rsquo;t sufficiently fine
for our needs, but still much better than integer
resolution. This limited resolution means that fast method
calls will often register as taking 0 time. And timings in
general will have much more &rsquo;jitter&rsquo; depending
on where within the &rsquo;current millisecond&rsquo; the
start and and timing was taken.</p>

<p style="margin-left:11%; margin-top: 1em">This
documentation could be more clear. Probably needs to be
reordered to start with several examples and build from
there. Trying to explain the concepts first seems painful
and to lead to just as many forward references. (Patches
welcome!)</p>
<hr>
</body>
</html>
