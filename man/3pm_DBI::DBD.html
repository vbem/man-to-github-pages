<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Tue Aug  2 15:32:12 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DBI::DBD</title>

</head>
<body>

<h1 align="center">DBI::DBD</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CREATING A NEW DRIVER">CREATING A NEW DRIVER</a><br>
<a href="#CREATING A PURE PERL DRIVER">CREATING A PURE PERL DRIVER</a><br>
<a href="#CREATING A C/XS DRIVER">CREATING A C/XS DRIVER</a><br>
<a href="#METADATA METHODS">METADATA METHODS</a><br>
<a href="#TRACING">TRACING</a><br>
<a href="#WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE">WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE</a><br>
<a href="#OTHER MISCELLANEOUS INFORMATION">OTHER MISCELLANEOUS INFORMATION</a><br>
<a href="#SUBCLASSING DBI DRIVERS">SUBCLASSING DBI DRIVERS</a><br>
<a href="#AUTHORS">AUTHORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">DBI::DBD
&minus; Perl DBI Database Driver Writer&rsquo;s Guide</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  perldoc DBI::DBD</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Version and
volatility</b> <br>
This document is <i>still</i> a minimal draft which is in
need of further work.</p>

<p style="margin-left:11%; margin-top: 1em">The changes
will occur both because the <b><small>DBI</small></b>
specification is changing and hence the requirements on
<b><small>DBD</small></b> drivers change, and because
feedback from people reading this document will suggest
improvements to it.</p>

<p style="margin-left:11%; margin-top: 1em">Please read the
<b><small>DBI</small></b> documentation first and fully,
including the <b><small>DBI</small></b> <small>FAQ.</small>
Then reread the <b><small>DBI</small></b> specification
again as you&rsquo;re reading this. It&rsquo;ll help.</p>

<p style="margin-left:11%; margin-top: 1em">This document
is a patchwork of contributions from various authors. More
contributions (preferably as patches) are very welcome.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
is primarily intended to help people writing new database
drivers for the Perl Database Interface (Perl
<small>DBI</small> ). It may also help others interested in
discovering why the internals of a <b><small>DBD</small></b>
driver are written the way they are.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
guide. Few (if any) of the statements in it are completely
authoritative under all possible circumstances. This means
you will need to use judgement in applying the guidelines in
this document. If in <i>any</i> doubt at all, please do
contact the <i>dbi-dev</i> mailing list (details given
below) where Tim Bunce and other driver authors can
help.</p>

<h2>CREATING A NEW DRIVER
<a name="CREATING A NEW DRIVER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The first rule
for creating a new database driver for the Perl
<small>DBI</small> is very simple: <b><small>DON</small>
&rsquo;T!</b></p>

<p style="margin-left:11%; margin-top: 1em">There is
usually a driver already available for the database you want
to use, almost regardless of which database you choose. Very
often, the database will provide an <small>ODBC</small>
driver interface, so you can often use
<b><small>DBD::ODBC</small></b> to access the database. This
is typically less convenient on a Unix box than on a
Microsoft Windows box, but there are numerous options for
<small>ODBC</small> driver managers on Unix too, and very
often the <small>ODBC</small> driver is provided by the
database supplier.</p>

<p style="margin-left:11%; margin-top: 1em">Before deciding
that you need to write a driver, do your homework to ensure
that you are not wasting your energies.</p>

<p style="margin-left:11%; margin-top: 1em">[As of December
2002, the consensus is that if you need an
<small>ODBC</small> driver manager on Unix, then the
unixODBC driver (available from
&lt;http://www.unixodbc.org/&gt;) is the way to go.]</p>

<p style="margin-left:11%; margin-top: 1em">The second rule
for creating a new database driver for the Perl
<small>DBI</small> is also very simple: <b>Don&rsquo;t --
get someone else to do it for you!</b></p>

<p style="margin-left:11%; margin-top: 1em">Nevertheless,
there are occasions when it is necessary to write a new
driver, often to use a proprietary language or
<small>API</small> to access the database more swiftly, or
more comprehensively, than an <small>ODBC</small> driver
can. Then you should read this document very carefully, but
with a suitably sceptical eye.</p>

<p style="margin-left:11%; margin-top: 1em">If there is
something in here that does not make any sense, question it.
You might be right that the information is bogus, but
don&rsquo;t come to that conclusion too quickly.</p>

<p style="margin-left:11%; margin-top: 1em"><b>URLs and
mailing lists</b> <br>
The primary web-site for locating <b><small>DBI</small></b>
software and information is</p>

<pre style="margin-left:11%; margin-top: 1em">  http://dbi.perl.org/</pre>


<p style="margin-left:11%; margin-top: 1em">There are two
main and one auxiliary mailing lists for people working with
<b><small>DBI</small></b> . The primary lists are
<i>dbi&minus;users@perl.org</i> for general users of
<b><small>DBI</small></b> and <b><small>DBD</small></b>
drivers, and <i>dbi&minus;dev@perl.org</i> mainly for
<b><small>DBD</small></b> driver writers (don&rsquo;t join
the <i>dbi-dev</i> list unless you have a good reason). The
auxiliary list is <i>dbi&minus;announce@perl.org</i> for
announcing new releases of <b><small>DBI</small></b> or
<b><small>DBD</small></b> drivers.</p>

<p style="margin-left:11%; margin-top: 1em">You can join
these lists by accessing the web-site
&lt;http://dbi.perl.org/&gt;. The lists are closed so you
cannot send email to any of the lists unless you join the
list first.</p>

<p style="margin-left:11%; margin-top: 1em">You should also
consider monitoring the <i>comp.lang.perl.*</i> newsgroups,
especially <i>comp.lang.perl.modules</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Cheetah
book</b> <br>
The definitive book on Perl <small>DBI</small> is the
Cheetah book, so called because of the picture on the cover.
Its proper title is &rsquo;<i>Programming the Perl
<small>DBI:</small> Database programming with
Perl</i>&rsquo; by Alligator Descartes and Tim Bunce,
published by O&rsquo;Reilly Associates, February 2000,
<small>ISBN 1&minus;56592&minus;699&minus;4.</small> Buy it
now if you have not already done so, and read it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Locating
drivers</b> <br>
Before writing a new driver, it is in your interests to find
out whether there already is a driver for your database. If
there is such a driver, it would be much easier to make use
of it than to write your own!</p>

<p style="margin-left:11%; margin-top: 1em">The primary
web-site for locating Perl software is
&lt;http://search.cpan.org/&gt;. You should look under the
various modules listings for the software you are after. For
example:</p>

<pre style="margin-left:11%; margin-top: 1em">  http://search.cpan.org/modlist/Database_Interfaces</pre>


<p style="margin-left:11%; margin-top: 1em">Follow the
<b><small>DBD::</small></b> and <b>DBIx::</b> links at the
top to see those subsets.</p>

<p style="margin-left:11%; margin-top: 1em">See the
<b><small>DBI</small></b> docs for information on
<b><small>DBI</small></b> web sites and mailing lists.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Registering
a new driver</b> <br>
Before going through any official registration process, you
will need to establish that there is no driver already in
the works. You&rsquo;ll do that by asking the
<b><small>DBI</small></b> mailing lists whether there is
such a driver available, or whether anybody is working on
one.</p>

<p style="margin-left:11%; margin-top: 1em">When you get
the go ahead, you will need to establish the name of the
driver and a prefix for the driver. Typically, the name is
based on the name of the database software it uses, and the
prefix is a contraction of that. Hence, <b>DBD::Oracle</b>
has the name <i>Oracle</i> and the prefix
&rsquo;<i>ora_</i>&rsquo;. The prefix must be lowercase and
contain no underscores other than the one at the end.</p>

<p style="margin-left:11%; margin-top: 1em">This
information will be recorded in the
<b><small>DBI</small></b> module. Apart from documentation
purposes, registration is a prerequisite for installing
private methods.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
writing a driver which will not be distributed on
<small>CPAN,</small> then you should choose a prefix
beginning with &rsquo;<i>x_</i>&rsquo;, to avoid potential
prefix collisions with drivers registered in the future.
Thus, if you wrote a non-CPAN distributed driver called
<b>DBD::CustomDB</b>, the prefix might be
&rsquo;<i>x_cdb_</i>&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">This document
assumes you are writing a driver called <b>DBD::Driver</b>,
and that the prefix &rsquo;<i>drv_</i>&rsquo; is assigned to
the driver.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Two styles
of database driver</b> <br>
There are two distinct styles of database driver that can be
written to work with the Perl <small>DBI.</small></p>

<p style="margin-left:11%; margin-top: 1em">Your driver can
be written in pure Perl, requiring no C compiler. When
feasible, this is the best solution, but most databases are
not written in such a way that this can be done. Some
examples of pure Perl drivers are <b>DBD::File</b> and
<b><small>DBD::CSV</small></b> .</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
and most commonly, your driver will need to use some C code
to gain access to the database. This will be classified as a
C/XS driver.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What code
will you write?</b> <br>
There are a number of files that need to be written for
either a pure Perl driver or a C/XS driver. There are no
extra files needed only by a pure Perl driver, but there are
several extra files needed only by a C/XS driver.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Files common
to pure Perl and C/XS drivers</i></p>

<p style="margin-left:11%; margin-top: 1em">Assuming that
your driver is called <b>DBD::Driver</b>, these files
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="38%">


<p><i>Makefile.PL</i></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="38%">


<p><i><small>META</small> .yml</i></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="38%">


<p><i><small>README</small></i></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="38%">


<p><i><small>MANIFEST</small></i></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="38%">


<p><i>Driver.pm</i></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="38%">


<p><i>lib/Bundle/DBD/Driver.pm</i></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="38%">


<p><i>lib/DBD/Driver/Summary.pm</i></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="38%">


<p><i>t/*.t</i></p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The first four
files are mandatory. <i>Makefile.PL</i> is used to control
how the driver is built and installed. The
<i><small>README</small></i> file tells people who download
the file about how to build the module and any prerequisite
software that must be installed. The
<i><small>MANIFEST</small></i> file is used by the standard
Perl module distribution mechanism. It lists all the source
files that need to be distributed with your module.
<i>Driver.pm</i> is what is loaded by the
<b><small>DBI</small></b> code; it contains the methods
peculiar to your driver.</p>

<p style="margin-left:11%; margin-top: 1em">Although the
<i><small>META</small> .yml</i> file is not <b>required</b>
you are advised to create one. Of particular importance are
the <i>build_requires</i> and <i>configure_requires</i>
attributes which newer <small>CPAN</small> modules
understand. You use these to tell the <small>CPAN</small>
module (and <small>CPANPLUS</small> ) that your build and
configure mechanisms require <small>DBI.</small> The best
reference for <small>META</small> .yml (at the time of
writing) is
&lt;http://module&minus;build.sourceforge.net/META&minus;spec&minus;v1.4.html&gt;.
You can find a reasonable example of a
<i><small>META</small> .yml</i> in
<small>DBD::ODBC.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<i>lib/Bundle/DBD/Driver.pm</i> file allows you to specify
other Perl modules on which yours depends in a format that
allows someone to type a simple command and ensure that all
the pre-requisites are in place as well as building your
driver.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>lib/DBD/Driver/Summary.pm</i> file contains (an updated
version of) the information that was included &minus; or
that would have been included &minus; in the appendices of
the Cheetah book as a summary of the abilities of your
driver and the associated database.</p>

<p style="margin-left:11%; margin-top: 1em">The files in
the <i>t</i> subdirectory are unit tests for your driver.
You should write your tests as stringently as possible,
while taking into account the diversity of installations
that you can encounter:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Your tests should not casually
modify operational databases.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You should never damage existing tables in a
database.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You should code your tests to use a constrained name
space within the database. For example, the tables (and all
other named objects) that are created could all begin with
&rsquo;<i>dbd_drv_</i>&rsquo;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>At the end of a test run, there should be no testing
objects left behind in the database.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If you create any databases, you should remove them.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If your database supports temporary tables that are
automatically removed at the end of a session, then exploit
them as often as possible.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Try to make your tests independent of each other. If you
have a test <i>t/t11dowhat.t</i> that depends upon the
successful running of <i>t/t10thingamy.t</i>, people cannot
run the single test case <i>t/t11dowhat.t</i>. Further,
running <i>t/t11dowhat.t</i> twice in a row is likely to
fail (at least, if <i>t/t11dowhat.t</i> modifies the
database at all) because the database at the start of the
second run is not what you saw at the start of the first
run.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Document in your <i><small>README</small></i> file what
you do, and what privileges people need to do it.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You can, and probably should, sequence your tests by
including a test number before an abbreviated version of the
test name; the tests are run in the order in which the names
are expanded by shell-style globbing.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>It is in your interests to ensure that your tests work
as widely as possible.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Many drivers
also install sub-modules <b>DBD::Driver::SubModule</b> for
any of a variety of different reasons, such as to support
the metadata methods (see the discussion of &quot;
<small>METADATA METHODS&quot;</small> below). Such
sub-modules are conventionally stored in the directory
<i>lib/DBD/Driver</i>. The module itself would usually be in
a file <i>SubModule.pm</i>. All such sub-modules should
themselves be version stamped (see the discussions far
below).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Extra files
needed by C/XS drivers</i></p>

<p style="margin-left:11%; margin-top: 1em">The software
for a C/XS driver will typically contain at least four extra
files that are not relevant to a pure Perl driver.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em"><i>Driver.xs</i></p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p><i>Driver.h</i></p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p><i>dbdimp.h</i></p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p><i>dbdimp.c</i></p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>Driver.xs</i> file is used to generate C code that Perl
can call to gain access to the C functions you write that
will, in turn, call down onto your database software.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>Driver.h</i> header is a stylized header that ensures you
can access the necessary Perl and <b><small>DBI</small></b>
macros, types, and function declarations.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>dbdimp.h</i> is used to specify which functions have been
implemented by your driver.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>dbdimp.c</i> file is where you write the C code that does
the real work of translating between Perl-ish data types and
what the database expects to use and return.</p>

<p style="margin-left:11%; margin-top: 1em">There are some
(mainly small, but very important) differences between the
contents of <i>Makefile.PL</i> and <i>Driver.pm</i> for pure
Perl and C/XS drivers, so those files are described both in
the section on creating a pure Perl driver and in the
section on creating a C/XS driver.</p>

<p style="margin-left:11%; margin-top: 1em">Obviously, you
can add extra source code files to the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Requirements
on a driver and driver writer</b> <br>
To be remotely useful, your driver must be implemented in a
format that allows it to be distributed via
<small>CPAN,</small> the Comprehensive Perl Archive Network
(&lt;http://www.cpan.org/&gt; and
&lt;http://search.cpan.org&gt;). Of course, it is easier if
you do not have to meet this criterion, but you will not be
able to ask for much help if you do not do so, and no-one is
likely to want to install your module if they have to learn
a new installation mechanism.</p>

<h2>CREATING A PURE PERL DRIVER
<a name="CREATING A PURE PERL DRIVER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Writing a pure
Perl driver is surprisingly simple. However, there are some
problems you should be aware of. The best option is of
course picking up an existing driver and carefully modifying
one method after the other.</p>

<p style="margin-left:11%; margin-top: 1em">Also look
carefully at <b>DBD::AnyData</b> and
<b>DBD::Template</b>.</p>

<p style="margin-left:11%; margin-top: 1em">As an example
we take a look at the <b>DBD::File</b> driver, a driver for
accessing plain files as tables, which is part of the
<b><small>DBD::CSV</small></b> package.</p>

<p style="margin-left:11%; margin-top: 1em">The minimal set
of files we have to implement are <i>Makefile.PL</i>,
<i><small>README</small></i> ,
<i><small>MANIFEST</small></i> and <i>Driver.pm</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pure Perl
version of Makefile.PL</b> <br>
You typically start with writing <i>Makefile.PL</i>, a
Makefile generator. The contents of this file are described
in detail in the ExtUtils::MakeMaker man pages. It is
definitely a good idea if you start reading them. At least
you should know about the variables
<i><small>CONFIGURE</small></i> ,
<i><small>DEFINED</small></i> , <i><small>PM</small></i> ,
<i><small>DIR</small></i> , <i><small>EXE_FILES</small></i>
, <i><small>INC</small></i> , <i><small>LIBS</small></i> ,
<i><small>LINKTYPE</small></i> , <i><small>NAME</small></i>
, <i><small>OPTIMIZE</small></i> ,
<i><small>PL_FILES</small></i> ,
<i><small>VERSION</small></i> ,
<i><small>VERSION_FROM</small></i> , <i>clean</i>,
<i>depend</i>, <i>realclean</i> from the ExtUtils::MakeMaker
man page: these are used in almost any
<i>Makefile.PL</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Additionally
read the section on <i>Overriding MakeMaker Methods</i> and
the descriptions of the <i>distcheck</i>, <i>disttest</i>
and <i>dist</i> targets: They will definitely be useful for
you.</p>

<p style="margin-left:11%; margin-top: 1em">Of special
importance for <b><small>DBI</small></b> drivers is the
<i>postamble</i> method from the ExtUtils::MM_Unix man
page.</p>

<p style="margin-left:11%; margin-top: 1em">For Emacs
users, I recommend the <i>libscan</i> method, which removes
Emacs backup files (file names which end with a tilde
&rsquo;~&rsquo;) from lists of files.</p>

<p style="margin-left:11%; margin-top: 1em">Now an example,
I use the word <tt>&quot;Driver&quot;</tt> wherever you
should insert your driver&rsquo;s name:</p>

<pre style="margin-left:11%; margin-top: 1em">  # &minus;*&minus; perl &minus;*&minus;
  use ExtUtils::MakeMaker;
  WriteMakefile(
      dbd_edit_mm_attribs( {
          'NAME'         =&gt; 'DBD::Driver',
          'VERSION_FROM' =&gt; 'Driver.pm',
          'INC'          =&gt; '',
          'dist'         =&gt; { 'SUFFIX'   =&gt; '.gz',
                              'COMPRESS' =&gt; 'gzip &minus;9f' },
          'realclean'    =&gt; { FILES =&gt; '*.xsi' },
          'PREREQ_PM'    =&gt; '1.03',
          'CONFIGURE'    =&gt; sub {
              eval {require DBI::DBD;};
              if ($@) {
                  warn $@;
                  exit 0;
              }
              my $dbi_arch_dir = dbd_dbi_arch_dir();
              if (exists($opts{INC})) {
                  return {INC =&gt; &quot;$opts{INC} &minus;I$dbi_arch_dir&quot;};
              } else {
                  return {INC =&gt; &quot;&minus;I$dbi_arch_dir&quot;};
              }
          }
      },
      { create_pp_tests =&gt; 1})
  );
  package MY;
  sub postamble { return main::dbd_postamble(@_); }
  sub libscan {
      my ($self, $path) = @_;
      ($path =~ m/\~$/) ? undef : $path;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Note the calls
to <tt>&quot;dbd_edit_mm_attribs()&quot;</tt> and
<tt>&quot;dbd_postamble()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The second hash
reference in the call to
<tt>&quot;dbd_edit_mm_attribs()&quot;</tt> (containing
<tt>&quot;create_pp_tests()&quot;</tt>) is optional; you
should not use it unless your driver is a pure Perl driver
(that is, it does not use C and <small>XS</small> code).
Therefore, the call to
<tt>&quot;dbd_edit_mm_attribs()&quot;</tt> is not relevant
for C/XS drivers and may be omitted; simply use the (single)
hash reference containing <small>NAME</small> etc as the
only argument to <tt>&quot;WriteMakefile()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
<tt>&quot;dbd_edit_mm_attribs()&quot;</tt> code will fail if
you do not have a <i>t</i> sub-directory containing at least
one test case.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>PREREQ_PM</small></i>
tells MakeMaker that <small>DBI</small> (version 1.03 in
this case) is required for this module. This will issue a
warning that <small>DBI 1.03</small> is missing if someone
attempts to install your <small>DBD</small> without
<small>DBI 1.03.</small> See <i><small>CONFIGURE</small></i>
below for why this does not work reliably in stopping cpan
testers failing your module if <small>DBI</small> is not
installed.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>CONFIGURE</small></i>
is a subroutine called by MakeMaker during
<tt>&quot;WriteMakefile&quot;</tt>. By putting the
<tt>&quot;require DBI::DBD&quot;</tt> in this section we can
attempt to load <small>DBI::DBD</small> but if it is missing
we exit with success. As we exit successfully without
creating a Makefile when <small>DBI::DBD</small> is missing
cpan testers will not report a failure. This may seem at
odds with <i><small>PREREQ_PM</small></i> but
<i><small>PREREQ_PM</small></i> does not cause
<tt>&quot;WriteMakefile&quot;</tt> to fail (unless you also
specify <small>PREREQ_FATAL</small> which is strongly
discouraged by MakeMaker) so
<tt>&quot;WriteMakefile&quot;</tt> would continue to call
<tt>&quot;dbd_dbi_arch_dir&quot;</tt> and fail.</p>

<p style="margin-left:11%; margin-top: 1em">All drivers
must use <tt>&quot;dbd_postamble()&quot;</tt> or risk
running into problems.</p>

<p style="margin-left:11%; margin-top: 1em">Note the
specification of <i><small>VERSION_FROM</small></i> ; the
named file (<i>Driver.pm</i>) will be scanned for the first
line that looks like an assignment to <i>$VERSION</i>, and
the subsequent text will be used to determine the version
number. Note the commentary in ExtUtils::MakeMaker on the
subject of correctly formatted version numbers.</p>

<p style="margin-left:11%; margin-top: 1em">If your driver
depends upon external software (it usually will), you will
need to add code to ensure that your environment is workable
before the call to <tt>&quot;WriteMakefile()&quot;</tt>. If
you need to check for the existence of an external library
and perhaps modify <i><small>INC</small></i> to include the
paths to where the external library header files are located
and you cannot find the library or header files make sure
you output a message saying they cannot be found but
<tt>&quot;exit 0&quot;</tt> (success) <b>before</b> calling
<tt>&quot;WriteMakefile&quot;</tt> or <small>CPAN</small>
testers will fail your module if the external library is not
found.</p>

<p style="margin-left:11%; margin-top: 1em">A full-fledged
<i>Makefile.PL</i> can be quite large (for example, the
files for <b>DBD::Oracle</b> and <b>DBD::Informix</b> are
both over 1000 lines long, and the Informix one uses &minus;
and creates &minus; auxiliary modules too).</p>

<p style="margin-left:11%; margin-top: 1em">See also
ExtUtils::MakeMaker and ExtUtils::MM_Unix. Consider using
CPAN::MakeMaker in place of <i>ExtUtils::MakeMaker</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>README</small></b>
<br>
The <small>README</small> file should describe what the
driver is for, the pre-requisites for the build process, the
actual build process, how to report errors, and who to
report them to.</p>

<p style="margin-left:11%; margin-top: 1em">Users will find
ways of breaking the driver build and test process which you
would never even have dreamed to be possible in your worst
nightmares. Therefore, you need to write this document
defensively, precisely and concisely.</p>

<p style="margin-left:11%; margin-top: 1em">As always, use
the <i><small>README</small></i> from one of the established
drivers as a basis for your own; the version in
<b>DBD::Informix</b> is worth a look as it has been quite
successful in heading off problems.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Note that users will have
versions of Perl and <b><small>DBI</small></b> that are both
older and newer than you expected, but this will seldom
cause much trouble. When it does, it will be because you are
using features of <b><small>DBI</small></b> that are not
supported in the version they are using.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Note that users will have versions of the database
software that are both older and newer than you expected.
You will save yourself time in the long run if you can
identify the range of versions which have been tested and
warn about versions which are not known to be
<small>OK.</small></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Note that many people trying to install your driver will
not be experts in the database software.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Note that many people trying to install your driver will
not be experts in C or Perl.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b><small>MANIFEST</small></b>
<br>
The <i><small>MANIFEST</small></i> will be used by the
Makefile&rsquo;s dist target to build the distribution tar
file that is uploaded to <small>CPAN.</small> It should list
every file that you want to include in your distribution,
one per line.</p>


<p style="margin-left:11%; margin-top: 1em"><b>lib/Bundle/DBD/Driver.pm</b>
<br>
The <small>CPAN</small> module provides an extremely
powerful bundle mechanism that allows you to specify
pre-requisites for your driver.</p>

<p style="margin-left:11%; margin-top: 1em">The primary
pre-requisite is <b>Bundle::DBI</b>; you may want or need to
add some more. With the bundle set up correctly, the user
can type:</p>

<pre style="margin-left:11%; margin-top: 1em">        perl &minus;MCPAN &minus;e 'install Bundle::DBD::Driver'</pre>


<p style="margin-left:11%; margin-top: 1em">and Perl will
download, compile, test and install all the Perl modules
needed to build your driver.</p>

<p style="margin-left:11%; margin-top: 1em">The
prerequisite modules are listed in the
<tt>&quot;CONTENTS&quot;</tt> section, with the official
name of the module followed by a dash and an informal name
or description.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Listing <b>Bundle::DBI</b> as
the main pre-requisite simplifies life.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Don&rsquo;t forget to list your driver.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Note that unless the <small>DBMS</small> is itself a
Perl module, you cannot list it as a pre-requisite in this
file.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You should keep the version of the bundle the same as
the version of your driver.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You should add configuration management, copyright, and
licencing information at the top.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">A suitable
skeleton for this file is shown below.</p>

<pre style="margin-left:11%; margin-top: 1em">  package Bundle::DBD::Driver;
  $VERSION = '0.01';
  1;
  __END__
  =head1 NAME
  Bundle::DBD::Driver &minus; A bundle to install all DBD::Driver related modules
  =head1 SYNOPSIS
  C&lt;perl &minus;MCPAN &minus;e 'install Bundle::DBD::Driver'&gt;
  =head1 CONTENTS
  Bundle::DBI  &minus; Bundle for DBI by TIMB (Tim Bunce)
  DBD::Driver  &minus; DBD::Driver by YOU (Your Name)
  =head1 DESCRIPTION
  This bundle includes all the modules used by the Perl Database
  Interface (DBI) driver for Driver (DBD::Driver), assuming the
  use of DBI version 1.13 or later, created by Tim Bunce.
  If you've not previously used the CPAN module to install any
  bundles, you will be interrogated during its setup phase.
  But when you've done it once, it remembers what you told it.
  You could start by running:
    C&lt;perl &minus;MCPAN &minus;e 'install Bundle::CPAN'&gt;
  =head1 SEE ALSO
  Bundle::DBI
  =head1 AUTHOR
  Your Name E&lt;lt&gt;F&lt;you@yourdomain.com&gt;E&lt;gt&gt;
  =head1 THANKS
  This bundle was created by ripping off Bundle::libnet created by
  Graham Barr E&lt;lt&gt;F&lt;gbarr@ti.com&gt;E&lt;gt&gt;, and radically simplified
  with some information from Jochen Wiedmann E&lt;lt&gt;F&lt;joe@ispsoft.de&gt;E&lt;gt&gt;.
  The template was then included in the DBI::DBD documentation by
  Jonathan Leffler E&lt;lt&gt;F&lt;jleffler@informix.com&gt;E&lt;gt&gt;.
  =cut</pre>



<p style="margin-left:11%; margin-top: 1em"><b>lib/DBD/Driver/Summary.pm</b>
<br>
There is no substitute for taking the summary file from a
driver that was documented in the Perl book (such as
<b>DBD::Oracle</b> or <b>DBD::Informix</b> or
<b><small>DBD::ODBC</small></b> , to name but three), and
adapting it to describe the facilities available via
<b>DBD::Driver</b> when accessing the Driver database.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pure Perl
version of Driver.pm</b> <br>
The <i>Driver.pm</i> file defines the Perl module
<b>DBD::Driver</b> for your driver. It will define a package
<b>DBD::Driver</b> along with some version information, some
variable definitions, and a function
<tt>&quot;driver()&quot;</tt> which will have a more or less
standard structure.</p>

<p style="margin-left:11%; margin-top: 1em">It will also
define three sub-packages of <b>DBD::Driver</b>: <br>
DBD::Driver::dr</p>

<p style="margin-left:17%;">with methods
<tt>&quot;connect()&quot;</tt>,
<tt>&quot;data_sources()&quot;</tt> and
<tt>&quot;disconnect_all()&quot;</tt>;</p>

<p style="margin-left:11%;">DBD::Driver::db</p>

<p style="margin-left:17%;">with methods such as
<tt>&quot;prepare()&quot;</tt>;</p>

<p style="margin-left:11%;">DBD::Driver::st</p>

<p style="margin-left:17%;">with methods such as
<tt>&quot;execute()&quot;</tt> and
<tt>&quot;fetch()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>Driver.pm</i> file will also contain the documentation
specific to <b>DBD::Driver</b> in the format used by
perldoc.</p>

<p style="margin-left:11%; margin-top: 1em">In a pure Perl
driver, the <i>Driver.pm</i> file is the core of the
implementation. You will need to provide all the key methods
needed by <b><small>DBI</small></b> .</p>

<p style="margin-left:11%; margin-top: 1em">Now let&rsquo;s
take a closer look at an excerpt of <i>File.pm</i> as an
example. We ignore things that are common to any module
(even non-DBI modules) or really specific to the
<b>DBD::File</b> package.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
DBD::Driver package</i></p>

<p style="margin-left:11%; margin-top: 1em">The header</p>

<pre style="margin-left:11%; margin-top: 1em">  package DBD::File;
  use strict;
  use vars qw($VERSION $drh);
  $VERSION = &quot;1.23.00&quot;  # Version number of DBD::File</pre>


<p style="margin-left:11%; margin-top: 1em">This is where
the version number of your driver is specified, and is where
<i>Makefile.PL</i> looks for this information. Please ensure
that any other modules added with your driver are also
version stamped so that <small>CPAN</small> does not get
confused.</p>

<p style="margin-left:11%; margin-top: 1em">It is
recommended that you use a two-part (1.23) or three-part
(1.23.45) version number. Also consider the
<small>CPAN</small> system, which gets confused and
considers version 1.10 to precede version 1.9, so that using
a raw <small>CVS, RCS</small> or <small>SCCS</small> version
number is probably not appropriate (despite being very
common).</p>

<p style="margin-left:11%; margin-top: 1em">For Subversion
you could use:</p>

<pre style="margin-left:11%; margin-top: 1em">  $VERSION = sprintf(&quot;12.%06d&quot;, q$Revision: 12345 $ =~ /(\d+)/o);</pre>


<p style="margin-left:11%; margin-top: 1em">(use lots of
leading zeros on the second portion so if you move the code
to a shared repository like svn.perl.org the much larger
revision numbers won&rsquo;t cause a problem, at least not
for a few years). For <small>RCS</small> or
<small>CVS</small> you can use:</p>

<pre style="margin-left:11%; margin-top: 1em">  $VERSION = sprintf &quot;%d.%02d&quot;, '$Revision: 11.21 $ ' =~ /(\d+)\.(\d+)/;</pre>


<p style="margin-left:11%; margin-top: 1em">which pads out
the fractional part with leading zeros so all is well (so
long as you don&rsquo;t go past x.99)</p>

<pre style="margin-left:11%; margin-top: 1em">  $drh = undef;         # holds driver handle once initialized</pre>


<p style="margin-left:11%; margin-top: 1em">This is where
the driver handle will be stored, once created. Note that
you may assume there is only one handle for your driver.</p>

<p style="margin-left:11%; margin-top: 1em">The driver
constructor</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;driver()&quot;</tt> method is the driver handle
constructor. Note that the <tt>&quot;driver()&quot;</tt>
method is in the <b>DBD::Driver</b> package, not in one of
the sub-packages <b>DBD::Driver::dr</b>,
<b>DBD::Driver::db</b>, or <b>DBD::Driver::db</b>.</p>

<pre style="margin-left:11%; margin-top: 1em">  sub driver
  {
      return $drh if $drh;      # already created &minus; return same one
      my ($class, $attr) = @_;
      $class .= &quot;::dr&quot;;
      DBD::Driver::db&minus;&gt;install_method('drv_example_dbh_method');
      DBD::Driver::st&minus;&gt;install_method('drv_example_sth_method');
      # not a 'my' since we use it above to prevent multiple drivers
      $drh = DBI::_new_drh($class, {
              'Name'        =&gt; 'File',
              'Version'     =&gt; $VERSION,
              'Attribution' =&gt; 'DBD::File by Jochen Wiedmann',
          })
          or return undef;
      return $drh;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">This is a
reasonable example of how <b><small>DBI</small></b>
implements its handles. There are three kinds: <b>driver
handles</b> (typically stored in <i>$drh</i>; from now on
called <i>drh</i> or <i>$drh</i>), <b>database handles</b>
(from now on called <i>dbh</i> or <i>$dbh</i>) and
<b>statement handles</b> (from now on called <i>sth</i> or
<i>$sth</i>).</p>

<p style="margin-left:11%; margin-top: 1em">The prototype
of <tt>&quot;DBI::_new_drh()&quot;</tt> is</p>

<pre style="margin-left:11%; margin-top: 1em">  $drh = DBI::_new_drh($class, $public_attrs, $private_attrs);</pre>


<p style="margin-left:11%; margin-top: 1em">with the
following arguments: <i><br>
$class</i></p>

<p style="margin-left:17%;">is typically the class for your
driver, (for example, &quot;DBD::File::dr&quot;), passed as
the first argument to the <tt>&quot;driver()&quot;</tt>
method.</p>

<p style="margin-left:11%;"><i>$public_attrs</i></p>

<p style="margin-left:17%;">is a hash ref to attributes
like <i>Name</i>, <i>Version</i>, and <i>Attribution</i>.
These are processed and used by <b><small>DBI</small></b> .
You had better not make any assumptions about them nor
should you add private attributes here.</p>

<p style="margin-left:11%;"><i>$private_attrs</i></p>

<p style="margin-left:17%;">This is another (optional) hash
ref with your private attributes. <b><small>DBI</small></b>
will store them and otherwise leave them alone.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;DBI::_new_drh()&quot;</tt> method and the
<tt>&quot;driver()&quot;</tt> method both return
<tt>&quot;undef&quot;</tt> for failure (in which case you
must look at <i>$DBI::err</i> and <i>$DBI::errstr</i> for
the failure information, because you have no driver handle
to use).</p>

<p style="margin-left:11%; margin-top: 1em">Using
<i>install_method()</i> to expose driver-private methods</p>

<pre style="margin-left:11%; margin-top: 1em">    DBD::Foo::db&minus;&gt;install_method($method_name, \%attr);</pre>


<p style="margin-left:11%; margin-top: 1em">Installs the
driver-private method named by <tt>$method_name</tt> into
the <small>DBI</small> method dispatcher so it can be called
directly, avoiding the need to use the <i>func()</i>
method.</p>

<p style="margin-left:11%; margin-top: 1em">It is called as
a static method on the driver class to which the method
belongs. The method name must begin with the corresponding
registered driver-private prefix. For example, for
DBD::Oracle <tt>$method_name</tt> must being with
&rsquo;<tt>&quot;ora_&quot;</tt>&rsquo;, and for
DBD::AnyData it must begin with
&rsquo;<tt>&quot;ad_&quot;</tt>&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;\%attr&quot;</tt> attributes can be used to
provide fine control over how the <small>DBI</small>
dispatcher handles the dispatching of the method. However
it&rsquo;s undocumented at the moment. See the IMA_*
#define&rsquo;s in <small>DBI</small> .xs and the
O=&gt;0x000x values in the initialization of
<tt>%DBI::DBI_methods</tt> in <small>DBI</small> .pm.
(Volunteers to polish up and document the interface are very
welcome to get in touch via dbi&minus;dev@perl.org).</p>

<p style="margin-left:11%; margin-top: 1em">Methods
installed using install_method default to the standard error
handling behaviour for <small>DBI</small> methods: clearing
err and errstr before calling the method, and checking for
errors to trigger RaiseError etc. on return. This differs
from the default behaviour of <i>func()</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note for driver
authors: The DBD::Foo::xx&minus;&gt;install_method call
won&rsquo;t work until the class-hierarchy has been setup.
Normally the <small>DBI</small> looks after that just after
the driver is loaded. This means <i>install_method()</i>
can&rsquo;t be called at the time the driver is loaded
unless the class-hierarchy is set up first. The way to do
that is to call the <i>setup_driver()</i> method:</p>

<pre style="margin-left:11%; margin-top: 1em">    DBI&minus;&gt;setup_driver('DBD::Foo');</pre>


<p style="margin-left:11%; margin-top: 1em">before using
<i>install_method()</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>CLONE</small> special subroutine</p>

<p style="margin-left:11%; margin-top: 1em">Also needed
here, in the <b>DBD::Driver</b> package, is a
<tt>&quot;CLONE()&quot;</tt> method that will be called by
perl when an interpreter is cloned. All your
<tt>&quot;CLONE()&quot;</tt> method needs to do, currently,
is clear the cached <i>$drh</i> so the new interpreter
won&rsquo;t start using the cached <i>$drh</i> from the old
interpreter:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub CLONE {
    undef $drh;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">See
&lt;http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe&gt;
for details.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
DBD::Driver::dr package</i></p>

<p style="margin-left:11%; margin-top: 1em">The next lines
of code look as follows:</p>

<pre style="margin-left:11%; margin-top: 1em">  package DBD::Driver::dr; # ====== DRIVER ======
  $DBD::Driver::dr::imp_data_size = 0;</pre>


<p style="margin-left:11%; margin-top: 1em">Note that no
<i>@ISA</i> is needed here, or for the other
<b>DBD::Driver::*</b> classes, because the
<b><small>DBI</small></b> takes care of that for you when
the driver is loaded.</p>

<pre style="margin-left:11%; margin-top: 1em"> *FIX ME* Explain what the imp_data_size is, so that implementors aren't
 practicing cargo&minus;cult programming.</pre>


<p style="margin-left:11%; margin-top: 1em">The database
handle constructor</p>

<p style="margin-left:11%; margin-top: 1em">The database
handle constructor is the driver&rsquo;s (hence the changed
namespace) <tt>&quot;connect()&quot;</tt> method:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub connect
  {
      my ($drh, $dr_dsn, $user, $auth, $attr) = @_;
      # Some database specific verifications, default settings
      # and the like can go here. This should only include
      # syntax checks or similar stuff where it's legal to
      # 'die' in case of errors.
      # For example, many database packages requires specific
      # environment variables to be set; this could be where you
      # validate that they are set, or default them if they are not set.
      my $driver_prefix = &quot;drv_&quot;; # the assigned prefix for this driver
      # Process attributes from the DSN; we assume ODBC syntax
      # here, that is, the DSN looks like var1=val1;...;varN=valN
      foreach my $var ( split /;/, $dr_dsn ) {
          my ($attr_name, $attr_value) = split '=', $var, 2;
          return $drh&minus;&gt;set_err($DBI::stderr, &quot;Can't parse DSN part '$var'&quot;)
              unless defined $attr_value;
          # add driver prefix to attribute name if it doesn't have it already
          $attr_name = $driver_prefix.$attr_name
              unless $attr_name =~ /^$driver_prefix/o;
          # Store attribute into %$attr, replacing any existing value.
          # The DBI will STORE() these into $dbh after we've connected
          $attr&minus;&gt;{$attr_name} = $attr_value;
      }
      # Get the attributes we'll use to connect.
      # We use delete here because these no need to STORE them
      my $db = delete $attr&minus;&gt;{drv_database} || delete $attr&minus;&gt;{drv_db}
          or return $drh&minus;&gt;set_err($DBI::stderr, &quot;No database name given in DSN '$dr_dsn'&quot;);
      my $host = delete $attr&minus;&gt;{drv_host} || 'localhost';
      my $port = delete $attr&minus;&gt;{drv_port} || 123456;
      # Assume you can attach to your database via drv_connect:
      my $connection = drv_connect($db, $host, $port, $user, $auth)
          or return $drh&minus;&gt;set_err($DBI::stderr, &quot;Can't connect to $dr_dsn: ...&quot;);
      # create a 'blank' dbh (call superclass constructor)
      my ($outer, $dbh) = DBI::_new_dbh($drh, { Name =&gt; $dr_dsn });
      $dbh&minus;&gt;STORE('Active', 1 );
      $dbh&minus;&gt;{drv_connection} = $connection;
      return $outer;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">This is mostly
the same as in the <i>driver handle constructor</i> above.
The arguments are described in <small>DBI</small> .</p>

<p style="margin-left:11%; margin-top: 1em">The constructor
<tt>&quot;DBI::_new_dbh()&quot;</tt> is called, returning a
database handle. The constructor&rsquo;s prototype is:</p>

<pre style="margin-left:11%; margin-top: 1em">  ($outer, $inner) = DBI::_new_dbh($drh, $public_attr, $private_attr);</pre>


<p style="margin-left:11%; margin-top: 1em">with similar
arguments to those in the <i>driver handle constructor</i>,
except that the <i>$class</i> is replaced by <i>$drh</i>.
The <i>Name</i> attribute is a standard
<b><small>DBI</small></b> attribute (see &quot;Database
Handle Attributes&quot; in <small>DBI</small> ).</p>

<p style="margin-left:11%; margin-top: 1em">In scalar
context, only the outer handle is returned.</p>

<p style="margin-left:11%; margin-top: 1em">Note the use of
the <tt>&quot;STORE()&quot;</tt> method for setting the
<i>dbh</i> attributes. That&rsquo;s because within the
driver code, the handle object you have is the
&rsquo;inner&rsquo; handle of a tied hash, not the outer
handle that the users of your driver have.</p>

<p style="margin-left:11%; margin-top: 1em">Because you
have the inner handle, tie magic doesn&rsquo;t get invoked
when you get or set values in the hash. This is often very
handy for speed when you want to get or set simple
non-special driver-specific attributes.</p>

<p style="margin-left:11%; margin-top: 1em">However, some
attribute values, such as those handled by the
<b><small>DBI</small></b> like <i>PrintError</i>,
don&rsquo;t actually exist in the hash and must be read via
<tt>&quot;$h&minus;&gt;FETCH($attrib)&quot;</tt> and set via
<tt>&quot;$h&minus;&gt;STORE($attrib, $value)&quot;</tt>. If
in any doubt, use these methods.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>data_sources()</i> method</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;data_sources()&quot;</tt> method must populate and
return a list of valid data sources, prefixed with the
&quot;<i>dbi:Driver</i>&quot; incantation that allows them
to be used in the first argument of the
<tt>&quot;DBI&minus;&gt;connect()&quot;</tt> method. An
example of this might be scanning the <i>$HOME/.odbcini</i>
file on Unix for <small>ODBC</small> data sources
(DSNs).</p>

<p style="margin-left:11%; margin-top: 1em">As a trivial
example, consider a fixed list of data sources:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub data_sources
  {
      my($drh, $attr) = @_;
      my(@list) = ();
      # You need more sophisticated code than this to set @list...
      push @list, &quot;dbi:Driver:abc&quot;;
      push @list, &quot;dbi:Driver:def&quot;;
      push @list, &quot;dbi:Driver:ghi&quot;;
      # End of code to set @list
      return @list;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<i>disconnect_all()</i> method</p>

<p style="margin-left:11%; margin-top: 1em">If you need to
release any resources when the driver is unloaded, you can
provide a disconnect_all method.</p>

<p style="margin-left:11%; margin-top: 1em">Other driver
handle methods</p>

<p style="margin-left:11%; margin-top: 1em">If you need any
other driver handle methods, they can follow here.</p>

<p style="margin-left:11%; margin-top: 1em">Error
handling</p>

<p style="margin-left:11%; margin-top: 1em">It is quite
likely that something fails in the connect method. With
<b>DBD::File</b> for example, you might catch an error when
setting the current directory to something not existent by
using the (driver-specific) <i>f_dir</i> attribute.</p>

<p style="margin-left:11%; margin-top: 1em">To report an
error, you use the <tt>&quot;set_err()&quot;</tt>
method:</p>

<pre style="margin-left:11%; margin-top: 1em">  $h&minus;&gt;set_err($err, $errmsg, $state);</pre>


<p style="margin-left:11%; margin-top: 1em">This will
ensure that the error is recorded correctly and that
<i>RaiseError</i> and <i>PrintError</i> etc are handled
correctly.</p>

<p style="margin-left:11%; margin-top: 1em">Typically
you&rsquo;ll always use the method instance, aka your
method&rsquo;s first argument.</p>

<p style="margin-left:11%; margin-top: 1em">As
<tt>&quot;set_err()&quot;</tt> always returns
<tt>&quot;undef&quot;</tt> your error handling code can
usually be simplified to something like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  return $h&minus;&gt;set_err($err, $errmsg, $state) if ...;</pre>


<p style="margin-left:11%; margin-top: 1em"><i>The
DBD::Driver::db package</i></p>

<pre style="margin-left:11%; margin-top: 1em">  package DBD::Driver::db; # ====== DATABASE ======
  $DBD::Driver::db::imp_data_size = 0;</pre>


<p style="margin-left:11%; margin-top: 1em">The statement
handle constructor</p>

<p style="margin-left:11%; margin-top: 1em">There&rsquo;s
nothing much new in the statement handle constructor, which
is the <tt>&quot;prepare()&quot;</tt> method:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub prepare
  {
      my ($dbh, $statement, @attribs) = @_;
      # create a 'blank' sth
      my ($outer, $sth) = DBI::_new_sth($dbh, { Statement =&gt; $statement });
      $sth&minus;&gt;STORE('NUM_OF_PARAMS', ($statement =~ tr/?//));
      $sth&minus;&gt;{drv_params} = [];
      return $outer;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">This is still
the same -- check the arguments and call the super class
constructor <tt>&quot;DBI::_new_sth()&quot;</tt>. Again, in
scalar context, only the outer handle is returned. The
<i>Statement</i> attribute should be cached as shown.</p>

<p style="margin-left:11%; margin-top: 1em">Note the prefix
<i>drv_</i> in the attribute names: it is required that all
your private attributes use a lowercase prefix unique to
your driver. As mentioned earlier in this document, the
<b><small>DBI</small></b> contains a registry of known
driver prefixes and may one day warn about unknown
attributes that don&rsquo;t have a registered prefix.</p>

<p style="margin-left:11%; margin-top: 1em">Note that we
parse the statement here in order to set the attribute
<i><small>NUM_OF_PARAMS</small></i> . The technique
illustrated is not very reliable; it can be confused by
question marks appearing in quoted strings, delimited
identifiers or in <small>SQL</small> comments that are part
of the <small>SQL</small> statement. We could set
<i><small>NUM_OF_PARAMS</small></i> in the
<tt>&quot;execute()&quot;</tt> method instead because the
<b><small>DBI</small></b> specification explicitly allows a
driver to defer this, but then the user could not call
<tt>&quot;bind_param()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Transaction
handling</p>

<p style="margin-left:11%; margin-top: 1em">Pure Perl
drivers will rarely support transactions. Thus your
<tt>&quot;commit()&quot;</tt> and
<tt>&quot;rollback()&quot;</tt> methods will typically be
quite simple:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub commit
  {
      my ($dbh) = @_;
      if ($dbh&minus;&gt;FETCH('Warn')) {
          warn(&quot;Commit ineffective while AutoCommit is on&quot;);
      }
      0;
  }
  sub rollback {
      my ($dbh) = @_;
      if ($dbh&minus;&gt;FETCH('Warn')) {
          warn(&quot;Rollback ineffective while AutoCommit is on&quot;);
      }
      0;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Or even
simpler, just use the default methods provided by the
<b><small>DBI</small></b> that do nothing except return
<tt>&quot;undef&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>DBI</small></b> &rsquo;s default
<tt>&quot;begin_work()&quot;</tt> method can be used by
inheritance.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i><small>STORE</small> ()</i> and <i><small>FETCH</small>
()</i> methods</p>

<p style="margin-left:11%; margin-top: 1em">These methods
(that we have already used, see above) are called for you,
whenever the user does a:</p>

<pre style="margin-left:11%; margin-top: 1em">  $dbh&minus;&gt;{$attr} = $val;</pre>


<p style="margin-left:11%; margin-top: 1em">or,
respectively,</p>

<pre style="margin-left:11%; margin-top: 1em">  $val = $dbh&minus;&gt;{$attr};</pre>


<p style="margin-left:11%; margin-top: 1em">See perltie for
details on tied hash refs to understand why these methods
are required.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>DBI</small></b> will handle most attributes for
you, in particular attributes like <i>RaiseError</i> or
<i>PrintError</i>. All you have to do is handle your
driver&rsquo;s private attributes and any attributes, like
<i>AutoCommit</i> and <i>ChopBlanks</i>, that the
<b><small>DBI</small></b> can&rsquo;t handle for you.</p>

<p style="margin-left:11%; margin-top: 1em">A good example
might look like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub STORE
  {
      my ($dbh, $attr, $val) = @_;
      if ($attr eq 'AutoCommit') {
          # AutoCommit is currently the only standard attribute we have
          # to consider.
          if (!$val) { die &quot;Can't disable AutoCommit&quot;; }
          return 1;
      }
      if ($attr =~ m/^drv_/) {
          # Handle only our private attributes here
          # Note that we could trigger arbitrary actions.
          # Ideally we should warn about unknown attributes.
          $dbh&minus;&gt;{$attr} = $val; # Yes, we are allowed to do this,
          return 1;             # but only for our private attributes
      }
      # Else pass up to DBI to handle for us
      $dbh&minus;&gt;SUPER::STORE($attr, $val);
  }
  sub FETCH
  {
      my ($dbh, $attr) = @_;
      if ($attr eq 'AutoCommit') { return 1; }
      if ($attr =~ m/^drv_/) {
          # Handle only our private attributes here
          # Note that we could trigger arbitrary actions.
          return $dbh&minus;&gt;{$attr}; # Yes, we are allowed to do this,
                                # but only for our private attributes
      }
      # Else pass up to DBI to handle
      $dbh&minus;&gt;SUPER::FETCH($attr);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<b><small>DBI</small></b> will actually store and fetch
driver-specific attributes (with all lowercase names)
without warning or error, so there&rsquo;s actually no need
to implement driver-specific any code in your
<tt>&quot;FETCH()&quot;</tt> and
<tt>&quot;STORE()&quot;</tt> methods unless you need extra
logic/checks, beyond getting or setting the value.</p>

<p style="margin-left:11%; margin-top: 1em">Unless your
driver documentation indicates otherwise, the return value
of the <tt>&quot;STORE()&quot;</tt> method is unspecified
and the caller shouldn&rsquo;t use that value.</p>

<p style="margin-left:11%; margin-top: 1em">Other database
handle methods</p>

<p style="margin-left:11%; margin-top: 1em">As with the
driver package, other database handle methods may follow
here. In particular you should consider a (possibly empty)
<tt>&quot;disconnect()&quot;</tt> method and possibly a
<tt>&quot;quote()&quot;</tt> method if
<b><small>DBI</small></b> &rsquo;s default isn&rsquo;t
correct for you. You may also need the
<tt>&quot;type_info_all()&quot;</tt> and
<tt>&quot;get_info()&quot;</tt> methods, as described
elsewhere in this document.</p>

<p style="margin-left:11%; margin-top: 1em">Where
reasonable use
<tt>&quot;$h&minus;&gt;SUPER::foo()&quot;</tt> to call the
<b><small>DBI</small></b> &rsquo;s method in some or all
cases and just wrap your custom behavior around that.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
use private trace flags you&rsquo;ll probably want to be
able to set them by name. To do that you&rsquo;ll need to
define a <tt>&quot;parse_trace_flag()&quot;</tt> method
(note that&rsquo;s &quot;parse_trace_flag&quot;, singular,
not &quot;parse_trace_flags&quot;, plural).</p>

<pre style="margin-left:11%; margin-top: 1em">  sub parse_trace_flag {
      my ($h, $name) = @_;
      return 0x01000000 if $name eq 'foo';
      return 0x02000000 if $name eq 'bar';
      return 0x04000000 if $name eq 'baz';
      return 0x08000000 if $name eq 'boo';
      return 0x10000000 if $name eq 'bop';
      return $h&minus;&gt;SUPER::parse_trace_flag($name);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">All private
flag names must be lowercase, and all private flags must be
in the top 8 of the 32 bits.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
DBD::Driver::st package</i></p>

<p style="margin-left:11%; margin-top: 1em">This package
follows the same pattern the others do:</p>

<pre style="margin-left:11%; margin-top: 1em">  package DBD::Driver::st;
  $DBD::Driver::st::imp_data_size = 0;</pre>


<p style="margin-left:11%; margin-top: 1em">The
<i>execute()</i> and <i>bind_param()</i> methods</p>

<p style="margin-left:11%; margin-top: 1em">This is perhaps
the most difficult method because we have to consider
parameter bindings here. In addition to that, there are a
number of statement attributes which must be set for
inherited <b><small>DBI</small></b> methods to function
correctly (see &quot;Statement attributes&quot; below).</p>

<p style="margin-left:11%; margin-top: 1em">We present a
simplified implementation by using the <i>drv_params</i>
attribute from above:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub bind_param
  {
      my ($sth, $pNum, $val, $attr) = @_;
      my $type = (ref $attr) ? $attr&minus;&gt;{TYPE} : $attr;
      if ($type) {
          my $dbh = $sth&minus;&gt;{Database};
          $val = $dbh&minus;&gt;quote($sth, $type);
      }
      my $params = $sth&minus;&gt;{drv_params};
      $params&minus;&gt;[$pNum&minus;1] = $val;
      1;
  }
  sub execute
  {
      my ($sth, @bind_values) = @_;
      # start of by finishing any previous execution if still active
      $sth&minus;&gt;finish if $sth&minus;&gt;FETCH('Active');
      my $params = (@bind_values) ?
          \@bind_values : $sth&minus;&gt;{drv_params};
      my $numParam = $sth&minus;&gt;FETCH('NUM_OF_PARAMS');
      return $sth&minus;&gt;set_err($DBI::stderr, &quot;Wrong number of parameters&quot;)
          if @$params != $numParam;
      my $statement = $sth&minus;&gt;{'Statement'};
      for (my $i = 0;  $i &lt; $numParam;  $i++) {
          $statement =~ s/?/$params&minus;&gt;[$i]/; # XXX doesn't deal with quoting etc!
      }
      # Do anything ... we assume that an array ref of rows is
      # created and store it:
      $sth&minus;&gt;{'drv_data'} = $data;
      $sth&minus;&gt;{'drv_rows'} = @$data; # number of rows
      $sth&minus;&gt;STORE('NUM_OF_FIELDS') = $numFields;
      $sth&minus;&gt;{Active} = 1;
      @$data || '0E0';
  }</pre>


<p style="margin-left:11%; margin-top: 1em">There are a
number of things you should note here.</p>

<p style="margin-left:11%; margin-top: 1em">We initialize
the <i><small>NUM_OF_FIELDS</small></i> and <i>Active</i>
attributes here, because they are essential for
<tt>&quot;bind_columns()&quot;</tt> to work.</p>

<p style="margin-left:11%; margin-top: 1em">We use
attribute <tt>&quot;$sth&minus;&gt;{Statement}&quot;</tt>
which we created within <tt>&quot;prepare()&quot;</tt>. The
attribute <tt>&quot;$sth&minus;&gt;{Database}&quot;</tt>,
which is nothing else than the <i>dbh</i>, was automatically
created by <b><small>DBI</small></b> .</p>

<p style="margin-left:11%; margin-top: 1em">Finally, note
that (as specified in the <b><small>DBI</small></b>
specification) we return the string <tt>'0E0'</tt> instead
of the number 0, so that the result tests true but equal to
zero.</p>

<pre style="margin-left:11%; margin-top: 1em">  $sth&minus;&gt;execute() or die $sth&minus;&gt;errstr;</pre>


<p style="margin-left:11%; margin-top: 1em">The
<i>execute_array()</i>, <i>execute_for_fetch()</i> and
<i>bind_param_array()</i> methods</p>

<p style="margin-left:11%; margin-top: 1em">In general,
<small>DBD</small> &rsquo;s only need to implement
<tt>&quot;execute_for_fetch()&quot;</tt> and
<tt>&quot;bind_param_array&quot;</tt>. <small>DBI</small>
&rsquo;s default <tt>&quot;execute_array()&quot;</tt> will
invoke the <small>DBD</small> &rsquo;s
<tt>&quot;execute_for_fetch()&quot;</tt> as needed.</p>

<p style="margin-left:11%; margin-top: 1em">The following
sequence describes the interaction between
<small>DBI</small> <tt>&quot;execute_array&quot;</tt> and a
<small>DBD</small> &rsquo;s
<tt>&quot;execute_for_fetch&quot;</tt>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>App calls
<tt>&quot;$sth&minus;&gt;execute_array(\%attrs,
@array_of_arrays)&quot;</tt></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If <tt>@array_of_arrays</tt> was specified,
<small>DBI</small> processes <tt>@array_of_arrays</tt> by
calling <small>DBD</small> &rsquo;s
<tt>&quot;bind_param_array()&quot;</tt>. Alternately, App
may have directly called
<tt>&quot;bind_param_array()&quot;</tt></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p><small>DBD</small> validates and binds each array</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p><small>DBI</small> retrieves the validated param arrays
from <small>DBD</small> &rsquo;s ParamArray attribute</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="83%">


<p><small>DBI</small> calls <small>DBD</small> &rsquo;s
<tt>&quot;execute_for_fetch($fetch_tuple_sub,
\@tuple_status)&quot;</tt>, where
<tt>&amp;$fetch_tuple_sub</tt> is a closure to iterate over
the returned ParamArray values, and
<tt>&quot;\@tuple_status&quot;</tt> is an array to receive
the disposition status of each tuple.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="83%">


<p><small>DBD</small> iteratively calls
<tt>&amp;$fetch_tuple_sub</tt> to retrieve parameter tuples
to be added to its bulk database operation/request.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>7.</p></td>
<td width="3%"></td>
<td width="83%">


<p>when <small>DBD</small> reaches the limit of tuples it
can handle in a single database operation/request, or the
<tt>&amp;$fetch_tuple_sub</tt> indicates no more tuples by
returning undef, the <small>DBD</small> executes the bulk
operation, and reports the disposition of each tuple in
\@tuple_status.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>8.</p></td>
<td width="3%"></td>
<td width="83%">


<p><small>DBD</small> repeats steps 6 and 7 until all
tuples are processed.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">E.g.,
here&rsquo;s the essence of DBD::Oracle&rsquo;s
execute_for_fetch:</p>

<pre style="margin-left:11%; margin-top: 1em">       while (1) {
           my @tuple_batch;
           for (my $i = 0; $i &lt; $batch_size; $i++) {
                push @tuple_batch, [ @{$fetch_tuple_sub&minus;&gt;() || last} ];
           }
           last unless @tuple_batch;
           my $res = ora_execute_array($sth, \@tuple_batch,
              scalar(@tuple_batch), $tuple_batch_status);
           push @$tuple_status, @$tuple_batch_status;
       }</pre>


<p style="margin-left:11%; margin-top: 1em">Note that
<small>DBI</small> &rsquo;s default
<i>execute_array()</i>/<i>execute_for_fetch()</i>
implementation requires the use of positional (i.e.,
&rsquo;?&rsquo;) placeholders. Drivers which <b>require</b>
named placeholders must either emulate positional
placeholders (e.g., see DBD::Oracle), or must implement
their own <i>execute_array()</i>/<i>execute_for_fetch()</i>
methods to properly sequence bound parameter arrays.</p>

<p style="margin-left:11%; margin-top: 1em">Fetching
data</p>

<p style="margin-left:11%; margin-top: 1em">Only one method
needs to be written for fetching data,
<tt>&quot;fetchrow_arrayref()&quot;</tt>. The other methods,
<tt>&quot;fetchrow_array()&quot;</tt>,
<tt>&quot;fetchall_arrayref()&quot;</tt>, etc, as well as
the database handle&rsquo;s <tt>&quot;select*&quot;</tt>
methods are part of <b><small>DBI</small></b> , and call
<tt>&quot;fetchrow_arrayref()&quot;</tt> as necessary.</p>

<pre style="margin-left:11%; margin-top: 1em">  sub fetchrow_arrayref
  {
      my ($sth) = @_;
      my $data = $sth&minus;&gt;{drv_data};
      my $row = shift @$data;
      if (!$row) {
          $sth&minus;&gt;STORE(Active =&gt; 0); # mark as no longer active
          return undef;
      }
      if ($sth&minus;&gt;FETCH('ChopBlanks')) {
          map { $_ =~ s/\s+$//; } @$row;
      }
      return $sth&minus;&gt;_set_fbav($row);
  }
  *fetch = \&amp;fetchrow_arrayref; # required alias for fetchrow_arrayref</pre>


<p style="margin-left:11%; margin-top: 1em">Note the use of
the method <tt>&quot;_set_fbav()&quot;</tt> -- this is
required so that <tt>&quot;bind_col()&quot;</tt> and
<tt>&quot;bind_columns()&quot;</tt> work.</p>

<p style="margin-left:11%; margin-top: 1em">If an error
occurs which leaves the <i>$sth</i> in a state where
remaining rows can&rsquo;t be fetched then <i>Active</i>
should be turned off before the method returns.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;rows()&quot;</tt> method for this driver can be
implemented like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub rows { shift&minus;&gt;{drv_rows} }</pre>


<p style="margin-left:11%; margin-top: 1em">because it
knows in advance how many rows it has fetched. Alternatively
you could delete that method and so fallback to the
<b><small>DBI</small></b> &rsquo;s own method which does the
right thing based on the number of calls to
<tt>&quot;_set_fbav()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
more_results method</p>

<p style="margin-left:11%; margin-top: 1em">If your driver
doesn&rsquo;t support multiple result sets, then don&rsquo;t
even implement this method.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, this
method needs to get the statement handle ready to fetch
results from the next result set, if there is one. Typically
you&rsquo;d start with:</p>

<pre style="margin-left:11%; margin-top: 1em">    $sth&minus;&gt;finish;</pre>


<p style="margin-left:11%; margin-top: 1em">then you should
delete all the attributes from the attribute cache that may
no longer be relevant for the new result set:</p>

<pre style="margin-left:11%; margin-top: 1em">    delete $sth&minus;&gt;{$_}
        for qw(NAME TYPE PRECISION SCALE ...);</pre>


<p style="margin-left:11%; margin-top: 1em">for drivers
written in C use:</p>

<pre style="margin-left:11%; margin-top: 1em">    hv_delete((HV*)SvRV(sth), &quot;NAME&quot;, 4, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;NULLABLE&quot;, 8, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;NUM_OF_FIELDS&quot;, 13, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;PRECISION&quot;, 9, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;SCALE&quot;, 5, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;TYPE&quot;, 4, G_DISCARD);</pre>


<p style="margin-left:11%; margin-top: 1em">Don&rsquo;t
forget to also delete, or update, any driver-private
attributes that may not be correct for the next
resultset.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>NUM_OF_FIELDS</small> attribute is a special case. It
should be set using <small>STORE:</small></p>

<pre style="margin-left:11%; margin-top: 1em">    $sth&minus;&gt;STORE(NUM_OF_FIELDS =&gt; 0); /* for DBI &lt;= 1.53 */
    $sth&minus;&gt;STORE(NUM_OF_FIELDS =&gt; $new_value);</pre>


<p style="margin-left:11%; margin-top: 1em">for drivers
written in C use this incantation:</p>

<pre style="margin-left:11%; margin-top: 1em">    /* Adjust NUM_OF_FIELDS &minus; which also adjusts the row buffer size */
    DBIc_NUM_FIELDS(imp_sth) = 0; /* for DBI &lt;= 1.53 */
    DBIc_STATE(imp_xxh)&minus;&gt;set_attr_k(sth, sv_2mortal(newSVpvn(&quot;NUM_OF_FIELDS&quot;,13)), 0,
        sv_2mortal(newSViv(mysql_num_fields(imp_sth&minus;&gt;result)))
    );</pre>


<p style="margin-left:11%; margin-top: 1em">For
<small>DBI</small> versions prior to 1.54 you&rsquo;ll also
need to explicitly adjust the number of elements in the row
buffer array (<tt>&quot;DBIc_FIELDS_AV(imp_sth)&quot;</tt>)
to match the new result set. Fill any new values with
<i>newSV</i>(0) not &amp;sv_undef. Alternatively you could
free DBIc_FIELDS_AV(imp_sth) and set it to null, but that
would mean <i>bind_columns()</i> wouldn&rsquo;t work across
result sets.</p>

<p style="margin-left:11%; margin-top: 1em">Statement
attributes</p>

<p style="margin-left:11%; margin-top: 1em">The main
difference between <i>dbh</i> and <i>sth</i> attributes is,
that you should implement a lot of attributes here that are
required by the <b><small>DBI</small></b> , such as
<i><small>NAME</small></i> , <i><small>NULLABLE</small></i>
, <i><small>TYPE</small></i> , etc. See &quot;Statement
Handle Attributes&quot; in <small>DBI</small> for a complete
list.</p>

<p style="margin-left:11%; margin-top: 1em">Pay attention
to attributes which are marked as read only, such as
<i><small>NUM_OF_PARAMS</small></i> . These attributes can
only be set the first time a statement is executed. If a
statement is prepared, then executed multiple times,
warnings may be generated.</p>

<p style="margin-left:11%; margin-top: 1em">You can protect
against these warnings, and prevent the recalculation of
attributes which might be expensive to calculate (such as
the <i><small>NAME</small></i> and <i>NAME_*</i>
attributes):</p>

<pre style="margin-left:11%; margin-top: 1em">    my $storedNumParams = $sth&minus;&gt;FETCH('NUM_OF_PARAMS');
    if (!defined $storedNumParams or $storedNumFields &lt; 0) {
        $sth&minus;&gt;STORE('NUM_OF_PARAMS') = $numParams;
        # Set other useful attributes that only need to be set once
        # for a statement, like $sth&minus;&gt;{NAME} and $sth&minus;&gt;{TYPE}
    }</pre>


<p style="margin-left:11%; margin-top: 1em">One
particularly important attribute to set correctly (mentioned
in &quot; <small>ATTRIBUTES COMMON TO ALL
HANDLES&quot;</small> in <small>DBI</small> is
<i>Active</i>. Many <b><small>DBI</small></b> methods,
including <tt>&quot;bind_columns()&quot;</tt>, depend on
this attribute.</p>

<p style="margin-left:11%; margin-top: 1em">Besides that
the <tt>&quot;STORE()&quot;</tt> and
<tt>&quot;FETCH()&quot;</tt> methods are mainly the same as
above for <i>dbh</i>&rsquo;s.</p>

<p style="margin-left:11%; margin-top: 1em">Other statement
methods</p>

<p style="margin-left:11%; margin-top: 1em">A trivial
<tt>&quot;finish()&quot;</tt> method to discard stored data,
reset any attributes (such as <i>Active</i>) and do
<tt>&quot;$sth&minus;&gt;SUPER::finish()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;ve
defined a <tt>&quot;parse_trace_flag()&quot;</tt> method in
<b>::db</b> you&rsquo;ll also want it in <b>::st</b>, so
just alias it in:</p>

<pre style="margin-left:11%; margin-top: 1em">  *parse_trace_flag = \&amp;DBD::foo:db::parse_trace_flag;</pre>


<p style="margin-left:11%; margin-top: 1em">And perhaps
some other methods that are not part of the
<b><small>DBI</small></b> specification, in particular to
make metadata available. Remember that they must have names
that begin with your drivers registered prefix so they can
be installed using
<tt>&quot;install_method()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>&quot;DESTROY()&quot;</tt> is called on a statement
handle that&rsquo;s still active
(<tt>&quot;$sth&minus;&gt;{Active}&quot;</tt> is true) then
it should effectively call
<tt>&quot;finish()&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">    sub DESTROY {
        my $sth = shift;
        $sth&minus;&gt;finish if $sth&minus;&gt;FETCH('Active');
    }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Tests</b>
<br>
The test process should conform as closely as possibly to
the Perl standard test harness.</p>

<p style="margin-left:11%; margin-top: 1em">In particular,
most (all) of the tests should be run in the <i>t</i>
sub-directory, and should simply produce an
<tt>&quot;ok&quot;</tt> when run under <tt>&quot;make
test&quot;</tt>. For details on how this is done, see the
Camel book and the section in Chapter 7, &quot;The Standard
Perl Library&quot; on Test::Harness.</p>

<p style="margin-left:11%; margin-top: 1em">The tests may
need to adapt to the type of database which is being used
for testing, and to the privileges of the user testing the
driver. For example, the <b>DBD::Informix</b> test code has
to adapt in a number of places to the type of database to
which it is connected as different Informix databases have
different capabilities: some of the tests are for databases
without transaction logs; others are for databases with a
transaction log; some versions of the server have support
for blobs, or stored procedures, or user-defined data types,
and others do not.</p>

<p style="margin-left:11%; margin-top: 1em">When a complete
file of tests must be skipped, you can provide a reason in a
pseudo-comment:</p>

<pre style="margin-left:11%; margin-top: 1em">    if ($no_transactions_available)
    {
        print &quot;1..0 # Skip: No transactions available\n&quot;;
        exit 0;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Consider
downloading the <b>DBD::Informix</b> code and look at the
code in <i>DBD/Informix/TestHarness.pm</i> which is used
throughout the <b>DBD::Informix</b> tests in the <i>t</i>
sub-directory.</p>

<h2>CREATING A C/XS DRIVER
<a name="CREATING A C/XS DRIVER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please also see
the section under &quot; <small>CREATING A PURE PERL
DRIVER&quot;</small> regarding the creation of the
<i>Makefile.PL</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Creating a new
C/XS driver from scratch will always be a daunting task. You
can and should greatly simplify your task by taking a good
reference driver implementation and modifying that to match
the database product for which you are writing a driver.</p>

<p style="margin-left:11%; margin-top: 1em">The de facto
reference driver has been the one for <b>DBD::Oracle</b>
written by Tim Bunce, who is also the author of the
<b><small>DBI</small></b> package. The <b>DBD::Oracle</b>
module is a good example of a driver implemented around a
C&minus;level <small>API.</small></p>

<p style="margin-left:11%; margin-top: 1em">Nowadays it it
seems better to base on <b><small>DBD::ODBC</small></b> ,
another driver maintained by Tim and Jeff Urlwin, because it
offers a lot of metadata and seems to become the guideline
for the future development. (Also as <b>DBD::Oracle</b> digs
deeper into the Oracle 8 <small>OCI</small> interface
it&rsquo;ll get even more hairy than it is now.)</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>DBD::Informix</b> driver is one driver implemented using
embedded <small>SQL</small> instead of a function-based
<small>API.</small> <b>DBD::Ingres</b> may also be worth a
look.</p>

<p style="margin-left:11%; margin-top: 1em"><b>C/XS version
of Driver.pm</b> <br>
A lot of the code in the <i>Driver.pm</i> file is very
similar to the code for pure Perl modules &minus; see above.
However, there are also some subtle (and not so subtle)
differences, including:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="11%"></td>
<td width="77%">


<p style="margin-top: 1em">The variables
<i>$DBD::Driver::{dr|db|st}::imp_data_size</i> are not
defined here, but in the <small>XS</small> code, because
they declare the size of certain C structures.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="11%"></td>
<td width="77%">


<p>Some methods are typically moved to the
<small>XS</small> code, in particular
<tt>&quot;prepare()&quot;</tt>,
<tt>&quot;execute()&quot;</tt>,
<tt>&quot;disconnect()&quot;</tt>,
<tt>&quot;disconnect_all()&quot;</tt> and the
<tt>&quot;STORE()&quot;</tt> and
<tt>&quot;FETCH()&quot;</tt> methods.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="11%"></td>
<td width="77%">


<p>Other methods are still part of <i>Driver.pm</i>, but
have callbacks to the <small>XS</small> code.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="11%"></td>
<td width="77%">


<p>If the driver-specific parts of the <i>imp_drh_t</i>
structure need to be formally initialized (which does not
seem to be a common requirement), then you need to add a
call to an appropriate <small>XS</small> function in the
driver method of <tt>&quot;DBD::Driver::driver()&quot;</tt>,
and you define the corresponding function in
<i>Driver.xs</i>, and you define the C code in
<i>dbdimp.c</i> and the prototype in <i>dbdimp.h</i>.</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">For example,
<b>DBD::Informix</b> has such a requirement, and adds the
following call after the call to
<tt>&quot;_new_drh()&quot;</tt> in <i>Informix.pm</i>:</p>

<pre style="margin-left:23%; margin-top: 1em">  DBD::Informix::dr::driver_init($drh);</pre>


<p style="margin-left:23%; margin-top: 1em">and the
following code in <i>Informix.xs</i>:</p>

<pre style="margin-left:23%; margin-top: 1em">  # Initialize the DBD::Informix driver data structure
  void
  driver_init(drh)
      SV *drh
      CODE:
      ST(0) = dbd_ix_dr_driver_init(drh) ? &amp;sv_yes : &amp;sv_no;</pre>


<p style="margin-left:23%; margin-top: 1em">and the code in
<i>dbdimp.h</i> declares:</p>

<pre style="margin-left:23%; margin-top: 1em">  extern int dbd_ix_dr_driver_init(SV *drh);</pre>


<p style="margin-left:23%; margin-top: 1em">and the code in
<i>dbdimp.ec</i> (equivalent to <i>dbdimp.c</i>)
defines:</p>

<pre style="margin-left:23%; margin-top: 1em">  /* Formally initialize the DBD::Informix driver structure */
  int
  dbd_ix_dr_driver(SV *drh)
  {
      D_imp_drh(drh);
      imp_drh&minus;&gt;n_connections = 0;       /* No active connections */
      imp_drh&minus;&gt;current_connection = 0;  /* No current connection */
      imp_drh&minus;&gt;multipleconnections = (ESQLC_VERSION &gt;= 600) ? True : False;
      dbd_ix_link_newhead(&amp;imp_drh&minus;&gt;head);  /* Empty linked list of connections */
      return 1;
  }</pre>



<p style="margin-left:23%; margin-top: 1em"><b>DBD::Oracle</b>
has a similar requirement but gets around it by checking
whether the private data part of the driver handle is all
zeroed out, rather than add extra functions.</p>

<p style="margin-left:11%; margin-top: 1em">Now let&rsquo;s
take a closer look at an excerpt from <i>Oracle.pm</i>
(revised heavily to remove idiosyncrasies) as an example,
ignoring things that were already discussed for pure Perl
drivers.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The connect
method</i></p>

<p style="margin-left:11%; margin-top: 1em">The connect
method is the database handle constructor. You could write
either of two versions of this method: either one which
takes connection attributes (new code) and one which ignores
them (old code only).</p>

<p style="margin-left:11%; margin-top: 1em">If you ignore
the connection attributes, then you omit all mention of the
<i>$auth</i> variable (which is a reference to a hash of
attributes), and the <small>XS</small> system manages the
differences for you.</p>

<pre style="margin-left:11%; margin-top: 1em">  sub connect
  {
      my ($drh, $dbname, $user, $auth, $attr) = @_;
      # Some database specific verifications, default settings
      # and the like following here. This should only include
      # syntax checks or similar stuff where it's legal to
      # 'die' in case of errors.
      my $dbh = DBI::_new_dbh($drh, {
              'Name'   =&gt; $dbname,
          })
          or return undef;
      # Call the driver&minus;specific function _login in Driver.xs file which
      # calls the DBMS&minus;specific function(s) to connect to the database,
      # and populate internal handle data.
      DBD::Driver::db::_login($dbh, $dbname, $user, $auth, $attr)
          or return undef;
      $dbh;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">This is mostly
the same as in the pure Perl case, the exception being the
use of the private <tt>&quot;_login()&quot;</tt> callback,
which is the function that will really connect to the
database. It is implemented in <i>Driver.xst</i> (you should
not implement it) and calls
<tt>&quot;dbd_db_login6()&quot;</tt> or
<tt>&quot;dbd_db_login6_sv&quot;</tt> from <i>dbdimp.c</i>.
See below for details.</p>

<p style="margin-left:11%; margin-top: 1em">If your driver
has driver-specific attributes which may be passed in the
connect method and hence end up in <tt>$attr</tt> in
<tt>&quot;dbd_db_login6&quot;</tt> then it is best to delete
any you process so <small>DBI</small> does not send them
again via <small>STORE</small> after connect. You can do
this in C like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBD_ATTRIB_DELETE(attr, &quot;my_attribute_name&quot;,
                    strlen(&quot;my_attribute_name&quot;));</pre>


<p style="margin-left:11%; margin-top: 1em">However, prior
to <small>DBI</small> subversion version 11605 (and fixed
post 1.607) <small>DBD_ATTRIB_DELETE</small> segfaulted so
if you cannot guarantee the <small>DBI</small> version will
be post 1.607 you need to use:</p>

<pre style="margin-left:11%; margin-top: 1em">  hv_delete((HV*)SvRV(attr), &quot;my_attribute_name&quot;,
                     strlen(&quot;my_attribute_name&quot;), G_DISCARD);
 *FIX ME* Discuss removing attributes in Perl code.</pre>


<p style="margin-left:11%; margin-top: 1em"><i>The
disconnect_all method</i></p>

<pre style="margin-left:11%; margin-top: 1em"> *FIX ME* T.B.S</pre>


<p style="margin-left:11%; margin-top: 1em"><i>The
data_sources method</i></p>

<p style="margin-left:11%; margin-top: 1em">If your
<tt>&quot;data_sources()&quot;</tt> method can be
implemented in pure Perl, then do so because it is easier
than doing it in <small>XS</small> code (see the section
above for pure Perl drivers).</p>

<p style="margin-left:11%; margin-top: 1em">If your
<tt>&quot;data_sources()&quot;</tt> method must call onto
compiled functions, then you will need to define
<i>dbd_dr_data_sources</i> in your <i>dbdimp.h</i> file,
which will trigger <i>Driver.xst</i> (in
<b><small>DBI</small></b> v1.33 or greater) to generate the
<small>XS</small> code that calls your actual C function
(see the discussion below for details) and you do not code
anything in <i>Driver.pm</i> to handle it.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The prepare
method</i></p>

<p style="margin-left:11%; margin-top: 1em">The prepare
method is the statement handle constructor, and most of it
is not new. Like the <tt>&quot;connect()&quot;</tt> method,
it now has a C callback:</p>

<pre style="margin-left:11%; margin-top: 1em">  package DBD::Driver::db; # ====== DATABASE ======
  use strict;
  sub prepare
  {
      my ($dbh, $statement, $attribs) = @_;
      # create a 'blank' sth
      my $sth = DBI::_new_sth($dbh, {
          'Statement' =&gt; $statement,
          })
          or return undef;
      # Call the driver&minus;specific function _prepare in Driver.xs file
      # which calls the DBMS&minus;specific function(s) to prepare a statement
      # and populate internal handle data.
      DBD::Driver::st::_prepare($sth, $statement, $attribs)
          or return undef;
      $sth;
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><i>The execute
method</i></p>

<pre style="margin-left:11%; margin-top: 1em"> *FIX ME* T.B.S</pre>


<p style="margin-left:11%; margin-top: 1em"><i>The
fetchrow_arrayref method</i></p>

<pre style="margin-left:11%; margin-top: 1em"> *FIX ME* T.B.S</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Other
methods?</i></p>

<pre style="margin-left:11%; margin-top: 1em"> *FIX ME* T.B.S</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Driver.xs</b>
<i><br>
Driver.xs</i> should look something like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  #include &quot;Driver.h&quot;
  DBISTATE_DECLARE;
  INCLUDE: Driver.xsi
  MODULE = DBD::Driver    PACKAGE = DBD::Driver::dr
  /* Non&minus;standard drh XS methods following here, if any.       */
  /* If none (the usual case), omit the MODULE line above too. */
  MODULE = DBD::Driver    PACKAGE = DBD::Driver::db
  /* Non&minus;standard dbh XS methods following here, if any.       */
  /* Currently this includes things like _list_tables from     */
  /* DBD::mSQL and DBD::mysql.                                 */
  MODULE = DBD::Driver    PACKAGE = DBD::Driver::st
  /* Non&minus;standard sth XS methods following here, if any.       */
  /* In particular this includes things like _list_fields from */
  /* DBD::mSQL and DBD::mysql for accessing metadata.          */</pre>


<p style="margin-left:11%; margin-top: 1em">Note especially
the include of <i>Driver.xsi</i> here:
<b><small>DBI</small></b> inserts stub functions for almost
all private methods here which will typically do much work
for you.</p>

<p style="margin-left:11%; margin-top: 1em">Wherever you
really have to implement something, it will call a private
function in <i>dbdimp.c</i>, and this is what you have to
implement.</p>

<p style="margin-left:11%; margin-top: 1em">You need to set
up an extra routine if your driver needs to export constants
of its own, analogous to the <small>SQL</small> types
available when you say:</p>

<pre style="margin-left:11%; margin-top: 1em">  use DBI qw(:sql_types);
 *FIX ME* T.B.S</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Driver.h</b>
<i><br>
Driver.h</i> is very simple and the operational contents
should look like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  #ifndef DRIVER_H_INCLUDED
  #define DRIVER_H_INCLUDED
  #define NEED_DBIXS_VERSION 93    /* 93 for DBI versions 1.00 to 1.51+ */
  #define PERL_NO_GET_CONTEXT      /* if used require DBI 1.51+ */
  #include &lt;DBIXS.h&gt;      /* installed by the DBI module  */
  #include &quot;dbdimp.h&quot;
  #include &quot;dbivport.h&quot;   /* see below                    */
  #include &lt;dbd_xsh.h&gt;    /* installed by the DBI module  */
  #endif /* DRIVER_H_INCLUDED */</pre>


<p style="margin-left:11%; margin-top: 1em">The
<i><small>DBIXS</small> .h</i> header defines most of the
interesting information that the writer of a driver
needs.</p>

<p style="margin-left:11%; margin-top: 1em">The file
<i>dbd_xsh.h</i> header provides prototype declarations for
the C functions that you might decide to implement. Note
that you should normally only define one of
<tt>&quot;dbd_db_login()&quot;</tt>,
<tt>&quot;dbd_db_login6()&quot;</tt> or
<tt>&quot;dbd_db_login6_sv&quot;</tt> unless you are intent
on supporting really old versions of
<b><small>DBI</small></b> (prior to
<b><small>DBI</small></b> 1.06) as well as modern versions.
The only standard, <b><small>DBI</small></b> &minus;mandated
functions that you need write are those specified in the
<i>dbd_xsh.h</i> header. You might also add extra
driver-specific functions in <i>Driver.xs</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>dbivport.h</i> file should be <i>copied</i> from the
latest <b><small>DBI</small></b> release into your
distribution each time you modify your driver. Its job is to
allow you to enhance your code to work with the latest
<b><small>DBI</small></b> <small>API</small> while still
allowing your driver to be compiled and used with older
versions of the <b><small>DBI</small></b> (for example, when
the <tt>&quot;DBIh_SET_ERR_CHAR()&quot;</tt> macro was added
to <b><small>DBI</small></b> 1.41, an emulation of it was
added to <i>dbivport.h</i>). This makes users happy and your
life easier. Always read the notes in <i>dbivport.h</i> to
check for any limitations in the emulation that you should
be aware of.</p>

<p style="margin-left:11%; margin-top: 1em">With
<b><small>DBI</small></b> v1.51 or better I recommend that
the driver defines <i><small>PERL_NO_GET_CONTEXT</small></i>
before <i><small>DBIXS</small> .h</i> is included. This can
significantly improve efficiency when running under a thread
enabled perl. (Remember that the standard perl in most Linux
distributions is built with threads enabled. So is
ActiveState perl for Windows, and perl built for Apache
mod_perl2.) If you do this there are some things to keep in
mind:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If
<i><small>PERL_NO_GET_CONTEXT</small></i> is defined, then
every function that calls the Perl <small>API</small> will
need to start out with a <tt>&quot;dTHX;&quot;</tt>
declaration.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You&rsquo;ll know which functions need this, because the
C compiler will complain that the undeclared identifier
<tt>&quot;my_perl&quot;</tt> is used if <i>and only if</i>
the perl you are using to develop and test your driver has
threads enabled.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If you don&rsquo;t remember to test with a
thread-enabled perl before making a release it&rsquo;s
likely that you&rsquo;ll get failure reports from users who
are.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>For driver private functions it is possible to gain even
more efficiency by replacing <tt>&quot;dTHX;&quot;</tt> with
<tt>&quot;pTHX_&quot;</tt> prepended to the parameter list
and then <tt>&quot;aTHX_&quot;</tt> prepended to the
argument list where the function is called.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">See &quot;How
multiple interpreters and concurrency are supported&quot; in
perlguts for additional information about
<i><small>PERL_NO_GET_CONTEXT</small></i> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>Implementation
header dbdimp.h</b> <br>
This header file has two jobs:</p>

<p style="margin-left:11%; margin-top: 1em">First it
defines data structures for your private part of the
handles.</p>

<p style="margin-left:11%; margin-top: 1em">Second it
defines macros that rename the generic names like
<tt>&quot;dbd_db_login()&quot;</tt> to database specific
names like <tt>&quot;ora_db_login()&quot;</tt>. This avoids
name clashes and enables use of different drivers when you
work with a statically linked perl.</p>

<p style="margin-left:11%; margin-top: 1em">It also will
have the important task of disabling <small>XS</small>
methods that you don&rsquo;t want to implement.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, the
macros will also be used to select alternate implementations
of some functions. For example, the
<tt>&quot;dbd_db_login()&quot;</tt> function is not passed
the attribute hash.</p>

<p style="margin-left:11%; margin-top: 1em">Since
<b><small>DBI</small></b> v1.06, if a
<tt>&quot;dbd_db_login6()&quot;</tt> macro is defined (for a
function with 6 arguments), it will be used instead with the
attribute hash passed as the sixth argument.</p>

<p style="margin-left:11%; margin-top: 1em">Since
<b><small>DBI</small></b> post v1.607, if a
<tt>&quot;dbd_db_login6_sv()&quot;</tt> macro is defined
(for a function like dbd_db_login6 but with scalar pointers
for the dbname, username and password), it will be used
instead. This will allow your login6 function to see if
there are any Unicode characters in the dbname.</p>

<p style="margin-left:11%; margin-top: 1em">People used to
just pick Oracle&rsquo;s <i>dbdimp.c</i> and use the same
names, structures and types. I strongly recommend against
that. At first glance this saves time, but your
implementation will be less readable. It was just hell when
I had to separate <b><small>DBI</small></b> specific parts,
Oracle specific parts, mSQL specific parts and mysql
specific parts in <b>DBD::mysql</b>&rsquo;s <i>dbdimp.h</i>
and <i>dbdimp.c</i>. (<b>DBD::mysql</b> was a port of
<b>DBD::mSQL</b> which was based on <b>DBD::Oracle</b>.)
[Seconded, based on the experience taking
<b>DBD::Informix</b> apart, even though the version
inherited in 1996 was only based on <b>DBD::Oracle</b>.]</p>

<p style="margin-left:11%; margin-top: 1em">This part of
the driver is <i>your exclusive part</i>. Rewrite it from
scratch, so it will be clean and short: in other words, a
better piece of code. (Of course keep an eye on other
people&rsquo;s work.)</p>

<pre style="margin-left:11%; margin-top: 1em">  struct imp_drh_st {
      dbih_drc_t com;           /* MUST be first element in structure   */
      /* Insert your driver handle attributes here */
  };
  struct imp_dbh_st {
      dbih_dbc_t com;           /* MUST be first element in structure   */
      /* Insert your database handle attributes here */
  };
  struct imp_sth_st {
      dbih_stc_t com;           /* MUST be first element in structure   */
      /* Insert your statement handle attributes here */
  };
  /*  Rename functions for avoiding name clashes; prototypes are  */
  /*  in dbd_xsh.h                                                */
  #define dbd_init            drv_dr_init
  #define dbd_db_login6_sv    drv_db_login_sv
  #define dbd_db_do           drv_db_do
  ... many more here ...</pre>


<p style="margin-left:11%; margin-top: 1em">These
structures implement your private part of the handles.</p>

<p style="margin-left:11%; margin-top: 1em">You <i>have</i>
to use the name <tt>&quot;imp_dbh_{dr|db|st}&quot;</tt> and
the first field <i>must</i> be of type
<i>dbih_drc_t|_dbc_t|_stc_t</i> and <i>must</i> be called
<tt>&quot;com&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">You should
never access these fields directly, except by using the
<i>DBIc_xxx()</i> macros below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Implementation
source dbdimp.c</b> <br>
Conventionally, <i>dbdimp.c</i> is the main implementation
file (but <b>DBD::Informix</b> calls the file
<i>dbdimp.ec</i>). This section includes a short note on
each function that is used in the <i>Driver.xsi</i> template
and thus <i>has</i> to be implemented.</p>

<p style="margin-left:11%; margin-top: 1em">Of course, you
will probably also need to implement other support
functions, which should usually be file static if they are
placed in <i>dbdimp.c</i>. If they are placed in other
files, you need to list those files in <i>Makefile.PL</i>
(and <i><small>MANIFEST</small></i> ) to handle them
correctly.</p>

<p style="margin-left:11%; margin-top: 1em">It is wise to
adhere to a namespace convention for your functions to avoid
conflicts. For example, for a driver with prefix
<i>drv_</i>, you might call externally visible functions
<i>dbd_drv_xxxx</i>. You should also avoid non-constant
global variables as much as possible to improve the support
for threading.</p>

<p style="margin-left:11%; margin-top: 1em">Since Perl
requires support for function prototypes (
<small>ANSI</small> or <small>ISO</small> or Standard C),
you should write your code using function prototypes
too.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to use either the unmapped names such as
<tt>&quot;dbd_init()&quot;</tt> or the mapped names such as
<tt>&quot;dbd_ix_dr_init()&quot;</tt> in the <i>dbdimp.c</i>
file. <b>DBD::Informix</b> uses the mapped names which makes
it easier to identify where to look for linkage problems at
runtime (which will report errors using the mapped
names).</p>

<p style="margin-left:11%; margin-top: 1em">Most other
drivers, and in particular <b>DBD::Oracle</b>, use the
unmapped names in the source code which makes it a little
easier to compare code between drivers and eases discussions
on the <i>dbi-dev</i> mailing list. The majority of the code
fragments here will use the unmapped names.</p>

<p style="margin-left:11%; margin-top: 1em">Ultimately, you
should provide implementations for most of the functions
listed in the <i>dbd_xsh.h</i> header. The exceptions are
optional functions (such as
<tt>&quot;dbd_st_rows()&quot;</tt>) and those functions with
alternative signatures, such as
<tt>&quot;dbd_db_login6_sv&quot;</tt>,
<tt>&quot;dbd_db_login6()&quot;</tt> and
<i>dbd_db_login()</i>. Then you should only implement one of
the alternatives, and generally the newer one of the
alternatives.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The dbd_init
method</i></p>

<pre style="margin-left:11%; margin-top: 1em">  #include &quot;Driver.h&quot;
  DBISTATE_DECLARE;
  void dbd_init(dbistate_t* dbistate)
  {
      DBISTATE_INIT;  /*  Initialize the DBI macros  */
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;dbd_init()&quot;</tt> function will be called when
your driver is first loaded; the bootstrap command in
<tt>&quot;DBD::Driver::dr::driver()&quot;</tt> triggers
this, and the call is generated in the
<i><small>BOOT</small></i> section of <i>Driver.xst</i>.
These statements are needed to allow your driver to use the
<b><small>DBI</small></b> macros. They will include your
private header file <i>dbdimp.h</i> in turn. Note that
<i><small>DBISTATE_INIT</small></i> requires the name of the
argument to <tt>&quot;dbd_init()&quot;</tt> to be called
<tt>&quot;dbistate()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_drv_error method</i></p>

<p style="margin-left:11%; margin-top: 1em">You need a
function to record errors so <b><small>DBI</small></b> can
access them properly. You can call it whatever you like, but
we&rsquo;ll call it <tt>&quot;dbd_drv_error()&quot;</tt>
here.</p>

<p style="margin-left:11%; margin-top: 1em">The argument
list depends on your database software; different systems
provide different ways to get at error information.</p>

<pre style="margin-left:11%; margin-top: 1em">  static void dbd_drv_error(SV *h, int rc, const char *what)
  {</pre>


<p style="margin-left:11%; margin-top: 1em">Note that
<i>h</i> is a generic handle, may it be a driver handle, a
database or a statement handle.</p>

<pre style="margin-left:11%; margin-top: 1em">      D_imp_xxh(h);</pre>


<p style="margin-left:11%; margin-top: 1em">This macro will
declare and initialize a variable <i>imp_xxh</i> with a
pointer to your private handle pointer. You may cast this to
to <i>imp_drh_t</i>, <i>imp_dbh_t</i> or
<i>imp_sth_t</i>.</p>

<p style="margin-left:11%; margin-top: 1em">To record the
error correctly, equivalent to the
<tt>&quot;set_err()&quot;</tt> method, use one of the
<tt>&quot;DBIh_SET_ERR_CHAR(...)&quot;</tt> or
<tt>&quot;DBIh_SET_ERR_SV(...)&quot;</tt> macros, which were
added in <b><small>DBI</small></b> 1.41:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIh_SET_ERR_SV(h, imp_xxh, err, errstr, state, method);
  DBIh_SET_ERR_CHAR(h, imp_xxh, err_c, err_i, errstr, state, method);</pre>


<p style="margin-left:11%; margin-top: 1em">For
<tt>&quot;DBIh_SET_ERR_SV&quot;</tt> the <i>err</i>,
<i>errstr</i>, <i>state</i>, and <i>method</i> parameters
are <tt>&quot;SV*&quot;</tt> (use &amp;sv_undef instead of
<small>NULL</small> ).</p>

<p style="margin-left:11%; margin-top: 1em">For
<tt>&quot;DBIh_SET_ERR_CHAR&quot;</tt> the <i>err_c</i>,
<i>errstr</i>, <i>state</i>, <i>method</i> parameters are
<tt>&quot;char*&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>err_i</i> parameter is an <tt>&quot;IV&quot;</tt>
that&rsquo;s used instead of <i>err_c</i> if <i>err_c</i> is
<tt>&quot;Null&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>method</i> parameter can be ignored.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;DBIh_SET_ERR_CHAR&quot;</tt> macro is usually the
simplest to use when you just have an integer error code and
an error message string:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIh_SET_ERR_CHAR(h, imp_xxh, Nullch, rc, what, Nullch, Nullch);</pre>


<p style="margin-left:11%; margin-top: 1em">As you can see,
any parameters that aren&rsquo;t relevant to you can be
<tt>&quot;Null&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">To make drivers
compatible with <b><small>DBI</small></b> &lt; 1.41 you
should be using <i>dbivport.h</i> as described in
&quot;Driver.h&quot; above.</p>

<p style="margin-left:11%; margin-top: 1em">The (obsolete)
macros such as <tt>&quot;DBIh_EVENT2&quot;</tt> should be
removed from drivers.</p>

<p style="margin-left:11%; margin-top: 1em">The names
<tt>&quot;dbis&quot;</tt> and <tt>&quot;DBIS&quot;</tt>,
which were used in previous versions of this document,
should be replaced with the
<tt>&quot;DBIc_DBISTATE(imp_xxh)&quot;</tt> macro.</p>

<p style="margin-left:11%; margin-top: 1em">The name
<tt>&quot;DBILOGFP&quot;</tt>, which was also used in
previous versions of this document, should be replaced by
<tt>&quot;DBIc_LOGPIO(imp_xxh)&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Your code
should not call the C <tt>&quot;&lt;stdio.h&gt;&quot;</tt>
I/O functions; you should use
<tt>&quot;PerlIO_printf()&quot;</tt> as shown:</p>

<pre style="margin-left:11%; margin-top: 1em">      if (DBIc_TRACE_LEVEL(imp_xxh) &gt;= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), &quot;foobar %s: %s\n&quot;,
              foo, neatsvpv(errstr,0));</pre>


<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
the first time we see how tracing works within a
<b><small>DBI</small></b> driver. Make use of this as often
as you can, but don&rsquo;t output anything at a trace level
less than 3. Levels 1 and 2 are reserved for the
<b><small>DBI</small></b> .</p>

<p style="margin-left:11%; margin-top: 1em">You can define
up to 8 private trace flags using the top 8 bits of
<tt>&quot;DBIc_TRACE_FLAGS(imp)&quot;</tt>, that is:
<tt>0xFF000000</tt>. See the
<tt>&quot;parse_trace_flag()&quot;</tt> method elsewhere in
this document.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_dr_data_sources method</i></p>

<p style="margin-left:11%; margin-top: 1em">This method is
optional; the support for it was added in
<b><small>DBI</small></b> v1.33.</p>

<p style="margin-left:11%; margin-top: 1em">As noted in the
discussion of <i>Driver.pm</i>, if the data sources can be
determined by pure Perl code, do it that way. If, as in
<b>DBD::Informix</b>, the information is obtained by a C
function call, then you need to define a function that
matches the prototype:</p>

<pre style="margin-left:11%; margin-top: 1em">  extern AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attrs);</pre>


<p style="margin-left:11%; margin-top: 1em">An outline
implementation for <b>DBD::Informix</b> follows, assuming
that the <tt>&quot;sqgetdbs()&quot;</tt> function call shown
will return up to 100 databases names, with the pointers to
each name in the array dbsname and the name strings
themselves being stores in dbsarea.</p>

<pre style="margin-left:11%; margin-top: 1em">  AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attr)
  {
      int ndbs;
      int i;
      char *dbsname[100];
      char  dbsarea[10000];
      AV *av = Nullav;
      if (sqgetdbs(&amp;ndbs, dbsname, 100, dbsarea, sizeof(dbsarea)) == 0)
      {
          av = NewAV();
          av_extend(av, (I32)ndbs);
          sv_2mortal((SV *)av);
          for (i = 0; i &lt; ndbs; i++)
            av_store(av, i, newSVpvf(&quot;dbi:Informix:%s&quot;, dbsname[i]));
      }
      return(av);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The actual
<b>DBD::Informix</b> implementation has a number of extra
lines of code, logs function entry and exit, reports the
error from <tt>&quot;sqgetdbs()&quot;</tt>, and uses
<tt>&quot;#define&quot;</tt>&rsquo;d constants for the array
sizes.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_db_login6 method</i></p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_db_login6_sv(SV* dbh, imp_dbh_t* imp_dbh, SV* dbname,
                       SV* user, SV* auth, SV *attr);
  or
  int dbd_db_login6(SV* dbh, imp_dbh_t* imp_dbh, char* dbname,
                   char* user, char* auth, SV *attr);</pre>


<p style="margin-left:11%; margin-top: 1em">This function
will really connect to the database. The argument <i>dbh</i>
is the database handle. <i>imp_dbh</i> is the pointer to the
handles private data, as is <i>imp_xxx</i> in
<tt>&quot;dbd_drv_error()&quot;</tt> above. The arguments
<i>dbname</i>, <i>user</i>, <i>auth</i> and <i>attr</i>
correspond to the arguments of the driver handle&rsquo;s
<tt>&quot;connect()&quot;</tt> method.</p>

<p style="margin-left:11%; margin-top: 1em">You will quite
often use database specific attributes here, that are
specified in the <small>DSN. I</small> recommend you parse
the <small>DSN</small> (using Perl) within the
<tt>&quot;connect()&quot;</tt> method and pass the segments
of the <small>DSN</small> via the attributes parameter
through <tt>&quot;_login()&quot;</tt> to
<tt>&quot;dbd_db_login6()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
how you fetch them; as an example we use <i>hostname</i>
attribute, which can be up to 12 characters long excluding
null terminator:</p>

<pre style="margin-left:11%; margin-top: 1em">  SV** svp;
  STRLEN len;
  char* hostname;
  if ( (svp = DBD_ATTRIB_GET_SVP(attr, &quot;drv_hostname&quot;, 12)) &amp;&amp; SvTRUE(*svp)) {
      hostname = SvPV(*svp, len);
      DBD_ATTRIB_DELETE(attr, &quot;drv_hostname&quot;, 12); /* avoid later STORE */
  } else {
      hostname = &quot;localhost&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">If you handle
any driver specific attributes in the dbd_db_login6 method
you probably want to delete them from
<tt>&quot;attr&quot;</tt> (as above with
<small>DBD_ATTRIB_DELETE</small> ). If you don&rsquo;t
delete your handled attributes <small>DBI</small> will call
<tt>&quot;STORE&quot;</tt> for each attribute after the
connect/login and this is at best redundant for attributes
you have already processed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note: Until
revision 11605 (post <small>DBI 1.607</small> ), there was a
problem with <small>DBD_ATTRIBUTE_DELETE</small> so unless
you require a <small>DBI</small> version after 1.607 you
need to replace each <small>DBD_ATTRIBUTE_DELETE</small>
call with:</b></p>

<pre style="margin-left:11%; margin-top: 1em">  hv_delete((HV*)SvRV(attr), key, key_len, G_DISCARD)</pre>


<p style="margin-left:11%; margin-top: 1em">Note that you
can also obtain standard attributes such as
<i>AutoCommit</i> and <i>ChopBlanks</i> from the attributes
parameter, using <tt>&quot;DBD_ATTRIB_GET_IV&quot;</tt> for
integer attributes.</p>

<p style="margin-left:11%; margin-top: 1em">If, for
example, your database does not support transactions but
<i>AutoCommit</i> is set off (requesting transaction
support), then you can emulate a &rsquo;failure to
connect&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">Now you should
really connect to the database. In general, if the
connection fails, it is best to ensure that all allocated
resources are released so that the handle does not need to
be destroyed separately. If you are successful (and possibly
even if you fail but you have allocated some resources), you
should use the following macros:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIc_IMPSET_on(imp_dbh);</pre>


<p style="margin-left:11%; margin-top: 1em">This indicates
that the driver (implementor) has allocated resources in the
<i>imp_dbh</i> structure and that the implementors private
<tt>&quot;dbd_db_destroy()&quot;</tt> function should be
called when the handle is destroyed.</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIc_ACTIVE_on(imp_dbh);</pre>


<p style="margin-left:11%; margin-top: 1em">This indicates
that the handle has an active connection to the server and
that the <tt>&quot;dbd_db_disconnect()&quot;</tt> function
should be called before the handle is destroyed.</p>

<p style="margin-left:11%; margin-top: 1em">Note that if
you do need to fail, you should report errors via the
<i>drh</i> or <i>imp_drh</i> rather than via <i>dbh</i> or
<i>imp_dbh</i> because <i>imp_dbh</i> will be destroyed by
the failure, so errors recorded in that handle will not be
visible to <b><small>DBI</small></b> , and hence not the
user either.</p>

<p style="margin-left:11%; margin-top: 1em">Note too, that
the function is passed <i>dbh</i> and <i>imp_dbh</i>, and
there is a macro <tt>&quot;D_imp_drh_from_dbh&quot;</tt>
which can recover the <i>imp_drh</i> from the
<i>imp_dbh</i>. However, there is no
<b><small>DBI</small></b> macro to provide you with the
<i>drh</i> given either the <i>imp_dbh</i> or the <i>dbh</i>
or the <i>imp_drh</i> (and there&rsquo;s no way to recover
the <i>dbh</i> given just the <i>imp_dbh</i>).</p>

<p style="margin-left:11%; margin-top: 1em">This suggests
that, despite the above notes about
<tt>&quot;dbd_drv_error()&quot;</tt> taking an <tt>&quot;SV
*&quot;</tt>, it may be better to have two error routines,
one taking <i>imp_dbh</i> and one taking <i>imp_drh</i>
instead. With care, you can factor most of the formatting
code out so that these are small routines calling a common
error formatter. See the code in <b>DBD::Informix</b>
1.05.00 for more information.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;dbd_db_login6()&quot;</tt> function should return
<i><small>TRUE</small></i> for success,
<i><small>FALSE</small></i> otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Drivers
implemented long ago may define the five-argument function
<tt>&quot;dbd_db_login()&quot;</tt> instead of
<tt>&quot;dbd_db_login6()&quot;</tt>. The missing argument
is the attributes. There are ways to work around the missing
attributes, but they are ungainly; it is much better to use
the 6&minus;argument form. Even later drivers will use
<tt>&quot;dbd_db_login6_sv()&quot;</tt> which provides the
dbname, username and password as SVs.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_db_commit and dbd_db_rollback methods</i></p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_db_commit(SV *dbh, imp_dbh_t *imp_dbh);
  int dbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh);</pre>


<p style="margin-left:11%; margin-top: 1em">These are used
for commit and rollback. They should return
<i><small>TRUE</small></i> for success,
<i><small>FALSE</small></i> for error.</p>

<p style="margin-left:11%; margin-top: 1em">The arguments
<i>dbh</i> and <i>imp_dbh</i> are the same as for
<tt>&quot;dbd_db_login6()&quot;</tt> above; I will omit
describing them in what follows, as they appear always.</p>

<p style="margin-left:11%; margin-top: 1em">These functions
should return <i><small>TRUE</small></i> for success,
<i><small>FALSE</small></i> otherwise.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_db_disconnect method</i></p>

<p style="margin-left:11%; margin-top: 1em">This is your
private part of the <tt>&quot;disconnect()&quot;</tt>
method. Any <i>dbh</i> with the <i><small>ACTIVE</small></i>
flag on must be disconnected. (Note that you have to set it
in <tt>&quot;dbd_db_connect()&quot;</tt> above.)</p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh);</pre>


<p style="margin-left:11%; margin-top: 1em">The database
handle will return <i><small>TRUE</small></i> for success,
<i><small>FALSE</small></i> otherwise. In any case it should
do a:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIc_ACTIVE_off(imp_dbh);</pre>


<p style="margin-left:11%; margin-top: 1em">before
returning so <b><small>DBI</small></b> knows that
<tt>&quot;dbd_db_disconnect()&quot;</tt> was executed.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
there&rsquo;s nothing to stop a <i>dbh</i> being
<i>disconnected</i> while it still have active children. If
your database <small>API</small> reacts badly to trying to
use an <i>sth</i> in this situation then you&rsquo;ll need
to add code like this to all <i>sth</i> methods:</p>

<pre style="margin-left:11%; margin-top: 1em">  if (!DBIc_ACTIVE(DBIc_PARENT_COM(imp_sth)))
    return 0;</pre>


<p style="margin-left:11%; margin-top: 1em">Alternatively,
you can add code to your driver to keep explicit track of
the statement handles that exist for each database handle
and arrange to destroy those handles before disconnecting
from the database. There is code to do this in
<b>DBD::Informix</b>. Similar comments apply to the driver
handle keeping track of all the database handles.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
code which destroys the subordinate handles should only
release the associated database resources and mark the
handles inactive; it does not attempt to free the actual
handle structures.</p>

<p style="margin-left:11%; margin-top: 1em">This function
should return <i><small>TRUE</small></i> for success,
<i><small>FALSE</small></i> otherwise, but it is not clear
what anything can do about a failure.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_db_discon_all method</i></p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_discon_all (SV *drh, imp_drh_t *imp_drh);</pre>


<p style="margin-left:11%; margin-top: 1em">This function
may be called at shutdown time. It should make best-efforts
to disconnect all database handles &minus; if possible. Some
databases don&rsquo;t support that, in which case you can do
nothing but return &rsquo;success&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">This function
should return <i><small>TRUE</small></i> for success,
<i><small>FALSE</small></i> otherwise, but it is not clear
what anything can do about a failure.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_db_destroy method</i></p>

<p style="margin-left:11%; margin-top: 1em">This is your
private part of the database handle destructor. Any
<i>dbh</i> with the <i><small>IMPSET</small></i> flag on
must be destroyed, so that you can safely free resources.
(Note that you have to set it in
<tt>&quot;dbd_db_connect()&quot;</tt> above.)</p>

<pre style="margin-left:11%; margin-top: 1em">  void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh)
  {
      DBIc_IMPSET_off(imp_dbh);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<b><small>DBI</small></b> <i>Driver.xst</i> code will have
called <tt>&quot;dbd_db_disconnect()&quot;</tt> for you, if
the handle is still &rsquo;active&rsquo;, before calling
<tt>&quot;dbd_db_destroy()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Before
returning the function must switch
<i><small>IMPSET</small></i> to off, so
<b><small>DBI</small></b> knows that the destructor was
called.</p>

<p style="margin-left:11%; margin-top: 1em">A
<b><small>DBI</small></b> handle doesn&rsquo;t keep
references to its children. But children do keep references
to their parents. So a database handle won&rsquo;t be
<tt>&quot;DESTROY&quot;</tt>&rsquo;d until all its children
have been <tt>&quot;DESTROY&quot;</tt>&rsquo;d.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_db_STORE_attrib method</i></p>

<p style="margin-left:11%; margin-top: 1em">This function
handles</p>

<pre style="margin-left:11%; margin-top: 1em">  $dbh&minus;&gt;{$key} = $value;</pre>


<p style="margin-left:11%; margin-top: 1em">Its prototype
is:</p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_db_STORE_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv,
                          SV* valuesv);</pre>


<p style="margin-left:11%; margin-top: 1em">You do not
handle all attributes; on the contrary, you should not
handle <b><small>DBI</small></b> attributes here: leave this
to <b><small>DBI</small></b> . (There are two exceptions,
<i>AutoCommit</i> and <i>ChopBlanks</i>, which you should
care about.)</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is <i><small>TRUE</small></i> if you have handled the
attribute or <i><small>FALSE</small></i> otherwise. If you
are handling an attribute and something fails, you should
call <tt>&quot;dbd_drv_error()&quot;</tt>, so
<b><small>DBI</small></b> can raise exceptions, if desired.
If <tt>&quot;dbd_drv_error()&quot;</tt> returns, however,
you have a problem: the user will never know about the
error, because he typically will not check
<tt>&quot;$dbh&minus;&gt;errstr()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">I cannot
recommend a general way of going on, if
<tt>&quot;dbd_drv_error()&quot;</tt> returns, but there are
examples where even the <b><small>DBI</small></b>
specification expects that you <tt>&quot;croak()&quot;</tt>.
(See the <i>AutoCommit</i> method in <small>DBI</small>
.)</p>

<p style="margin-left:11%; margin-top: 1em">If you have to
store attributes, you should either use your private data
structure <i>imp_xxx</i>, the handle hash (via
<tt>&quot;(HV*)SvRV(dbh)&quot;</tt>), or use the private
<i>imp_data</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The first is
best for internal C values like integers or pointers and
where speed is important within the driver. The handle hash
is best for values the user may want to get/set via
driver-specific attributes. The private <i>imp_data</i> is
an additional <tt>&quot;SV&quot;</tt> attached to the
handle. You could think of it as an unnamed handle
attribute. It&rsquo;s not normally used.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_db_FETCH_attrib method</i></p>

<p style="margin-left:11%; margin-top: 1em">This is the
counterpart of <tt>&quot;dbd_db_STORE_attrib()&quot;</tt>,
needed for:</p>

<pre style="margin-left:11%; margin-top: 1em">  $value = $dbh&minus;&gt;{$key};</pre>


<p style="margin-left:11%; margin-top: 1em">Its prototype
is:</p>

<pre style="margin-left:11%; margin-top: 1em">  SV* dbd_db_FETCH_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv);</pre>


<p style="margin-left:11%; margin-top: 1em">Unlike all
previous methods this returns an <tt>&quot;SV&quot;</tt>
with the value. Note that you should normally execute
<tt>&quot;sv_2mortal()&quot;</tt>, if you return a
nonconstant value. (Constant values are
<tt>&amp;sv_undef</tt>, <tt>&amp;sv_no</tt> and
<tt>&amp;sv_yes</tt>.)</p>

<p style="margin-left:11%; margin-top: 1em">Note, that
<b><small>DBI</small></b> implements a caching algorithm for
attribute values. If you think, that an attribute may be
fetched, you store it in the <i>dbh</i> itself:</p>

<pre style="margin-left:11%; margin-top: 1em">  if (cacheit) /* cache value for later DBI 'quick' fetch? */
      hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);</pre>


<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_st_prepare method</i></p>

<p style="margin-left:11%; margin-top: 1em">This is the
private part of the <tt>&quot;prepare()&quot;</tt> method.
Note that you <b>must not</b> really execute the statement
here. You may, however, preparse and validate the statement,
or do similar things.</p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_st_prepare(SV* sth, imp_sth_t* imp_sth, char* statement,
                     SV* attribs);</pre>


<p style="margin-left:11%; margin-top: 1em">A typical,
simple, possibility is to do nothing and rely on the perl
<tt>&quot;prepare()&quot;</tt> code that set the
<i>Statement</i> attribute on the handle. This attribute can
then be used by <tt>&quot;dbd_st_execute()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If the driver
supports placeholders then the
<i><small>NUM_OF_PARAMS</small></i> attribute must be set
correctly by <tt>&quot;dbd_st_prepare()&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIc_NUM_PARAMS(imp_sth) = ...</pre>


<p style="margin-left:11%; margin-top: 1em">If you can, you
should also setup attributes like
<i><small>NUM_OF_FIELDS</small></i> ,
<i><small>NAME</small></i> , etc. here, but
<b><small>DBI</small></b> doesn&rsquo;t require that &minus;
they can be deferred until <i>execute()</i> is called.
However, if you do, document it.</p>

<p style="margin-left:11%; margin-top: 1em">In any case you
should set the <i><small>IMPSET</small></i> flag, as you did
in <tt>&quot;dbd_db_connect()&quot;</tt> above:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIc_IMPSET_on(imp_sth);</pre>


<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_st_execute method</i></p>

<p style="margin-left:11%; margin-top: 1em">This is where a
statement will really be executed.</p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_st_execute(SV* sth, imp_sth_t* imp_sth);</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;dbd_st_execute&quot;
should return &minus;2 for any error, &minus;1 if the number
of rows affected is unknown else it should be the number of
affected (updated, inserted) rows.</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
must be aware a statement may be executed repeatedly. Also,
you should not expect that <tt>&quot;finish()&quot;</tt>
will be called between two executions, so you might need
code, like the following, near the start of the
function:</p>

<pre style="margin-left:11%; margin-top: 1em">  if (DBIc_ACTIVE(imp_sth))
      dbd_st_finish(h, imp_sth);</pre>


<p style="margin-left:11%; margin-top: 1em">If your driver
supports the binding of parameters (it should!), but the
database doesn&rsquo;t, you must do it here. This can be
done as follows:</p>

<pre style="margin-left:11%; margin-top: 1em">  SV *svp;
  char* statement = DBD_ATTRIB_GET_PV(h, &quot;Statement&quot;, 9, svp, &quot;&quot;);
  int numParam = DBIc_NUM_PARAMS(imp_sth);
  int i;
  for (i = 0; i &lt; numParam; i++)
  {
      char* value = dbd_db_get_param(sth, imp_sth, i);
      /* It is your drivers task to implement dbd_db_get_param,    */
      /* it must be setup as a counterpart of dbd_bind_ph.         */
      /* Look for '?' and replace it with 'value'.  Difficult      */
      /* task, note that you may have question marks inside        */
      /* quotes and comments the like ...  :&minus;(                     */
      /* See DBD::mysql for an example. (Don't look too deep into  */
      /* the example, you will notice where I was lazy ...)        */
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The next thing
is to really execute the statement.</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
must set the attributes <i><small>NUM_OF_FIELDS</small></i>
, <i><small>NAME</small></i> , etc when the statement is
successfully executed if the driver has not already done so:
they may be used even before a potential
<tt>&quot;fetchrow()&quot;</tt>. In particular you have to
tell <b><small>DBI</small></b> the number of fields that the
statement has, because it will be used by
<b><small>DBI</small></b> internally. Thus the function will
typically ends with:</p>

<pre style="margin-left:11%; margin-top: 1em">  if (isSelectStatement) {
      DBIc_NUM_FIELDS(imp_sth) = numFields;
      DBIc_ACTIVE_on(imp_sth);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">It is important
that the <i><small>ACTIVE</small></i> flag only be set for
<tt>&quot;SELECT&quot;</tt> statements (or any other
statements that can return many values from the database
using a cursor-like mechanism). See
<tt>&quot;dbd_db_connect()&quot;</tt> above for more
explanations.</p>

<p style="margin-left:11%; margin-top: 1em">There plans for
a preparse function to be provided by
<b><small>DBI</small></b> , but this has not reached
fruition yet. Meantime, if you want to know how ugly it can
get, try looking at the
<tt>&quot;dbd_ix_preparse()&quot;</tt> in
<b>DBD::Informix</b> <i>dbdimp.ec</i> and the related
functions in <i>iustoken.c</i> and <i>sqltoken.c</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_st_fetch method</i></p>

<p style="margin-left:11%; margin-top: 1em">This function
fetches a row of data. The row is stored in in an array, of
<tt>&quot;SV&quot;</tt>&rsquo;s that
<b><small>DBI</small></b> prepares for you. This has two
advantages: it is fast (you even reuse the
<tt>&quot;SV&quot;</tt>&rsquo;s, so they don&rsquo;t have to
be created after the first <tt>&quot;fetchrow()&quot;</tt>),
and it guarantees that <b><small>DBI</small></b> handles
<tt>&quot;bind_cols()&quot;</tt> for you.</p>

<p style="margin-left:11%; margin-top: 1em">What you do is
the following:</p>

<pre style="margin-left:11%; margin-top: 1em">  AV* av;
  int numFields = DBIc_NUM_FIELDS(imp_sth); /* Correct, if NUM_FIELDS
      is constant for this statement. There are drivers where this is
      not the case! */
  int chopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);
  int i;
  if (!fetch_new_row_of_data(...)) {
      ... /* check for error or end&minus;of&minus;data */
      DBIc_ACTIVE_off(imp_sth); /* turn off Active flag automatically */
      return Nullav;
  }
  /* get the fbav (field buffer array value) for this row       */
  /* it is very important to only call this after you know      */
  /* that you have a row of data to return.                     */
  av = DBIc_DBISTATE(imp_sth)&minus;&gt;get_fbav(imp_sth);
  for (i = 0; i &lt; numFields; i++) {
      SV* sv = fetch_a_field(..., i);
      if (chopBlanks &amp;&amp; SvOK(sv) &amp;&amp; type_is_blank_padded(field_type[i])) {
          /*  Remove white space from end (only) of sv  */
      }
      sv_setsv(AvARRAY(av)[i], sv); /* Note: (re)use! */
  }
  return av;</pre>


<p style="margin-left:11%; margin-top: 1em">There&rsquo;s
no need to use a <tt>&quot;fetch_a_field()&quot;</tt>
function returning an <tt>&quot;SV*&quot;</tt>. It&rsquo;s
more common to use your database <small>API</small>
functions to fetch the data as character strings and use
code like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  sv_setpvn(AvARRAY(av)[i], char_ptr, char_count);</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;NULL&quot;
values must be returned as <tt>&quot;undef&quot;</tt>. You
can use code like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  SvOK_off(AvARRAY(av)[i]);</pre>


<p style="margin-left:11%; margin-top: 1em">The function
returns the <tt>&quot;AV&quot;</tt> prepared by
<b><small>DBI</small></b> for success or
<tt>&quot;Nullav&quot;</tt> otherwise.</p>

<pre style="margin-left:11%; margin-top: 1em"> *FIX ME* Discuss what happens when there's no more data to fetch.
 Are errors permitted if another fetch occurs after the first fetch
 that reports no more data. (Permitted, not required.)</pre>


<p style="margin-left:11%; margin-top: 1em">If an error
occurs which leaves the <i>$sth</i> in a state where
remaining rows can&rsquo;t be fetched then <i>Active</i>
should be turned off before the method returns.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_st_finish3 method</i></p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;$sth&minus;&gt;finish()&quot;</tt> method can be
called if the user wishes to indicate that no more rows will
be fetched even if the database has more rows to offer, and
the <b><small>DBI</small></b> code can call the function
when handles are being destroyed. See the
<b><small>DBI</small></b> specification for more background
details.</p>

<p style="margin-left:11%; margin-top: 1em">In both
circumstances, the <b><small>DBI</small></b> code ends up
calling the <tt>&quot;dbd_st_finish3()&quot;</tt> method (if
you provide a mapping for
<tt>&quot;dbd_st_finish3()&quot;</tt> in <i>dbdimp.h</i>),
or <tt>&quot;dbd_st_finish()&quot;</tt> otherwise. The
difference is that <tt>&quot;dbd_st_finish3()&quot;</tt>
takes a third argument which is an <tt>&quot;int&quot;</tt>
with the value 1 if it is being called from a
<tt>&quot;destroy()&quot;</tt> method and 0 otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<b><small>DBI</small></b> v1.32 and earlier test on
<tt>&quot;dbd_db_finish3()&quot;</tt> to call
<tt>&quot;dbd_st_finish3()&quot;</tt>; if you provide
<tt>&quot;dbd_st_finish3()&quot;</tt>, either define
<tt>&quot;dbd_db_finish3()&quot;</tt> too, or insist on
<b><small>DBI</small></b> v1.33 or later.</p>

<p style="margin-left:11%; margin-top: 1em">All it
<i>needs</i> to do is turn off the <i>Active</i> flag for
the <i>sth</i>. It will only be called by <i>Driver.xst</i>
code, if the driver has set <i><small>ACTIVE</small></i> to
on for the <i>sth</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Outline
example:</p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_st_finish3(SV* sth, imp_sth_t* imp_sth, int from_destroy) {
      if (DBIc_ACTIVE(imp_sth))
      {
          /* close cursor or equivalent action */
          DBIc_ACTIVE_off(imp_sth);
      }
      return 1;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
from_destroy parameter is true if
<tt>&quot;dbd_st_finish3()&quot;</tt> is being called from
<tt>&quot;DESTROY()&quot;</tt> &minus; and so the statement
is about to be destroyed. For many drivers there is no point
in doing anything more than turning off the <i>Active</i>
flag in this case.</p>

<p style="margin-left:11%; margin-top: 1em">The function
returns <i><small>TRUE</small></i> for success,
<i><small>FALSE</small></i> otherwise, but there isn&rsquo;t
a lot anyone can do to recover if there is an error.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_st_destroy method</i></p>

<p style="margin-left:11%; margin-top: 1em">This function
is the private part of the statement handle destructor.</p>

<pre style="margin-left:11%; margin-top: 1em">  void dbd_st_destroy(SV* sth, imp_sth_t* imp_sth) {
      ... /* any clean&minus;up that's needed */
      DBIc_IMPSET_off(imp_sth); /* let DBI know we've done it   */
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<b><small>DBI</small></b> <i>Driver.xst</i> code will call
<tt>&quot;dbd_st_finish()&quot;</tt> for you, if the
<i>sth</i> has the <i><small>ACTIVE</small></i> flag set,
before calling <tt>&quot;dbd_st_destroy()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods</i></p>

<p style="margin-left:11%; margin-top: 1em">These functions
correspond to <tt>&quot;dbd_db_STORE()&quot;</tt> and
<tt>&quot;dbd_db_FETCH()&quot;</tt> attrib above, except
that they are for statement handles. See above.</p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_st_STORE_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv,
                          SV* valuesv);
  SV* dbd_st_FETCH_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv);</pre>


<p style="margin-left:11%; margin-top: 1em"><i>The
dbd_bind_ph method</i></p>

<p style="margin-left:11%; margin-top: 1em">This function
is internally used by the <tt>&quot;bind_param()&quot;</tt>
method, the <tt>&quot;bind_param_inout()&quot;</tt> method
and by the <b><small>DBI</small></b> <i>Driver.xst</i> code
if <tt>&quot;execute()&quot;</tt> is called with any bind
parameters.</p>

<pre style="margin-left:11%; margin-top: 1em">  int dbd_bind_ph (SV *sth, imp_sth_t *imp_sth, SV *param,
                   SV *value, IV sql_type, SV *attribs,
                   int is_inout, IV maxlen);</pre>


<p style="margin-left:11%; margin-top: 1em">The
<i>param</i> argument holds an <tt>&quot;IV&quot;</tt> with
the parameter number (1, 2, ...). The <i>value</i> argument
is the parameter value and <i>sql_type</i> is its type.</p>

<p style="margin-left:11%; margin-top: 1em">If your driver
does not support <tt>&quot;bind_param_inout()&quot;</tt>
then you should ignore <i>maxlen</i> and croak if
<i>is_inout</i> is <i><small>TRUE</small></i> .</p>

<p style="margin-left:11%; margin-top: 1em">If your driver
<i>does</i> support <tt>&quot;bind_param_inout()&quot;</tt>
then you should note that <i>value</i> is the
<tt>&quot;SV&quot;</tt> <i>after</i> dereferencing the
reference passed to
<tt>&quot;bind_param_inout()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In drivers of
simple databases the function will, for example, store the
value in a parameter array and use it later in
<tt>&quot;dbd_st_execute()&quot;</tt>. See the
<b>DBD::mysql</b> driver for an example.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Implementing
bind_param_inout support</i></p>

<p style="margin-left:11%; margin-top: 1em">To provide
support for parameters bound by reference rather than by
value, the driver must do a number of things. First, and
most importantly, it must note the references and stash them
in its own driver structure. Secondly, when a value is bound
to a column, the driver must discard any previous reference
bound to the column. On each execute, the driver must
evaluate the references and internally bind the values
resulting from the references. This is only applicable if
the user writes:</p>

<pre style="margin-left:11%; margin-top: 1em">  $sth&minus;&gt;execute;</pre>


<p style="margin-left:11%; margin-top: 1em">If the user
writes:</p>

<pre style="margin-left:11%; margin-top: 1em">  $sth&minus;&gt;execute(@values);</pre>


<p style="margin-left:11%; margin-top: 1em">then
<b><small>DBI</small></b> automatically calls the binding
code for each element of <i>@values</i>. These calls are
indistinguishable from explicit user calls to
<tt>&quot;bind_param()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>C/XS version
of Makefile.PL</b> <br>
The <i>Makefile.PL</i> file for a C/XS driver is similar to
the code needed for a pure Perl driver, but there are a
number of extra bits of information needed by the build
system.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the attributes list passed to
<tt>&quot;WriteMakefile()&quot;</tt> needs to specify the
object files that need to be compiled and built into the
shared object ( <small>DLL</small> ). This is often, but not
necessarily, just <i>dbdimp.o</i> (unless that should be
<i>dbdimp.obj</i> because you&rsquo;re building on
<small>MS</small> Windows).</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
can reliably determine the extension of the object files
from the <i>$Config{obj_ext}</i> values, and there are many
other useful pieces of configuration information lurking in
that hash. You get access to it with:</p>

<pre style="margin-left:11%; margin-top: 1em">    use Config;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Methods
which do not need to be written</b> <br>
The <b><small>DBI</small></b> code implements the majority
of the methods which are accessed using the notation
<tt>&quot;DBI&minus;&gt;function()&quot;</tt>, the only
exceptions being
<tt>&quot;DBI&minus;&gt;connect()&quot;</tt> and
<tt>&quot;DBI&minus;&gt;data_sources()&quot;</tt> which
require support from the driver.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>DBI</small></b> code implements the following
documented driver, database and statement functions which do
not need to be written by the <b><small>DBD</small></b>
driver writer. <br>
$dbh&minus;&gt;<i>do()</i></p>

<p style="margin-left:17%;">The default implementation of
this function prepares, executes and destroys the statement.
This can be replaced if there is a better way to implement
this, such as <tt>&quot;EXECUTE IMMEDIATE&quot;</tt> which
can sometimes be used if there are no parameters.</p>

<p style="margin-left:11%;">$h&minus;&gt;<i>errstr()</i>
<br>
$h&minus;&gt;<i>err()</i> <br>
$h&minus;&gt;<i>state()</i> <br>
$h&minus;&gt;<i>trace()</i></p>

<p style="margin-left:17%;">The <b><small>DBD</small></b>
driver does not need to worry about these routines at
all.</p>

<p style="margin-left:11%;">$h&minus;&gt;{ChopBlanks}</p>

<p style="margin-left:17%;">This attribute needs to be
honored during <tt>&quot;fetch()&quot;</tt> operations, but
does not need to be handled by the attribute handling
code.</p>

<p style="margin-left:11%;">$h&minus;&gt;{RaiseError}</p>

<p style="margin-left:17%;">The <b><small>DBD</small></b>
driver does not need to worry about this attribute at
all.</p>

<p style="margin-left:11%;">$h&minus;&gt;{PrintError}</p>

<p style="margin-left:17%;">The <b><small>DBD</small></b>
driver does not need to worry about this attribute at
all.</p>


<p style="margin-left:11%;">$sth&minus;&gt;<i>bind_col()</i></p>

<p style="margin-left:17%;">Assuming the driver uses the
<tt>&quot;DBIc_DBISTATE(imp_xxh)&minus;&gt;get_fbav()&quot;</tt>
function (C drivers, see below), or the
<tt>&quot;$sth&minus;&gt;_set_fbav($data)&quot;</tt> method
(Perl drivers) the driver does not need to do anything about
this routine.</p>


<p style="margin-left:11%;">$sth&minus;&gt;<i>bind_columns()</i></p>

<p style="margin-left:17%;">Regardless of whether the
driver uses
<tt>&quot;DBIc_DBISTATE(imp_xxh)&minus;&gt;get_fbav()&quot;</tt>,
the driver does not need to do anything about this routine
as it simply iteratively calls
<tt>&quot;$sth&minus;&gt;bind_col()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>DBI</small></b> code implements a default
implementation of the following functions which do not need
to be written by the <b><small>DBD</small></b> driver writer
unless the default implementation is incorrect for the
Driver. <br>
$dbh&minus;&gt;<i>quote()</i></p>

<p style="margin-left:17%;">This should only be written if
the database does not accept the <small>ANSI SQL</small>
standard for quoting strings, with the string enclosed in
single quotes and any embedded single quotes replaced by two
consecutive single quotes.</p>

<p style="margin-left:17%; margin-top: 1em">For the two
argument form of quote, you need to implement the
<tt>&quot;type_info()&quot;</tt> method to provide the
information that quote needs.</p>


<p style="margin-left:11%;">$dbh&minus;&gt;<i>ping()</i></p>

<p style="margin-left:17%;">This should be implemented as a
simple efficient way to determine whether the connection to
the database is still alive. Typically code like this:</p>

<pre style="margin-left:17%; margin-top: 1em">  sub ping {
      my $dbh = shift;
      $sth = $dbh&minus;&gt;prepare_cached(q{
          select * from A_TABLE_NAME where 1=0
      }) or return 0;
      $sth&minus;&gt;execute or return 0;
      $sth&minus;&gt;finish;
      return 1;
  }</pre>


<p style="margin-left:17%; margin-top: 1em">where
<i>A_TABLE_NAME</i> is the name of a table that always
exists (such as a database system catalogue).</p>


<p style="margin-left:11%;">$drh&minus;&gt;default_user</p>

<p style="margin-left:17%;">The default implementation of
default_user will get the database username and password
fields from <tt>$ENV{DBI_USER}</tt> and
<tt>$ENV{DBI_PASS}</tt>. You can override this method. It is
called as follows:</p>

<pre style="margin-left:17%; margin-top: 1em">  ($user, $pass) = $drh&minus;&gt;default_user($user, $pass, $attr)</pre>


<h2>METADATA METHODS
<a name="METADATA METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The exposition
above ignores the <b><small>DBI</small></b> MetaData
methods. The metadata methods are all associated with a
database handle.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
DBI::DBD::Metadata</b> <br>
The <b>DBI::DBD::Metadata</b> module is a good
semi-automatic way for the developer of a
<b><small>DBD</small></b> module to write the
<tt>&quot;get_info()&quot;</tt> and
<tt>&quot;type_info()&quot;</tt> functions quickly and
accurately.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Generating
the get_info method</i></p>

<p style="margin-left:11%; margin-top: 1em">Prior to
<b><small>DBI</small></b> v1.33, this existed as the method
<tt>&quot;write_getinfo_pm()&quot;</tt> in the
<b><small>DBI::DBD</small></b> module. From
<b><small>DBI</small></b> v1.33, it exists as the method
<tt>&quot;write_getinfo_pm()&quot;</tt> in the
<b>DBI::DBD::Metadata</b> module. This discussion assumes
you have <b><small>DBI</small></b> v1.33 or later.</p>

<p style="margin-left:11%; margin-top: 1em">You examine the
documentation for <tt>&quot;write_getinfo_pm()&quot;</tt>
using:</p>

<pre style="margin-left:11%; margin-top: 1em">    perldoc DBI::DBD::Metadata</pre>


<p style="margin-left:11%; margin-top: 1em">To use it, you
need a Perl <b><small>DBI</small></b> driver for your
database which implements the
<tt>&quot;get_info()&quot;</tt> method. In practice, this
means you need to install <b><small>DBD::ODBC</small></b> ,
an <small>ODBC</small> driver manager, and an
<small>ODBC</small> driver for your database.</p>

<p style="margin-left:11%; margin-top: 1em">With the
pre-requisites in place, you might type:</p>

<pre style="margin-left:11%; margin-top: 1em">    perl &minus;MDBI::DBD::Metadata &minus;we \
       &quot;write_getinfo_pm (qw{ dbi:ODBC:foo_db username password Driver })&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">The procedure
writes to standard output the code that should be added to
your <i>Driver.pm</i> file and the code that should be
written to <i>lib/DBD/Driver/GetInfo.pm</i>.</p>

<p style="margin-left:11%; margin-top: 1em">You should
review the output to ensure that it is sensible.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Generating
the type_info method</i></p>

<p style="margin-left:11%; margin-top: 1em">Given the idea
of the <tt>&quot;write_getinfo_pm()&quot;</tt> method, it
was not hard to devise a parallel method,
<tt>&quot;write_typeinfo_pm()&quot;</tt>, which does the
analogous job for the <b><small>DBI</small></b>
<tt>&quot;type_info_all()&quot;</tt> metadata method. The
<tt>&quot;write_typeinfo_pm()&quot;</tt> method was added to
<b><small>DBI</small></b> v1.33.</p>

<p style="margin-left:11%; margin-top: 1em">You examine the
documentation for <tt>&quot;write_typeinfo_pm()&quot;</tt>
using:</p>

<pre style="margin-left:11%; margin-top: 1em">    perldoc DBI::DBD::Metadata</pre>


<p style="margin-left:11%; margin-top: 1em">The setup is
exactly analogous to the mechanism described in
&quot;Generating the get_info method&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">With the
pre-requisites in place, you might type:</p>

<pre style="margin-left:11%; margin-top: 1em">    perl &minus;MDBI::DBD::Metadata &minus;we \
       &quot;write_typeinfo (qw{ dbi:ODBC:foo_db username password Driver })&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">The procedure
writes to standard output the code that should be added to
your <i>Driver.pm</i> file and the code that should be
written to <i>lib/DBD/Driver/TypeInfo.pm</i>.</p>

<p style="margin-left:11%; margin-top: 1em">You should
review the output to ensure that it is sensible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::get_info</b> <br>
If you use the <b>DBI::DBD::Metadata</b> module, then the
code you need is generated for you.</p>

<p style="margin-left:11%; margin-top: 1em">If you decide
not to use the <b>DBI::DBD::Metadata</b> module, you should
probably borrow the code from a driver that has done so (eg
<b>DBD::Informix</b> from version 1.05 onwards) and crib the
code from there, or look at the code that generates that
module and follow that. The method in <i>Driver.pm</i> will
be very simple; the method in
<i>lib/DBD/Driver/GetInfo.pm</i> is not very much more
complex unless your <small>DBMS</small> itself is much more
complex.</p>

<p style="margin-left:11%; margin-top: 1em">Note that some
of the <b><small>DBI</small></b> utility methods rely on
information from the <tt>&quot;get_info()&quot;</tt> method
to perform their operations correctly. See, for example, the
<tt>&quot;quote_identifier()&quot;</tt> and quote methods,
discussed below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::type_info_all</b> <br>
If you use the <tt>&quot;DBI::DBD::Metadata&quot;</tt>
module, then the code you need is generated for you.</p>

<p style="margin-left:11%; margin-top: 1em">If you decide
not to use the <tt>&quot;DBI::DBD::Metadata&quot;</tt>
module, you should probably borrow the code from a driver
that has done so (eg <tt>&quot;DBD::Informix&quot;</tt> from
version 1.05 onwards) and crib the code from there, or look
at the code that generates that module and follow that. The
method in <i>Driver.pm</i> will be very simple; the method
in <i>lib/DBD/Driver/TypeInfo.pm</i> is not very much more
complex unless your <small>DBMS</small> itself is much more
complex.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::type_info</b> <br>
The guidelines on writing this method are still not really
clear. No sample implementation is available.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::table_info</b></p>

<pre style="margin-left:11%;"> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::column_info</b></p>

<pre style="margin-left:11%;"> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::primary_key_info</b></p>

<pre style="margin-left:11%;"> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::primary_key</b></p>

<pre style="margin-left:11%;"> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::foreign_key_info</b></p>

<pre style="margin-left:11%;"> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::tables</b> <br>
This method generates an array of names in a format suitable
for being embedded in <small>SQL</small> statements in
places where a table name is expected.</p>

<p style="margin-left:11%; margin-top: 1em">If your
database hews close enough to the <small>SQL</small>
standard or if you have implemented an appropriate
<tt>&quot;table_info()&quot;</tt> function and and the
appropriate <tt>&quot;quote_identifier()&quot;</tt>
function, then the <b><small>DBI</small></b> default version
of this method will work for your driver too.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, you
have to write a function yourself, such as:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub tables
    {
        my($dbh, $cat, $sch, $tab, $typ) = @_;
        my(@res);
        my($sth) = $dbh&minus;&gt;table_info($cat, $sch, $tab, $typ);
        my(@arr);
        while (@arr = $sth&minus;&gt;fetchrow_array)
        {
            push @res, $dbh&minus;&gt;quote_identifier($arr[0], $arr[1], $arr[2]);
        }
        return @res;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">See also the
default implementation in <i><small>DBI</small> .pm</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::quote</b> <br>
This method takes a value and converts it into a string
suitable for embedding in an <small>SQL</small> statement as
a string literal.</p>

<p style="margin-left:11%; margin-top: 1em">If your
<small>DBMS</small> accepts the <small>SQL</small> standard
notation for strings (single quotes around the string as a
whole with any embedded single quotes doubled up), then you
do not need to write this method as
<b><small>DBI</small></b> provides a default method that
does it for you.</p>

<p style="margin-left:11%; margin-top: 1em">If your
<small>DBMS</small> uses an alternative notation or escape
mechanism, then you need to provide an equivalent function.
For example, suppose your <small>DBMS</small> used C
notation with double quotes around the string and
backslashes escaping both double quotes and backslashes
themselves. Then you might write the function as:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub quote
    {
        my($dbh, $str) = @_;
        $str =~ s/[&quot;\\]/\\$&amp;/gmo;
        return qq{&quot;$str&quot;};
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Handling
newlines and other control characters is left as an exercise
for the reader.</p>

<p style="margin-left:11%; margin-top: 1em">This sample
method ignores the <i>$data_type</i> indicator which is the
optional second argument to the method.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Writing
DBD::Driver::db::quote_identifier</b> <br>
This method is called to ensure that the name of the given
table (or other database object) can be embedded into an
<small>SQL</small> statement without danger of
misinterpretation. The result string should be usable in the
text of an <small>SQL</small> statement as the identifier
for a table.</p>

<p style="margin-left:11%; margin-top: 1em">If your
<small>DBMS</small> accepts the <small>SQL</small> standard
notation for quoted identifiers (which uses double quotes
around the identifier as a whole, with any embedded double
quotes doubled up) and accepts
<i>&quot;schema&quot;.&quot;identifier&quot;</i> (and
<i>&quot;catalog&quot;.&quot;schema&quot;.&quot;identifier&quot;</i>
when a catalog is specified), then you do not need to write
this method as <b><small>DBI</small></b> provides a default
method that does it for you.</p>

<p style="margin-left:11%; margin-top: 1em">In fact, even
if your <small>DBMS</small> does not handle exactly that
notation but you have implemented the
<tt>&quot;get_info()&quot;</tt> method and it gives the
correct responses, then it will work for you. If your
database is fussier, then you need to implement your own
version of the function.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
<b>DBD::Informix</b> has to deal with an environment
variable <i><small>DELIMIDENT</small></i> . If it is not
set, then the <small>DBMS</small> treats names enclosed in
double quotes as strings rather than names, which is usually
a syntax error. Additionally, the catalog portion of the
name is separated from the schema and table by a different
delimiter (colon instead of dot), and the catalog portion is
never enclosed in quotes. (Fortunately, valid strings for
the catalog will never contain weird characters that might
need to be escaped, unless you count dots, dashes, slashes
and at-signs as weird.) Finally, an Informix database can
contain objects that cannot be accessed because they were
created by a user with the <i><small>DELIMIDENT</small></i>
environment variable set, but the current user does not have
it set. By design choice, the
<tt>&quot;quote_identifier()&quot;</tt> method encloses
those identifiers in double quotes anyway, which generally
triggers a syntax error, and the metadata methods which
generate lists of tables etc omit those identifiers from the
result sets.</p>

<pre style="margin-left:11%; margin-top: 1em">    sub quote_identifier
    {
        my($dbh, $cat, $sch, $obj) = @_;
        my($rv) = &quot;&quot;;
        my($qq) = (defined $ENV{DELIMIDENT}) ? '&quot;' : '';
        $rv .= qq{$cat:} if (defined $cat);
        if (defined $sch)
        {
            if ($sch !~ m/^\w+$/o)
            {
                $qq = '&quot;';
                $sch =~ s/$qq/$qq$qq/gm;
            }
            $rv .= qq{$qq$sch$qq.};
        }
        if (defined $obj)
        {
            if ($obj !~ m/^\w+$/o)
            {
                $qq = '&quot;';
                $obj =~ s/$qq/$qq$qq/gm;
            }
            $rv .= qq{$qq$obj$qq};
        }
        return $rv;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Handling
newlines and other control characters is left as an exercise
for the reader.</p>

<p style="margin-left:11%; margin-top: 1em">Note that there
is an optional fourth parameter to this function which is a
reference to a hash of attributes; this sample
implementation ignores that.</p>

<p style="margin-left:11%; margin-top: 1em">This sample
implementation also ignores the single-argument variant of
the method.</p>

<h2>TRACING
<a name="TRACING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tracing in
<small>DBI</small> is controlled with a combination of a
trace level and a set of flags which together are known as
the trace settings. The trace settings are stored in a
single integer and divided into levels and flags by a set of
masks (<tt>&quot;DBIc_TRACE_LEVEL_MASK&quot;</tt> and
<tt>&quot;DBIc_TRACE_FLAGS_MASK&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">Each handle has
it&rsquo;s own trace settings and so does the
<small>DBI.</small> When you call a method the
<small>DBI</small> merges the handles settings into its own
for the duration of the call: the trace flags of the handle
are <small>OR</small> &rsquo;d into the trace flags of the
<small>DBI,</small> and if the handle has a higher trace
level then the <small>DBI</small> trace level is raised to
match it. The previous <small>DBI</small> trace settings are
restored when the called method returns.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Trace
Level</b> <br>
The trace level is the first 4 bits of the trace settings
(masked by <tt>&quot;DBIc_TRACE_FLAGS_MASK&quot;</tt>) and
represents trace levels of 1 to 15. Do not output anything
at trace levels less than 3 as they are reserved for
<small>DBI.</small></p>

<p style="margin-left:11%; margin-top: 1em">For advice on
what to output at each level see &quot;Trace Levels&quot; in
<small>DBI</small> .</p>

<p style="margin-left:11%; margin-top: 1em">To test for a
trace level you can use the
<tt>&quot;DBIc_TRACE_LEVEL&quot;</tt> macro like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  if (DBIc_TRACE_LEVEL(imp_xxh) &gt;= 2) {
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), &quot;foobar&quot;);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Also
<b>note</b> the use of PerlIO_printf which you should always
use for tracing and never the C <tt>&quot;stdio.h&quot;</tt>
I/O functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Trace
Flags</b> <br>
Trace flags are used to enable tracing of specific
activities within the <small>DBI</small> and drivers. The
<small>DBI</small> defines some trace flags and drivers can
define others. <small>DBI</small> trace flag names begin
with a capital letter and driver specific names begin with a
lowercase letter. For a list of <small>DBI</small> defined
trace flags see &quot;Trace Flags&quot; in
<small>DBI</small> .</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
use private trace flags you&rsquo;ll probably want to be
able to set them by name. Drivers are expected to override
the parse_trace_flag (note the singular) and check if
<tt>$trace_flag_name</tt> is a driver specific trace flags
and, if not, then call the DBIs default
<i>parse_trace_flag()</i>. To do that you&rsquo;ll need to
define a <i>parse_trace_flag()</i> method like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub parse_trace_flag {
      my ($h, $name) = @_;
      return 0x01000000 if $name eq 'foo';
      return 0x02000000 if $name eq 'bar';
      return 0x04000000 if $name eq 'baz';
      return 0x08000000 if $name eq 'boo';
      return 0x10000000 if $name eq 'bop';
      return $h&minus;&gt;SUPER::parse_trace_flag($name);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">All private
flag names must be lowercase, and all private flags must be
in the top 8 of the 32 bits of
<tt>&quot;DBIc_TRACE_FLAGS(imp)&quot;</tt> i.e.,
0xFF000000.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;ve
defined a <i>parse_trace_flag()</i> method in ::db
you&rsquo;ll also want it in ::st, so just alias it in:</p>

<pre style="margin-left:11%; margin-top: 1em">  *parse_trace_flag = \&amp;DBD::foo:db::parse_trace_flag;</pre>


<p style="margin-left:11%; margin-top: 1em">You may want to
act on the current &rsquo; <small>SQL</small> &rsquo; trace
flag that <small>DBI</small> defines to output
<small>SQL</small> prepared/executed as <small>DBI</small>
currently does not do <small>SQL</small> tracing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Trace
Macros</b> <br>
Access to the trace level and trace flags is via a set of
macros.</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIc_TRACE_SETTINGS(imp) returns the trace settings
  DBIc_TRACE_LEVEL(imp) returns the trace level
  DBIc_TRACE_FLAGS(imp) returns the trace flags
  DBIc_TRACE(imp, flags, flaglevel, level)
  e.g.,
  DBIc_TRACE(imp, 0, 0, 4)
    if level &gt;= 4
  DBIc_TRACE(imp, DBDtf_FOO, 2, 4)
    if tracing DBDtf_FOO &amp; level&gt;=2 or level&gt;=4
  DBIc_TRACE(imp, DBDtf_FOO, 2, 0)
    as above but never trace just due to level</pre>


<h2>WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE

<a name="WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Study
<i>Oraperl.pm</i> (supplied with <b>DBD::Oracle</b>) and
<i>Ingperl.pm</i> (supplied with <b>DBD::Ingres</b>) and the
corresponding <i>dbdimp.c</i> files for ideas.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
emulation code sets <tt>&quot;$dbh&minus;&gt;{CompatMode} =
1;&quot;</tt> for each connection so that the internals of
the driver can implement behaviour compatible with the old
interface when dealing with those handles.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Setting
emulation perl variables</b> <br>
For example, ingperl has a <i>$sql_rowcount</i> variable.
Rather than try to manually update this in <i>Ingperl.pm</i>
it can be done faster in C code. In
<tt>&quot;dbd_init()&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">  sql_rowcount = perl_get_sv(&quot;Ingperl::sql_rowcount&quot;, GV_ADDMULTI);</pre>


<p style="margin-left:11%; margin-top: 1em">In the relevant
places do:</p>

<pre style="margin-left:11%; margin-top: 1em">  if (DBIc_COMPAT(imp_sth))     /* only do this for compatibility mode handles */
      sv_setiv(sql_rowcount, the_row_count);</pre>


<h2>OTHER MISCELLANEOUS INFORMATION
<a name="OTHER MISCELLANEOUS INFORMATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>The
imp_xyz_t types</b> <br>
Any handle has a corresponding C structure filled with
private data. Some of this data is reserved for use by
<b><small>DBI</small></b> (except for using the DBIc macros
below), some is for you. See the description of the
<i>dbdimp.h</i> file above for examples. Most functions in
<i>dbdimp.c</i> are passed both the handle
<tt>&quot;xyz&quot;</tt> and a pointer to
<tt>&quot;imp_xyz&quot;</tt>. In rare cases, however, you
may use the following macros: <br>
D_imp_dbh(dbh)</p>

<p style="margin-left:17%;">Given a function argument
<i>dbh</i>, declare a variable <i>imp_dbh</i> and initialize
it with a pointer to the handles private data. Note: This
must be a part of the function header, because it declares a
variable.</p>

<p style="margin-left:11%;">D_imp_sth(sth)</p>

<p style="margin-left:17%;">Likewise for statement
handles.</p>

<p style="margin-left:11%;">D_imp_xxx(h)</p>

<p style="margin-left:17%;">Given any handle, declare a
variable <i>imp_xxx</i> and initialize it with a pointer to
the handles private data. It is safe, for example, to cast
<i>imp_xxx</i> to <tt>&quot;imp_dbh_t*&quot;</tt>, if
<tt>&quot;DBIc_TYPE(imp_xxx) == DBIt_DB&quot;</tt>. (You can
also call <tt>&quot;sv_derived_from(h,
&quot;DBI::db&quot;)&quot;</tt>, but that&rsquo;s much
slower.)</p>

<p style="margin-left:11%;">D_imp_dbh_from_sth</p>

<p style="margin-left:17%;">Given a <i>imp_sth</i>, declare
a variable <i>imp_dbh</i> and initialize it with a pointer
to the parent database handle&rsquo;s implementors
structure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
DBIc_IMPSET_on</b> <br>
The driver code which initializes a handle should use
<tt>&quot;DBIc_IMPSET_on()&quot;</tt> as soon as its state
is such that the cleanup code must be called. When this
happens is determined by your driver code.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Failure to
call this can lead to corruption of data structures.</b></p>

<p style="margin-left:11%; margin-top: 1em">For example,
<b>DBD::Informix</b> maintains a linked list of database
handles in the driver, and within each handle, a linked list
of statements. Once a statement is added to the linked list,
it is crucial that it is cleaned up (removed from the list).
When <i>DBIc_IMPSET_on()</i> was being called too late, it
was able to cause all sorts of problems.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using</b>
<i>DBIc_is()</i><b>,</b> <i>DBIc_has()</i><b>,</b>
<i>DBIc_on()</i> <b>and</b> <i>DBIc_off()</i> <br>
Once upon a long time ago, the only way of handling the
internal <b><small>DBI</small></b> boolean flags/attributes
was through macros such as:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIc_WARN       DBIc_WARN_on        DBIc_WARN_off
  DBIc_COMPAT     DBIc_COMPAT_on      DBIc_COMPAT_off</pre>


<p style="margin-left:11%; margin-top: 1em">Each of these
took an <i>imp_xxh</i> pointer as an argument.</p>

<p style="margin-left:11%; margin-top: 1em">Since then, new
attributes have been added such as <i>ChopBlanks</i>,
<i>RaiseError</i> and <i>PrintError</i>, and these do not
have the full set of macros. The approved method for
handling these is now the four macros:</p>

<pre style="margin-left:11%; margin-top: 1em">  DBIc_is(imp, flag)
  DBIc_has(imp, flag)       an alias for DBIc_is
  DBIc_on(imp, flag)
  DBIc_off(imp, flag)
  DBIc_set(imp, flag, on)   set if on is true, else clear</pre>


<p style="margin-left:11%; margin-top: 1em">Consequently,
the <tt>&quot;DBIc_XXXXX&quot;</tt> family of macros is now
mostly deprecated and new drivers should avoid using them,
even though the older drivers will probably continue to do
so for quite a while yet. However...</p>

<p style="margin-left:11%; margin-top: 1em">There is an
<i>important exception</i> to that. The
<i><small>ACTIVE</small></i> and
<i><small>IMPSET</small></i> flags should be set via the
<tt>&quot;DBIc_ACTIVE_on()&quot;</tt> and
<tt>&quot;DBIc_IMPSET_on()&quot;</tt> macros, and unset via
the <tt>&quot;DBIc_ACTIVE_off()&quot;</tt> and
<tt>&quot;DBIc_IMPSET_off()&quot;</tt> macros.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
the</b> <i>get_fbav()</i> <b>method <small><br>
THIS IS CRITICAL</small> for C/XS drivers</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;$sth&minus;&gt;bind_col()&quot;</tt> and
<tt>&quot;$sth&minus;&gt;bind_columns()&quot;</tt>
documented in the <b><small>DBI</small></b> specification do
not have to be implemented by the driver writer because
<b><small>DBI</small></b> takes care of the details for
you.</p>

<p style="margin-left:11%; margin-top: 1em">However, the
key to ensuring that bound columns work is to call the
function
<tt>&quot;DBIc_DBISTATE(imp_xxh)&minus;&gt;get_fbav()&quot;</tt>
in the code which fetches a row of data.</p>

<p style="margin-left:11%; margin-top: 1em">This returns an
<tt>&quot;AV&quot;</tt>, and each element of the
<tt>&quot;AV&quot;</tt> contains the <tt>&quot;SV&quot;</tt>
which should be set to contain the returned data.</p>

<p style="margin-left:11%; margin-top: 1em">The pure Perl
equivalent is the
<tt>&quot;$sth&minus;&gt;_set_fbav($data)&quot;</tt> method,
as described in the part on pure Perl drivers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Casting
strings to Perl types based on a <small>SQL</small> type</b>
<small><br>
DBI</small> from 1.611 (and <small>DBIXS_REVISION
13606</small> ) defines the sql_type_cast_svpv method which
may be used to cast a string representation of a value to a
more specific Perl type based on a <small>SQL</small> type.
You should consider using this method when processing bound
column data as it provides some support for the
<small>TYPE</small> bind_col attribute which is rarely used
in drivers.</p>

<pre style="margin-left:11%; margin-top: 1em">  int sql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)</pre>


<p style="margin-left:11%; margin-top: 1em">&quot;sv&quot;
is what you would like cast, <tt>&quot;sql_type&quot;</tt>
is one of the <small>DBI</small> defined <small>SQL</small>
types (e.g., <tt>&quot;SQL_INTEGER&quot;</tt>) and
<tt>&quot;flags&quot;</tt> is a bitmask as follows: <br>
DBIstcf_STRICT</p>

<p style="margin-left:17%;">If set this indicates you want
an error state returned if the cast cannot be performed.</p>

<p style="margin-left:11%;">DBIstcf_DISCARD_STRING</p>

<p style="margin-left:17%;">If set and the pv portion of
the <tt>&quot;sv&quot;</tt> is cast then this will cause
sv&rsquo;s pv to be freed up.</p>


<p style="margin-left:11%; margin-top: 1em">sql_type_cast_svpv
returns the following states:</p>

<pre style="margin-left:11%; margin-top: 1em"> &minus;2 sql_type is not handled &minus; sv not changed
 &minus;1 sv is undef, sv not changed
  0 sv could not be cast cleanly and DBIstcf_STRICT was specified
  1 sv could not be case cleanly and DBIstcf_STRICT was not specified
  2 sv was cast ok</pre>


<p style="margin-left:11%; margin-top: 1em">The current
implementation of sql_type_cast_svpv supports
<tt>&quot;SQL_INTEGER&quot;</tt>,
<tt>&quot;SQL_DOUBLE&quot;</tt> and
<tt>&quot;SQL_NUMERIC&quot;</tt>.
<tt>&quot;SQL_INTEGER&quot;</tt> uses sv_2iv and hence may
set <small>IV, UV</small> or <small>NV</small> depending on
the number. <tt>&quot;SQL_DOUBLE&quot;</tt> uses sv_2nv so
may set <small>NV</small> and
<tt>&quot;SQL_NUMERIC&quot;</tt> will set <small>IV</small>
or <small>UV</small> or <small>NV.</small></p>

<p style="margin-left:11%; margin-top: 1em">DBIstcf_STRICT
should be implemented as the StrictlyTyped attribute and
DBIstcf_DISCARD_STRING implemented as the DiscardString
attribute to the bind_col method and both default to
off.</p>

<p style="margin-left:11%; margin-top: 1em">See DBD::Oracle
for an example of how this is used.</p>

<h2>SUBCLASSING DBI DRIVERS
<a name="SUBCLASSING DBI DRIVERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is
definitely an open subject. It can be done, as demonstrated
by the <b>DBD::File</b> driver, but it is not as simple as
one might think.</p>

<p style="margin-left:11%; margin-top: 1em">(Note that this
topic is different from subclassing the
<b><small>DBI</small></b> . For an example of that, see the
<i>t/subclass.t</i> file supplied with the
<b><small>DBI</small></b> .)</p>

<p style="margin-left:11%; margin-top: 1em">The main
problem is that the <i>dbh</i>&rsquo;s and
<i>sth</i>&rsquo;s that your <tt>&quot;connect()&quot;</tt>
and <tt>&quot;prepare()&quot;</tt> methods return are not
instances of your <b>DBD::Driver::db</b> or
<b>DBD::Driver::st</b> packages, they are not even derived
from it. Instead they are instances of the <b>DBI::db</b> or
<b>DBI::st</b> classes or a derived subclass. Thus, if you
write a method <tt>&quot;mymethod()&quot;</tt> and do a</p>

<pre style="margin-left:11%; margin-top: 1em">  $dbh&minus;&gt;mymethod()</pre>


<p style="margin-left:11%; margin-top: 1em">then the
autoloader will search for that method in the package
<b>DBI::db</b>. Of course you can instead to a</p>

<pre style="margin-left:11%; margin-top: 1em">  $dbh&minus;&gt;func('mymethod')</pre>


<p style="margin-left:11%; margin-top: 1em">and that will
indeed work, even if <tt>&quot;mymethod()&quot;</tt> is
inherited, but not without additional work. Setting
<i>@ISA</i> is not sufficient.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Overwriting
methods</b> <br>
The first problem is, that the
<tt>&quot;connect()&quot;</tt> method has no idea of
subclasses. For example, you cannot implement base class and
subclass in the same file: The
<tt>&quot;install_driver()&quot;</tt> method wants to do
a</p>

<pre style="margin-left:11%; margin-top: 1em">  require DBD::Driver;</pre>


<p style="margin-left:11%; margin-top: 1em">In particular,
your subclass <b>has</b> to be a separate driver, from the
view of <b><small>DBI</small></b> , and you cannot share
driver handles.</p>

<p style="margin-left:11%; margin-top: 1em">Of course
that&rsquo;s not much of a problem. You should even be able
to inherit the base classes <tt>&quot;connect()&quot;</tt>
method. But you cannot simply overwrite the method, unless
you do something like this, quoted from
<b><small>DBD::CSV</small></b> :</p>

<pre style="margin-left:11%; margin-top: 1em">  sub connect ($$;$$$) {
      my ($drh, $dbname, $user, $auth, $attr) = @_;
      my $this = $drh&minus;&gt;DBD::File::dr::connect($dbname, $user, $auth, $attr);
      if (!exists($this&minus;&gt;{csv_tables})) {
          $this&minus;&gt;{csv_tables} = {};
      }
      $this;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Note that we
cannot do a</p>

<pre style="margin-left:11%; margin-top: 1em">  $drh&minus;&gt;SUPER::connect($dbname, $user, $auth, $attr);</pre>


<p style="margin-left:11%; margin-top: 1em">as we would
usually do in a an <small>OO</small> environment, because
<i>$drh</i> is an instance of <b>DBI::dr</b>. And note, that
the <tt>&quot;connect()&quot;</tt> method of
<b>DBD::File</b> is able to handle subclass attributes. See
the description of Pure Perl drivers above.</p>

<p style="margin-left:11%; margin-top: 1em">It is essential
that you always call superclass method in the above manner.
However, that should do.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Attribute
handling</b> <br>
Fortunately the <b><small>DBI</small></b> specifications
allow a simple, but still performant way of handling
attributes. The idea is based on the convention that any
driver uses a prefix <i>driver_</i> for its private methods.
Thus it&rsquo;s always clear whether to pass attributes to
the super class or not. For example, consider this
<tt>&quot;STORE()&quot;</tt> method from the
<b><small>DBD::CSV</small></b> class:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub STORE {
      my ($dbh, $attr, $val) = @_;
      if ($attr !~ /^driver_/) {
          return $dbh&minus;&gt;DBD::File::db::STORE($attr, $val);
      }
      if ($attr eq 'driver_foo') {
      ...
  }</pre>


<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Jonathan
Leffler &lt;jleffler@us.ibm.com&gt; (previously
&lt;jleffler@informix.com&gt;), Jochen Wiedmann
&lt;joe@ispsoft.de&gt;, Steffen Goeldner
&lt;sgoeldner@cpan.org&gt;, and Tim Bunce
&lt;dbi&minus;users@perl.org&gt;.</p>
<hr>
</body>
</html>
