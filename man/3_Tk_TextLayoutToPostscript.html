<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:04:56 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Tk_ComputeTextLayout</title>

</head>
<body>

<h1 align="center">Tk_ComputeTextLayout</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#DISPLAY MODEL">DISPLAY MODEL</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tk_ComputeTextLayout,
Tk_FreeTextLayout, Tk_DrawTextLayout,
Tk_UnderlineTextLayout, Tk_PointToChar, Tk_CharBbox,
Tk_DistanceToTextLayout, Tk_IntersectTextLayout,
Tk_TextLayoutToPostscript &minus; routines to measure and
display single-font, multi-line, justified text.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tk.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">Tk_TextLayout
<b><br>
Tk_ComputeTextLayout(</b><i>tkfont, string, numChars,
wrapLength, justify, flags, widthPtr,
heightPtr</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tk_FreeTextLayout(</b><i>layout</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tk_DrawTextLayout(</b><i>display, drawable, gc, layout, x,
y, firstChar, lastChar</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tk_UnderlineTextLayout(</b><i>display, drawable, gc, layout,
x, y, underline</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tk_PointToChar(</b><i>layout, x, y</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tk_CharBbox(</b><i>layout, index, xPtr, yPtr, widthPtr,
heightPtr</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tk_DistanceToTextLayout(</b><i>layout, x, y</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tk_IntersectTextLayout(</b><i>layout, x, y, width,
height</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tk_TextLayoutToPostscript(</b><i>interp,
layout</i><b>)</b></p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p style="margin-top: 1em">Tk_Font <i>tkfont</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p style="margin-top: 1em">Font to use when constructing
and displaying a text layout. The <i>tkfont</i> must remain
valid for the lifetime of the text layout. Must have been
returned by a previous call to <b>Tk_GetFont</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>const char <i>*string</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Potentially multi-line string whose dimensions are to be
computed and stored in the text layout. The <i>string</i>
must remain valid for the lifetime of the text layout.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>numChars</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>The number of characters to consider from <i>string</i>.
If <i>numChars</i> is less than 0, then assumes
<i>string</i> is null terminated and uses
<b>Tcl_NumUtfChars</b> to determine the length of
<i>string</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>wrapLength</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Longest permissible line length, in pixels. Lines in
<i>string</i> will automatically be broken at word
boundaries and wrapped when they reach this length. If
<i>wrapLength</i> is too small for even a single character
to fit on a line, it will be expanded to allow one character
to fit on each line. If <i>wrapLength</i> is &lt;= 0, there
is no automatic wrapping; lines will get as long as they
need to be and only wrap if a newline/return character is
encountered.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>Tk_Justify <i>justify</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>How to justify the lines in a multi-line text layout.
Possible values are <b>TK_JUSTIFY_LEFT</b>,
<b>TK_JUSTIFY_CENTER</b>, or <b>TK_JUSTIFY_RIGHT</b>. If the
text layout only occupies a single line, then <i>justify</i>
is irrelevant.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>flags</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Various flag bits OR-ed together. <b>TK_IGNORE_TABS</b>
means that tab characters should not be expanded to the next
tab stop. <b>TK_IGNORE_NEWLINES</b> means that
newline/return characters should not cause a line break. If
either tabs or newlines/returns are ignored, then they will
be treated as regular characters, being measured and
displayed in a platform-dependent manner as described in
<b>Tk_MeasureChars</b>, and will not have any special
behaviors.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>*widthPtr</i> (out)</p></td>
<td width="25%"></td>
<td width="26%">


<p>If non-NULL, filled with either the width, in pixels, of
the widest line in the text layout, or the width, in pixels,
of the bounding box for the character specified by
<i>index</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>*heightPtr</i> (out)</p></td>
<td width="25%"></td>
<td width="26%">


<p>If non-NULL, filled with either the total height, in
pixels, of all the lines in the text layout, or the height,
in pixels, of the bounding box for the character specified
by <i>index</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>Tk_TextLayout <i>layout</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>A token that represents the cached layout information
about the single-font, multi-line, justified piece of text.
This token is returned by <b>Tk_ComputeTextLayout</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>Display <i>*display</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Display on which to draw.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>Drawable <i>drawable</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Window or pixmap in which to draw.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>GC <i>gc</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Graphics context to use for drawing text layout. The
font selected in this GC must correspond to the
<i>tkfont</i> used when constructing the text layout.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>x, y</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Point, in pixels, at which to place the upper-left hand
corner of the text layout when it is being drawn, or the
coordinates of a point (with respect to the upper-left hand
corner of the text layout) to check against the text
layout.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>firstChar</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>The index of the first character to draw from the given
text layout. The number 0 means to draw from the
beginning.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>lastChar</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>The index of the last character up to which to draw. The
character specified by <i>lastChar</i> itself will not be
drawn. A number less than 0 means to draw all characters in
the text layout.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>underline</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Index of the single character to underline in the text
layout, or a number less than 0 for no underline.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>index</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>The index of the character whose bounding box is
desired. The bounding box is computed with respect to the
upper-left hand corner of the text layout.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>*xPtr, *yPtr</i> (out)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Filled with the upper-left hand corner, in pixels, of
the bounding box for the character specified by
<i>index</i>. Either or both <i>xPtr</i> and <i>yPtr</i> may
be NULL, in which case the corresponding value is not
calculated.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>width, height</i> (in)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Specifies the width and height, in pixels, of the
rectangular area to compare for intersection against the
text layout.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>Tcl_Interp <i>*interp</i> (out)</p></td>
<td width="25%"></td>
<td width="26%">


<p>Postscript code that will print the text layout is
appended to <i>interp-&gt;result</i>.</p></td></tr>
</table>


<p style="margin-left:74%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These routines
are for measuring and displaying single-font, multi-line,
justified text. To measure and display simple single-font,
single-line strings, refer to the documentation for
<b>Tk_MeasureChars</b>. There is no programming interface in
the core of Tk that supports multi-font, multi-line text;
support for that behavior must be built on top of simpler
layers. Note that unlike the lower level text display
routines, the functions described here all operate on
character-oriented lengths and indices rather than
byte-oriented values. See the description of
<b>Tcl_UtfAtIndex</b> for more details on converting between
character and byte offsets.</p>

<p style="margin-left:11%; margin-top: 1em">The routines
described here are built on top of the programming interface
described in the <b>Tk_MeasureChars</b> documentation. Tab
characters and newline/return characters may be treated
specially by these procedures, but all other characters are
passed through to the lower level.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tk_ComputeTextLayout</b>
computes the layout information needed to display a
single-font, multi-line, justified <i>string</i> of text and
returns a Tk_TextLayout token that holds this information.
This token is used in subsequent calls to procedures such as
<b>Tk_DrawTextLayout</b>, <b>Tk_DistanceToTextLayout</b>,
and <b>Tk_FreeTextLayout</b>. The <i>string</i> and
<i>tkfont</i> used when computing the layout must remain
valid for the lifetime of this token.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tk_FreeTextLayout</b>
is called to release the storage associated with
<i>layout</i> when it is no longer needed. A <i>layout</i>
should not be used in any other text layout procedures once
it has been released.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tk_DrawTextLayout</b>
uses the information in <i>layout</i> to display a
single-font, multi-line, justified string of text at the
specified location.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tk_UnderlineTextLayout</b>
uses the information in <i>layout</i> to display an
underline below an individual character. This procedure does
not draw the text, just the underline. To produce natively
underlined text, an underlined font should be constructed
and used. All characters, including tabs, newline/return
characters, and spaces at the ends of lines, can be
underlined using this method. However, the underline will
never be drawn outside of the computed width of
<i>layout</i>; the underline will stop at the edge for any
character that would extend partially outside of
<i>layout</i>, and the underline will not be visible at all
for any character that would be located completely outside
of the layout.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tk_PointToChar</b>
uses the information in <i>layout</i> to determine the
character closest to the given point. The point is specified
with respect to the upper-left hand corner of the
<i>layout</i>, which is considered to be located at (0, 0).
Any point whose <i>y</i>-value is less that 0 will be
considered closest to the first character in the text
layout; any point whose <i>y</i>-value is greater than the
height of the text layout will be considered closest to the
last character in the text layout. Any point whose
<i>x</i>-value is less than 0 will be considered closest to
the first character on that line; any point whose
<i>x</i>-value is greater than the width of the text layout
will be considered closest to the last character on that
line. The return value is the index of the character that
was closest to the point. Given a <i>layout</i> with no
characters, the value 0 will always be returned, referring
to a hypothetical zero-width placeholder character.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tk_CharBbox</b>
uses the information in <i>layout</i> to return the bounding
box for the character specified by <i>index</i>. The width
of the bounding box is the advance width of the character,
and does not include any left or right bearing. Any
character that extends partially outside of <i>layout</i> is
considered to be truncated at the edge. Any character that
would be located completely outside of <i>layout</i> is
considered to be zero-width and pegged against the edge. The
height of the bounding box is the line height for this font,
extending from the top of the ascent to the bottom of the
descent; information about the actual height of individual
letters is not available. For measurement purposes, a
<i>layout</i> that contains no characters is considered to
contain a single zero-width placeholder character at index
0. If <i>index</i> was not a valid character index, the
return value is 0 and <i>*xPtr</i>, <i>*yPtr</i>,
<i>*widthPtr</i>, and <i>*heightPtr</i> are unmodified.
Otherwise, if <i>index</i> did specify a valid, the return
value is non-zero, and <i>*xPtr</i>, <i>*yPtr</i>,
<i>*widthPtr</i>, and <i>*heightPtr</i> are filled with the
bounding box information for the character. If any of
<i>xPtr</i>, <i>yPtr</i>, <i>widthPtr</i>, or
<i>heightPtr</i> are NULL, the corresponding value is not
calculated or stored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tk_DistanceToTextLayout</b>
computes the shortest distance in pixels from the given
point (<i>x, y</i>) to the characters in <i>layout</i>.
Newline/return characters and non-displaying space
characters that occur at the end of individual lines in the
text layout are ignored for hit detection purposes, but tab
characters are not. The return value is 0 if the point
actually hits the <i>layout</i>. If the point did not hit
the <i>layout</i> then the return value is the distance in
pixels from the point to the <i>layout</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tk_IntersectTextLayout</b>
determines whether a <i>layout</i> lies entirely inside,
entirely outside, or overlaps a given rectangle.
Newline/return characters and non-displaying space
characters that occur at the end of individual lines in the
<i>layout</i> are ignored for intersection calculations. The
return value is &minus;1 if the <i>layout</i> is entirely
outside of the rectangle, 0 if it overlaps, and 1 if it is
entirely inside of the rectangle.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tk_TextLayoutToPostscript</b>
outputs code consisting of a Postscript array of strings
that represent the individual lines in <i>layout</i>. It is
the responsibility of the caller to take the Postscript
array of strings and add some Postscript function operate on
the array to render each of the lines. The code that
represents the Postscript array of strings is appended to
<i>interp-&gt;result</i>.</p>

<h2>DISPLAY MODEL
<a name="DISPLAY MODEL"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When measuring
a text layout, space characters that occur at the end of a
line are ignored. The space characters still exist and the
insertion point can be positioned amongst them, but their
additional width is ignored when justifying lines or
returning the total width of a text layout. All end-of-line
space characters are considered to be attached to the right
edge of the line; this behavior is logical for
left-justified text and reasonable for center-justified
text, but not very useful when editing right-justified text.
Spaces are considered variable width characters; the first
space that extends past the edge of the text layout is
clipped to the edge, and any subsequent spaces on the line
are considered zero width and pegged against the edge. Space
characters that occur in the middle of a line of text are
not suppressed and occupy their normal space width.</p>

<p style="margin-left:11%; margin-top: 1em">Tab characters
are not ignored for measurement calculations. If wrapping is
turned on and there are enough tabs on a line, the next tab
will wrap to the beginning of the next line. There are some
possible strange interactions between tabs and
justification; tab positions are calculated and the line
length computed in a left-justified world, and then the
whole resulting line is shifted so it is centered or
right-justified, causing the tab columns not to align any
more.</p>

<p style="margin-left:11%; margin-top: 1em">When wrapping
is turned on, lines may wrap at word breaks (space or tab
characters) or newline/returns. A dash or hyphen character
in the middle of a word is not considered a word break.
<b>Tk_ComputeTextLayout</b> always attempts to place at
least one word on each line. If it cannot because the
<i>wrapLength</i> is too small, the word will be broken and
as much as fits placed on the line and the rest on
subsequent line(s). If <i>wrapLength</i> is so small that
not even one character can fit on a given line, the
<i>wrapLength</i> is ignored for that line and one character
will be placed on the line anyhow. When wrapping is turned
off, only newline/return characters may cause a line
break.</p>

<p style="margin-left:11%; margin-top: 1em">When a text
layout has been created using an underlined <i>tkfont</i>,
then any space characters that occur at the end of
individual lines, newlines/returns, and tabs will not be
displayed underlined when <b>Tk_DrawTextLayout</b> is
called, because those characters are never actually drawn
&minus; they are merely placeholders maintained in the
<i>layout</i>.</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>

 
<p style="margin-left:11%; margin-top: 1em">font</p>
<hr>
</body>
</html>
