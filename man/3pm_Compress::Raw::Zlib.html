<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Tue Aug  2 15:31:48 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Compress::Raw::Zlib</title>

</head>
<body>

<h1 align="center">Compress::Raw::Zlib</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Compress::Raw::Zlib::Deflate">Compress::Raw::Zlib::Deflate</a><br>
<a href="#Compress::Raw::Zlib::Inflate">Compress::Raw::Zlib::Inflate</a><br>
<a href="#CHECKSUM FUNCTIONS">CHECKSUM FUNCTIONS</a><br>
<a href="#Misc">Misc</a><br>
<a href="#The LimitOutput option.">The LimitOutput option.</a><br>
<a href="#ACCESSING ZIP FILES">ACCESSING ZIP FILES</a><br>
<a href="#FAQ">FAQ</a><br>
<a href="#CONSTANTS">CONSTANTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#MODIFICATION HISTORY">MODIFICATION HISTORY</a><br>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Compress::Raw::Zlib
&minus; Low&minus;Level Interface to zlib compression
library</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use Compress::Raw::Zlib ;
    ($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) ;
    $status = $d&minus;&gt;deflate($input, $output) ;
    $status = $d&minus;&gt;flush($output [, $flush_type]) ;
    $d&minus;&gt;deflateReset() ;
    $d&minus;&gt;deflateParams(OPTS) ;
    $d&minus;&gt;deflateTune(OPTS) ;
    $d&minus;&gt;dict_adler() ;
    $d&minus;&gt;crc32() ;
    $d&minus;&gt;adler32() ;
    $d&minus;&gt;total_in() ;
    $d&minus;&gt;total_out() ;
    $d&minus;&gt;msg() ;
    $d&minus;&gt;get_Strategy();
    $d&minus;&gt;get_Level();
    $d&minus;&gt;get_BufSize();
    ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) ;
    $status = $i&minus;&gt;inflate($input, $output [, $eof]) ;
    $status = $i&minus;&gt;inflateSync($input) ;
    $i&minus;&gt;inflateReset() ;
    $i&minus;&gt;dict_adler() ;
    $d&minus;&gt;crc32() ;
    $d&minus;&gt;adler32() ;
    $i&minus;&gt;total_in() ;
    $i&minus;&gt;total_out() ;
    $i&minus;&gt;msg() ;
    $d&minus;&gt;get_BufSize();
    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;
    $crc = adler32_combine($crc1, $crc2, $len2)l
    $crc = crc32_combine($adler1, $adler2, $len2)
    my $version = Compress::Raw::Zlib::zlib_version();
    my $flags = Compress::Raw::Zlib::zlibCompileFlags();</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>Compress::Raw::Zlib</i> module provides a Perl interface
to the <i>zlib</i> compression library (see &quot;
<small>AUTHOR&quot;</small> for details about where to get
<i>zlib</i>).</p>

<h2>Compress::Raw::Zlib::Deflate
<a name="Compress::Raw::Zlib::Deflate"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
defines an interface that allows in-memory compression using
the <i>deflate</i> interface provided by zlib.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
definition of the interface available:</p>

<p style="margin-left:11%; margin-top: 1em"><b>($d,
$status) = new Compress::Raw::Zlib::Deflate( [
<small>OPT</small> ] )</b> <br>
Initialises a deflation object.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
familiar with the <i>zlib</i> library, it combines the
features of the <i>zlib</i> functions
<tt>&quot;deflateInit&quot;</tt>,
<tt>&quot;deflateInit2&quot;</tt> and
<tt>&quot;deflateSetDictionary&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If successful,
it will return the initialised deflation object, <tt>$d</tt>
and a <tt>$status</tt> of <tt>&quot;Z_OK&quot;</tt> in a
list context. In scalar context it returns the deflation
object, <tt>$d</tt>, only.</p>

<p style="margin-left:11%; margin-top: 1em">If not
successful, the returned deflation object, <tt>$d</tt>, will
be <i>undef</i> and <tt>$status</tt> will hold the a
<i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">The function
optionally takes a number of named options specified as
<tt>&quot;Name =&gt; value&quot;</tt> pairs. This allows
individual options to be tailored without having to specify
them all in the parameter list.</p>

<p style="margin-left:11%; margin-top: 1em">For backward
compatibility, it is also possible to pass the parameters as
a reference to a hash containing the name=&gt;value
pairs.</p>

<p style="margin-left:11%; margin-top: 1em">Below is a list
of the valid options: <b><br>
&minus;Level</b></p>

<p style="margin-left:18%;">Defines the compression level.
Valid values are 0 through 9,
<tt>&quot;Z_NO_COMPRESSION&quot;</tt>,
<tt>&quot;Z_BEST_SPEED&quot;</tt>,
<tt>&quot;Z_BEST_COMPRESSION&quot;</tt>, and
<tt>&quot;Z_DEFAULT_COMPRESSION&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
<tt>&quot;Z_DEFAULT_COMPRESSION&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;Method</b></p>

<p style="margin-left:18%;">Defines the compression method.
The only valid value at present (and the default) is
<tt>&quot;Z_DEFLATED&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;WindowBits</b></p>

<p style="margin-left:18%;">To compress an <small>RFC
1950</small> data stream, set
<tt>&quot;WindowBits&quot;</tt> to a positive number between
8 and 15.</p>

<p style="margin-left:18%; margin-top: 1em">To compress an
<small>RFC 1951</small> data stream, set
<tt>&quot;WindowBits&quot;</tt> to
<tt>&quot;&minus;MAX_WBITS&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">To compress an
<small>RFC 1952</small> data stream (i.e. gzip), set
<tt>&quot;WindowBits&quot;</tt> to
<tt>&quot;WANT_GZIP&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">For a
definition of the meaning and valid values for
<tt>&quot;WindowBits&quot;</tt> refer to the <i>zlib</i>
documentation for <i>deflateInit2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<tt>&quot;MAX_WBITS&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;MemLevel</b></p>

<p style="margin-left:18%;">For a definition of the meaning
and valid values for <tt>&quot;MemLevel&quot;</tt> refer to
the <i>zlib</i> documentation for <i>deflateInit2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<small>MAX_MEM_LEVEL.</small></p>

<p style="margin-left:11%;"><b>&minus;Strategy</b></p>

<p style="margin-left:18%;">Defines the strategy used to
tune the compression. The valid values are
<tt>&quot;Z_DEFAULT_STRATEGY&quot;</tt>,
<tt>&quot;Z_FILTERED&quot;</tt>, <tt>&quot;Z_RLE&quot;</tt>,
<tt>&quot;Z_FIXED&quot;</tt> and
<tt>&quot;Z_HUFFMAN_ONLY&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
<tt>&quot;Z_DEFAULT_STRATEGY&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;Dictionary</b></p>

<p style="margin-left:18%;">When a dictionary is specified
<i>Compress::Raw::Zlib</i> will automatically call
<tt>&quot;deflateSetDictionary&quot;</tt> directly after
calling <tt>&quot;deflateInit&quot;</tt>. The Adler32 value
for the dictionary can be obtained by calling the method
<tt>&quot;$d&minus;&gt;dict_adler()&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
no dictionary.</p>

<p style="margin-left:11%;"><b>&minus;Bufsize</b></p>

<p style="margin-left:18%;">Sets the initial size for the
output buffer used by the
<tt>&quot;$d&minus;&gt;deflate&quot;</tt> and
<tt>&quot;$d&minus;&gt;flush&quot;</tt> methods. If the
buffer has to be reallocated to increase the size, it will
grow in increments of <tt>&quot;Bufsize&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">The default
buffer size is 4096.</p>

<p style="margin-left:11%;"><b>&minus;AppendOutput</b></p>

<p style="margin-left:18%;">This option controls how data
is written to the output buffer by the
<tt>&quot;$d&minus;&gt;deflate&quot;</tt> and
<tt>&quot;$d&minus;&gt;flush&quot;</tt> methods.</p>

<p style="margin-left:18%; margin-top: 1em">If the
<tt>&quot;AppendOutput&quot;</tt> option is set to false,
the output buffers in the
<tt>&quot;$d&minus;&gt;deflate&quot;</tt> and
<tt>&quot;$d&minus;&gt;flush&quot;</tt> methods will be
truncated before uncompressed data is written to them.</p>

<p style="margin-left:18%; margin-top: 1em">If the option
is set to true, uncompressed data will be appended to the
output buffer in the
<tt>&quot;$d&minus;&gt;deflate&quot;</tt> and
<tt>&quot;$d&minus;&gt;flush&quot;</tt> methods.</p>

<p style="margin-left:18%; margin-top: 1em">This option
defaults to false.</p>

<p style="margin-left:11%;"><b>&minus;CRC32</b></p>

<p style="margin-left:18%;">If set to true, a crc32
checksum of the uncompressed data will be calculated. Use
the <tt>&quot;$d&minus;&gt;crc32&quot;</tt> method to
retrieve this value.</p>

<p style="margin-left:18%; margin-top: 1em">This option
defaults to false.</p>

<p style="margin-left:11%;"><b>&minus;ADLER32</b></p>

<p style="margin-left:18%;">If set to true, an adler32
checksum of the uncompressed data will be calculated. Use
the <tt>&quot;$d&minus;&gt;adler32&quot;</tt> method to
retrieve this value.</p>

<p style="margin-left:18%; margin-top: 1em">This option
defaults to false.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of using the
<tt>&quot;Compress::Raw::Zlib::Deflate&quot;</tt> optional
parameter list to override the default buffer size and
compression level. All other options will take their default
values.</p>

<pre style="margin-left:11%; margin-top: 1em">    my $d = new Compress::Raw::Zlib::Deflate ( &minus;Bufsize =&gt; 300,
                                               &minus;Level   =&gt; Z_BEST_SPEED ) ;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>$status =
$d&minus;&gt;deflate($input, $output)</b> <br>
Deflates the contents of <tt>$input</tt> and writes the
compressed data to <tt>$output</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$input</tt> and <tt>$output</tt> parameters can be
either scalars or scalar references.</p>

<p style="margin-left:11%; margin-top: 1em">When finished,
<tt>$input</tt> will be completely processed (assuming there
were no errors). If the deflation was successful it writes
the deflated data to <tt>$output</tt> and returns a status
value of <tt>&quot;Z_OK&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">On error, it
returns a <i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>&quot;AppendOutput&quot;</tt> option is set to true in
the constructor for the <tt>$d</tt> object, the compressed
data will be appended to <tt>$output</tt>. If it is false,
<tt>$output</tt> will be truncated before any compressed
data is written to it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note</b>:
This method will not necessarily write compressed data to
<tt>$output</tt> every time it is called. So do not assume
that there has been an error if the contents of
<tt>$output</tt> is empty on returning from this method. As
long as the return code from the method is
<tt>&quot;Z_OK&quot;</tt>, the deflate has succeeded.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$d&minus;&gt;flush($output [, $flush_type])</b> <br>
Typically used to finish the deflation. Any pending output
will be written to <tt>$output</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Returns
<tt>&quot;Z_OK&quot;</tt> if successful.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using
<tt>&quot;Z_FINISH&quot;</tt>) or when you want to create a
<i>full flush point</i> (using
<tt>&quot;Z_FULL_FLUSH&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">By default the
<tt>&quot;flush_type&quot;</tt> used is
<tt>&quot;Z_FINISH&quot;</tt>. Other valid values for
<tt>&quot;flush_type&quot;</tt> are
<tt>&quot;Z_NO_FLUSH&quot;</tt>,
<tt>&quot;Z_PARTIAL_FLUSH&quot;</tt>,
<tt>&quot;Z_SYNC_FLUSH&quot;</tt> and
<tt>&quot;Z_FULL_FLUSH&quot;</tt>. It is strongly
recommended that you only set the
<tt>&quot;flush_type&quot;</tt> parameter if you fully
understand the implications of what it does. See the
<tt>&quot;zlib&quot;</tt> documentation for details.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>&quot;AppendOutput&quot;</tt> option is set to true in
the constructor for the <tt>$d</tt> object, the compressed
data will be appended to <tt>$output</tt>. If it is false,
<tt>$output</tt> will be truncated before any compressed
data is written to it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$d&minus;&gt;</b><b><i>deflateReset()</i></b> <br>
This method will reset the deflation object <tt>$d</tt>. It
can be used when you are compressing multiple data streams
and want to use the same object to compress each of them. It
should only be used once the previous data stream has been
flushed successfully, i.e. a call to
<tt>&quot;$d&minus;&gt;flush(Z_FINISH)&quot;</tt> has
returned <tt>&quot;Z_OK&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Returns
<tt>&quot;Z_OK&quot;</tt> if successful.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$d&minus;&gt;deflateParams([ <small>OPT</small> ])</b> <br>
Change settings for the deflate object <tt>$d</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The list of the
valid options is shown below. Options not specified will
remain unchanged. <b><br>
&minus;Level</b></p>

<p style="margin-left:18%;">Defines the compression level.
Valid values are 0 through 9,
<tt>&quot;Z_NO_COMPRESSION&quot;</tt>,
<tt>&quot;Z_BEST_SPEED&quot;</tt>,
<tt>&quot;Z_BEST_COMPRESSION&quot;</tt>, and
<tt>&quot;Z_DEFAULT_COMPRESSION&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;Strategy</b></p>

<p style="margin-left:18%;">Defines the strategy used to
tune the compression. The valid values are
<tt>&quot;Z_DEFAULT_STRATEGY&quot;</tt>,
<tt>&quot;Z_FILTERED&quot;</tt> and
<tt>&quot;Z_HUFFMAN_ONLY&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;BufSize</b></p>

<p style="margin-left:18%;">Sets the initial size for the
output buffer used by the
<tt>&quot;$d&minus;&gt;deflate&quot;</tt> and
<tt>&quot;$d&minus;&gt;flush&quot;</tt> methods. If the
buffer has to be reallocated to increase the size, it will
grow in increments of <tt>&quot;Bufsize&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$d&minus;&gt;deflateTune($good_length, $max_lazy,
$nice_length, $max_chain)</b> <br>
Tune the internal settings for the deflate object
<tt>$d</tt>. This option is only available if you are
running zlib 1.2.2.3 or better.</p>

<p style="margin-left:11%; margin-top: 1em">Refer to the
documentation in zlib.h for instructions on how to fly
<tt>&quot;deflateTune&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>dict_adler()</i></b>
<br>
Returns the adler32 value for the dictionary.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>crc32()</i></b>
<br>
Returns the crc32 value for the uncompressed data to
date.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>&quot;CRC32&quot;</tt> option is not enabled in the
constructor for this object, this method will always return
0;</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>adler32()</i></b>
<br>
Returns the adler32 value for the uncompressed data to
date.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>msg()</i></b>
<br>
Returns the last error message generated by zlib.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>total_in()</i></b>
<br>
Returns the total number of bytes uncompressed bytes input
to deflate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>total_out()</i></b>
<br>
Returns the total number of compressed bytes output from
deflate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>get_Strategy()</i></b>
<br>
Returns the deflation strategy currently used. Valid values
are <tt>&quot;Z_DEFAULT_STRATEGY&quot;</tt>,
<tt>&quot;Z_FILTERED&quot;</tt> and
<tt>&quot;Z_HUFFMAN_ONLY&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>get_Level()</i></b>
<br>
Returns the compression level being used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>get_BufSize()</i></b>
<br>
Returns the buffer size used to carry out the
compression.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example</b>
<br>
Here is a trivial example of using
<tt>&quot;deflate&quot;</tt>. It simply reads standard
input, deflates it and writes it to standard output.</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Raw::Zlib ;
    binmode STDIN;
    binmode STDOUT;
    my $x = new Compress::Raw::Zlib::Deflate
       or die &quot;Cannot create a deflation stream\n&quot; ;
    my ($output, $status) ;
    while (&lt;&gt;)
    {
        $status = $x&minus;&gt;deflate($_, $output) ;
        $status == Z_OK
            or die &quot;deflation failed\n&quot; ;
        print $output ;
    }
    $status = $x&minus;&gt;flush($output) ;
    $status == Z_OK
        or die &quot;deflation failed\n&quot; ;
    print $output ;</pre>


<h2>Compress::Raw::Zlib::Inflate
<a name="Compress::Raw::Zlib::Inflate"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
defines an interface that allows in-memory uncompression
using the <i>inflate</i> interface provided by zlib.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
definition of the interface:</p>

<p style="margin-left:11%; margin-top: 1em"><b>($i,
$status) = new Compress::Raw::Zlib::Inflate( [
<small>OPT</small> ] )</b> <br>
Initialises an inflation object.</p>

<p style="margin-left:11%; margin-top: 1em">In a list
context it returns the inflation object, <tt>$i</tt>, and
the <i>zlib</i> status code (<tt>$status</tt>). In a scalar
context it returns the inflation object only.</p>

<p style="margin-left:11%; margin-top: 1em">If successful,
<tt>$i</tt> will hold the inflation object and
<tt>$status</tt> will be <tt>&quot;Z_OK&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If not
successful, <tt>$i</tt> will be <i>undef</i> and
<tt>$status</tt> will hold the <i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">The function
optionally takes a number of named options specified as
<tt>&quot;&minus;Name =&gt; value&quot;</tt> pairs. This
allows individual options to be tailored without having to
specify them all in the parameter list.</p>

<p style="margin-left:11%; margin-top: 1em">For backward
compatibility, it is also possible to pass the parameters as
a reference to a hash containing the
<tt>&quot;name=&gt;value&quot;</tt> pairs.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a list
of the valid options: <b><br>
&minus;WindowBits</b></p>

<p style="margin-left:18%;">To uncompress an <small>RFC
1950</small> data stream, set
<tt>&quot;WindowBits&quot;</tt> to a positive number between
8 and 15.</p>

<p style="margin-left:18%; margin-top: 1em">To uncompress
an <small>RFC 1951</small> data stream, set
<tt>&quot;WindowBits&quot;</tt> to
<tt>&quot;&minus;MAX_WBITS&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">To uncompress
an <small>RFC 1952</small> data stream (i.e. gzip), set
<tt>&quot;WindowBits&quot;</tt> to
<tt>&quot;WANT_GZIP&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">To auto-detect
and uncompress an <small>RFC 1950</small> or <small>RFC
1952</small> data stream (i.e. gzip), set
<tt>&quot;WindowBits&quot;</tt> to
<tt>&quot;WANT_GZIP_OR_ZLIB&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">For a full
definition of the meaning and valid values for
<tt>&quot;WindowBits&quot;</tt> refer to the <i>zlib</i>
documentation for <i>inflateInit2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<tt>&quot;MAX_WBITS&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;Bufsize</b></p>

<p style="margin-left:18%;">Sets the initial size for the
output buffer used by the
<tt>&quot;$i&minus;&gt;inflate&quot;</tt> method. If the
output buffer in this method has to be reallocated to
increase the size, it will grow in increments of
<tt>&quot;Bufsize&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">Default is
4096.</p>

<p style="margin-left:11%;"><b>&minus;Dictionary</b></p>

<p style="margin-left:18%;">The default is no
dictionary.</p>

<p style="margin-left:11%;"><b>&minus;AppendOutput</b></p>

<p style="margin-left:18%;">This option controls how data
is written to the output buffer by the
<tt>&quot;$i&minus;&gt;inflate&quot;</tt> method.</p>

<p style="margin-left:18%; margin-top: 1em">If the option
is set to false, the output buffer in the
<tt>&quot;$i&minus;&gt;inflate&quot;</tt> method will be
truncated before uncompressed data is written to it.</p>

<p style="margin-left:18%; margin-top: 1em">If the option
is set to true, uncompressed data will be appended to the
output buffer by the
<tt>&quot;$i&minus;&gt;inflate&quot;</tt> method.</p>

<p style="margin-left:18%; margin-top: 1em">This option
defaults to false.</p>

<p style="margin-left:11%;"><b>&minus;CRC32</b></p>

<p style="margin-left:18%;">If set to true, a crc32
checksum of the uncompressed data will be calculated. Use
the <tt>&quot;$i&minus;&gt;crc32&quot;</tt> method to
retrieve this value.</p>

<p style="margin-left:18%; margin-top: 1em">This option
defaults to false.</p>

<p style="margin-left:11%;"><b>&minus;ADLER32</b></p>

<p style="margin-left:18%;">If set to true, an adler32
checksum of the uncompressed data will be calculated. Use
the <tt>&quot;$i&minus;&gt;adler32&quot;</tt> method to
retrieve this value.</p>

<p style="margin-left:18%; margin-top: 1em">This option
defaults to false.</p>

<p style="margin-left:11%;"><b>&minus;ConsumeInput</b></p>

<p style="margin-left:18%;">If set to true, this option
will remove compressed data from the input buffer of the
<tt>&quot;$i&minus;&gt;inflate&quot;</tt> method as the
inflate progresses.</p>

<p style="margin-left:18%; margin-top: 1em">This option can
be useful when you are processing compressed data that is
embedded in another file/buffer. In this case the data that
immediately follows the compressed stream will be left in
the input buffer.</p>

<p style="margin-left:18%; margin-top: 1em">This option
defaults to true.</p>

<p style="margin-left:11%;"><b>&minus;LimitOutput</b></p>

<p style="margin-left:18%;">The
<tt>&quot;LimitOutput&quot;</tt> option changes the behavior
of the <tt>&quot;$i&minus;&gt;inflate&quot;</tt> method so
that the amount of memory used by the output buffer can be
limited.</p>

<p style="margin-left:18%; margin-top: 1em">When
<tt>&quot;LimitOutput&quot;</tt> is used the size of the
output buffer used will either be the value of the
<tt>&quot;Bufsize&quot;</tt> option or the amount of memory
already allocated to <tt>$output</tt>, whichever is larger.
Predicting the output size available is tricky, so
don&rsquo;t rely on getting an exact output buffer size.</p>

<p style="margin-left:18%; margin-top: 1em">When
<tt>&quot;LimitOutout&quot;</tt> is not specified
<tt>&quot;$i&minus;&gt;inflate&quot;</tt> will use as much
memory as it takes to write all the uncompressed data it
creates by uncompressing the input buffer.</p>

<p style="margin-left:18%; margin-top: 1em">If
<tt>&quot;LimitOutput&quot;</tt> is enabled, the
<tt>&quot;ConsumeInput&quot;</tt> option will also be
enabled.</p>

<p style="margin-left:18%; margin-top: 1em">This option
defaults to false.</p>

<p style="margin-left:18%; margin-top: 1em">See &quot;The
LimitOutput option&quot; for a discussion on why
<tt>&quot;LimitOutput&quot;</tt> is needed and how to use
it.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of using an optional parameter to override the
default buffer size.</p>

<pre style="margin-left:11%; margin-top: 1em">    my ($i, $status) = new Compress::Raw::Zlib::Inflate( &minus;Bufsize =&gt; 300 ) ;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>$status =
$i&minus;&gt;inflate($input, $output [,$eof])</b> <br>
Inflates the complete contents of <tt>$input</tt> and writes
the uncompressed data to <tt>$output</tt>. The
<tt>$input</tt> and <tt>$output</tt> parameters can either
be scalars or scalar references.</p>

<p style="margin-left:11%; margin-top: 1em">Returns
<tt>&quot;Z_OK&quot;</tt> if successful and
<tt>&quot;Z_STREAM_END&quot;</tt> if the end of the
compressed data has been successfully reached.</p>

<p style="margin-left:11%; margin-top: 1em">If not
successful <tt>$status</tt> will hold the <i>zlib</i> error
code.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>&quot;ConsumeInput&quot;</tt> option has been set to
true when the
<tt>&quot;Compress::Raw::Zlib::Inflate&quot;</tt> object is
created, the <tt>$input</tt> parameter is modified by
<tt>&quot;inflate&quot;</tt>. On completion it will contain
what remains of the input buffer after inflation. In
practice, this means that when the return status is
<tt>&quot;Z_OK&quot;</tt> the <tt>$input</tt> parameter will
contain an empty string, and when the return status is
<tt>&quot;Z_STREAM_END&quot;</tt> the <tt>$input</tt>
parameter will contains what (if anything) was stored in the
input buffer after the deflated data stream.</p>

<p style="margin-left:11%; margin-top: 1em">This feature is
useful when processing a file format that encapsulates a
compressed data stream (e.g. gzip, zip) and there is useful
data immediately after the deflation stream.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>&quot;AppendOutput&quot;</tt> option is set to true in
the constructor for this object, the uncompressed data will
be appended to <tt>$output</tt>. If it is false,
<tt>$output</tt> will be truncated before any uncompressed
data is written to it.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$eof</tt> parameter needs a bit of explanation.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to
version 1.2.0, zlib assumed that there was at least one
trailing byte immediately after the compressed data stream
when it was carrying out decompression. This normally
isn&rsquo;t a problem because the majority of zlib
applications guarantee that there will be data directly
after the compressed data stream. For example, both gzip (
<small>RFC 1950</small> ) and zip both define trailing data
that follows the compressed data stream.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$eof</tt> parameter only needs to be used if <b>all</b>
of the following conditions apply</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="4%"></td>
<td width="82%">


<p>You are either using a copy of zlib that is older than
version 1.2.0 or you want your application code to be able
to run with as many different versions of zlib as
possible.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>You have set the <tt>&quot;WindowBits&quot;</tt>
parameter to <tt>&quot;&minus;MAX_WBITS&quot;</tt> in the
constructor for this object, i.e. you are uncompressing a
raw deflated data stream ( <small>RFC 1951</small> ).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="4%"></td>
<td width="82%">


<p>There is no data immediately after the compressed data
stream.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If <b>all</b>
of these are the case, then you need to set the
<tt>$eof</tt> parameter to true on the final call (and only
the final call) to
<tt>&quot;$i&minus;&gt;inflate&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If you have
built this module with zlib &gt;= 1.2.0, the <tt>$eof</tt>
parameter is ignored. You can still set it if you want, but
it won&rsquo;t be used behind the scenes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$i&minus;&gt;inflateSync($input)</b> <br>
This method can be used to attempt to recover good data from
a compressed data stream that is partially corrupt. It scans
<tt>$input</tt> until it reaches either a <i>full flush
point</i> or the end of the buffer.</p>

<p style="margin-left:11%; margin-top: 1em">If a <i>full
flush point</i> is found, <tt>&quot;Z_OK&quot;</tt> is
returned and <tt>$input</tt> will be have all data up to the
flush point removed. This data can then be passed to the
<tt>&quot;$i&minus;&gt;inflate&quot;</tt> method to be
uncompressed.</p>

<p style="margin-left:11%; margin-top: 1em">Any other
return code means that a flush point was not found. If more
data is available, <tt>&quot;inflateSync&quot;</tt> can be
called repeatedly with more compressed data until the flush
point is found.</p>

<p style="margin-left:11%; margin-top: 1em">Note <i>full
flush points</i> are not present by default in compressed
data streams. They must have been added explicitly when the
data stream was created by calling
<tt>&quot;Compress::Deflate::flush&quot;</tt> with
<tt>&quot;Z_FULL_FLUSH&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$i&minus;&gt;</b><b><i>inflateReset()</i></b> <br>
This method will reset the inflation object <tt>$i</tt>. It
can be used when you are uncompressing multiple data streams
and want to use the same object to uncompress each of
them.</p>

<p style="margin-left:11%; margin-top: 1em">Returns
<tt>&quot;Z_OK&quot;</tt> if successful.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>dict_adler()</i></b>
<br>
Returns the adler32 value for the dictionary.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>crc32()</i></b>
<br>
Returns the crc32 value for the uncompressed data to
date.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>&quot;CRC32&quot;</tt> option is not enabled in the
constructor for this object, this method will always return
0;</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>adler32()</i></b>
<br>
Returns the adler32 value for the uncompressed data to
date.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>&quot;ADLER32&quot;</tt> option is not enabled in the
constructor for this object, this method will always return
0;</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>msg()</i></b>
<br>
Returns the last error message generated by zlib.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>total_in()</i></b>
<br>
Returns the total number of bytes compressed bytes input to
inflate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>total_out()</i></b>
<br>
Returns the total number of uncompressed bytes output from
inflate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>get_BufSize()</i></b>
<br>
Returns the buffer size used to carry out the
decompression.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Examples</b>
<br>
Here is an example of using
<tt>&quot;inflate&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Raw::Zlib;
    my $x = new Compress::Raw::Zlib::Inflate()
       or die &quot;Cannot create a inflation stream\n&quot; ;
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x&minus;&gt;inflate($input, $output) ;
        print $output ;
        last if $status != Z_OK ;
    }
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;</pre>


<p style="margin-left:11%; margin-top: 1em">The next
example show how to use the <tt>&quot;LimitOutput&quot;</tt>
option. Notice the use of two nested loops in this case. The
outer loop reads the data from the input source &minus;
<small>STDIN</small> and the inner loop repeatedly calls
<tt>&quot;inflate&quot;</tt> until <tt>$input</tt> is
exhausted, we get an error, or the end of the stream is
reached. One point worth remembering is by using the
<tt>&quot;LimitOutput&quot;</tt> option you also get
<tt>&quot;ConsumeInput&quot;</tt> set as well &minus; this
makes the code below much simpler.</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Raw::Zlib;
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)
       or die &quot;Cannot create a inflation stream\n&quot; ;
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    my ($output, $status) ;
  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x&minus;&gt;inflate($input, $output) ;
            print $output ;
            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK &amp;&amp; length $input);
    }
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;</pre>


<h2>CHECKSUM FUNCTIONS
<a name="CHECKSUM FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Two functions
are provided by <i>zlib</i> to calculate checksums. For the
Perl interface, the order of the two parameters in both
functions has been reversed. This allows both running
checksums and one off calculations to be done.</p>

<pre style="margin-left:11%; margin-top: 1em">    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;</pre>


<p style="margin-left:11%; margin-top: 1em">The buffer
parameters can either be a scalar or a scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>$crc</tt> parameters is <tt>&quot;undef&quot;</tt>, the
crc value will be reset.</p>

<p style="margin-left:11%; margin-top: 1em">If you have
built this module with zlib 1.2.3 or better, two more
CRC-related functions are available.</p>

<pre style="margin-left:11%; margin-top: 1em">    $crc = adler32_combine($crc1, $crc2, $len2)l
    $crc = crc32_combine($adler1, $adler2, $len2)</pre>


<p style="margin-left:11%; margin-top: 1em">These functions
allow checksums to be merged.</p>

<h2>Misc
<a name="Misc"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>my $version
=</b> <i>Compress::Raw::Zlib::zlib_version()</i><b>;</b>
<br>
Returns the version of the zlib library.</p>

<p style="margin-left:11%; margin-top: 1em"><b>my $flags
=</b> <i>Compress::Raw::Zlib::zlibCompileFlags()</i><b>;</b>
<br>
Returns the flags indicating compile-time options that were
used to build the zlib library. See the zlib documentation
for a description of the flags returned by
<tt>&quot;zlibCompileFlags&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that when
the zlib sources are built along with this module the
<tt>&quot;sprintf&quot;</tt> flags (bits 24, 25 and 26)
should be ignored.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
using zlib 1.2.0 or older,
<tt>&quot;zlibCompileFlags&quot;</tt> will return 0.</p>

<h2>The LimitOutput option.
<a name="The LimitOutput option."></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">By default
<tt>&quot;$i&minus;&gt;inflate($input, $output)&quot;</tt>
will uncompress <i>all</i> data in <tt>$input</tt> and write
<i>all</i> of the uncompressed data it has generated to
<tt>$output</tt>. This makes the interface to
<tt>&quot;inflate&quot;</tt> much simpler &minus; if the
method has uncompressed <tt>$input</tt> successfully
<i>all</i> compressed data in <tt>$input</tt> will have been
dealt with. So if you are reading from an input source and
uncompressing as you go the code will look something like
this</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Raw::Zlib;
    my $x = new Compress::Raw::Zlib::Inflate()
       or die &quot;Cannot create a inflation stream\n&quot; ;
    my $input = '' ;
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x&minus;&gt;inflate($input, $output) ;
        print $output ;
        last if $status != Z_OK ;
    }
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;</pre>


<p style="margin-left:11%; margin-top: 1em">The points to
note are</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">The main processing loop in the
code handles reading of compressed data from
<small>STDIN.</small></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>The status code returned from
<tt>&quot;inflate&quot;</tt> will only trigger termination
of the main processing loop if it isn&rsquo;t
<tt>&quot;Z_OK&quot;</tt>. When
<tt>&quot;LimitOutput&quot;</tt> has not been used the
<tt>&quot;Z_OK&quot;</tt> status means means that the end of
the compressed data stream has been reached or there has
been an error in uncompression.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>After the call to <tt>&quot;inflate&quot;</tt>
<i>all</i> of the uncompressed data in <tt>$input</tt> will
have been processed. This means the subsequent call to
<tt>&quot;read&quot;</tt> can overwrite it&rsquo;s contents
without any problem.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">For most
use-cases the behavior described above is acceptable (this
module and it&rsquo;s predecessor,
<tt>&quot;Compress::Zlib&quot;</tt>, have used it for over
10 years without an issue), but in a few very specific
use-cases the amount of memory required for <tt>$output</tt>
can prohibitively large. For example, if the compressed data
stream contains the same pattern repeated thousands of
times, a relatively small compressed data stream can
uncompress into hundreds of megabytes. Remember
<tt>&quot;inflate&quot;</tt> will keep allocating memory
until <i>all</i> the uncompressed data has been written to
the output buffer &minus; the size of <tt>$output</tt> is
unbounded.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;LimitOutput&quot;</tt> option is designed to help
with this use-case.</p>

<p style="margin-left:11%; margin-top: 1em">The main
difference in your code when using
<tt>&quot;LimitOutput&quot;</tt> is having to deal with
cases where the <tt>$input</tt> parameter still contains
some uncompressed data that <tt>&quot;inflate&quot;</tt>
hasn&rsquo;t processed yet. The status code returned from
<tt>&quot;inflate&quot;</tt> will be
<tt>&quot;Z_OK&quot;</tt> if uncompression took place and
<tt>&quot;Z_BUF_ERROR&quot;</tt> if the output buffer is
full.</p>

<p style="margin-left:11%; margin-top: 1em">Below is
typical code that shows how to use
<tt>&quot;LimitOutput&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Raw::Zlib;
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)
       or die &quot;Cannot create a inflation stream\n&quot; ;
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    my ($output, $status) ;
  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x&minus;&gt;inflate($input, $output) ;
            print $output ;
            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK &amp;&amp; length $input);
    }
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;</pre>


<p style="margin-left:11%; margin-top: 1em">Points to note
this time:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">There are now two nested loops
in the code: the outer loop for reading the compressed data
from <small>STDIN,</small> as before; and the inner loop to
carry out the uncompression.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>There are two exit points from the inner uncompression
loop.</p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Firstly when
<tt>&quot;inflate&quot;</tt> has returned a status other
than <tt>&quot;Z_OK&quot;</tt> or
<tt>&quot;Z_BUF_ERROR&quot;</tt>. This means that either the
end of the compressed data stream has been reached
(<tt>&quot;Z_STREAM_END&quot;</tt>) or there is an error in
the compressed data. In either of these cases there is no
point in continuing with reading the compressed data, so
both loops are terminated.</p>

<p style="margin-left:18%; margin-top: 1em">The second exit
point tests if there is any data left in the input buffer,
<tt>$input</tt> &minus; remember that the
<tt>&quot;ConsumeInput&quot;</tt> option is automatically
enabled when <tt>&quot;LimitOutput&quot;</tt> is used. When
the input buffer has been exhausted, the outer loop can run
again and overwrite a now empty <tt>$input</tt>.</p>

<h2>ACCESSING ZIP FILES
<a name="ACCESSING ZIP FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Although it is
possible (with some effort on your part) to use this module
to access .zip files, there are other perl modules available
that will do all the hard work for you. Check out
<tt>&quot;Archive::Zip&quot;</tt>,
<tt>&quot;Archive::Zip::SimpleZip&quot;</tt>,
<tt>&quot;IO::Compress::Zip&quot;</tt> and
<tt>&quot;IO::Uncompress::Unzip&quot;</tt>.</p>

<h2>FAQ
<a name="FAQ"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Compatibility
with Unix compress/uncompress.</b> <br>
This module is not compatible with Unix
<tt>&quot;compress&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If you have the
<tt>&quot;uncompress&quot;</tt> program available, you can
use this to read compressed files</p>

<pre style="margin-left:11%; margin-top: 1em">    open F, &quot;uncompress &minus;c $filename |&quot;;
    while (&lt;F&gt;)
    {
        ...</pre>


<p style="margin-left:11%; margin-top: 1em">Alternatively,
if you have the <tt>&quot;gunzip&quot;</tt> program
available, you can use this to read compressed files</p>

<pre style="margin-left:11%; margin-top: 1em">    open F, &quot;gunzip &minus;c $filename |&quot;;
    while (&lt;F&gt;)
    {
        ...</pre>


<p style="margin-left:11%; margin-top: 1em">and this to
write compress files, if you have the
<tt>&quot;compress&quot;</tt> program available</p>

<pre style="margin-left:11%; margin-top: 1em">    open F, &quot;| compress &minus;c $filename &quot;;
    print F &quot;data&quot;;
    ...
    close F ;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Accessing
.tar.Z files</b> <br>
See previous <small>FAQ</small> item.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>&quot;Archive::Tar&quot;</tt> module is installed and
either the <tt>&quot;uncompress&quot;</tt> or
<tt>&quot;gunzip&quot;</tt> programs are available, you can
use one of these workarounds to read
<tt>&quot;.tar.Z&quot;</tt> files.</p>

<p style="margin-left:11%; margin-top: 1em">Firstly with
<tt>&quot;uncompress&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><tt>use strict;
<br>
use warnings; <br>
use Archive::Tar; <br>
open F, &quot;uncompress &minus;c $filename |&quot;; <br>
my $tar = Archive::Tar&minus;&gt;new(*F); <br>
...</tt></p>

<p style="margin-left:11%; margin-top: 1em">and this with
<tt>&quot;gunzip&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><tt>use strict;
<br>
use warnings; <br>
use Archive::Tar; <br>
open F, &quot;gunzip &minus;c $filename |&quot;; <br>
my $tar = Archive::Tar&minus;&gt;new(*F); <br>
...</tt></p>

<p style="margin-left:11%; margin-top: 1em">Similarly, if
the <tt>&quot;compress&quot;</tt> program is available, you
can use this to write a <tt>&quot;.tar.Z&quot;</tt> file</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict;
    use warnings;
    use Archive::Tar;
    use IO::File;
    my $fh = new IO::File &quot;| compress &minus;c &gt;$filename&quot;;
    my $tar = Archive::Tar&minus;&gt;new();
    ...
    $tar&minus;&gt;write($fh);
    $fh&minus;&gt;close ;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Zlib Library
Version Support</b> <br>
By default <tt>&quot;Compress::Raw::Zlib&quot;</tt> will
build with a private copy of version 1.2.5 of the zlib
library. (See the <i><small>README</small></i> file for
details of how to override this behaviour)</p>

<p style="margin-left:11%; margin-top: 1em">If you decide
to use a different version of the zlib library, you need to
be aware of the following issues</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">First off, you must have zlib
1.0.5 or better.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>You need to have zlib 1.2.1 or better if you want to use
the <tt>&quot;&minus;Merge&quot;</tt> option with
<tt>&quot;IO::Compress::Gzip&quot;</tt>,
<tt>&quot;IO::Compress::Deflate&quot;</tt> and
<tt>&quot;IO::Compress::RawDeflate&quot;</tt>.</p> </td></tr>
</table>

<h2>CONSTANTS
<a name="CONSTANTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All the
<i>zlib</i> constants are automatically imported when you
make use of <i>Compress::Raw::Zlib</i>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Compress::Zlib,
IO::Compress::Gzip, IO::Uncompress::Gunzip,
IO::Compress::Deflate, IO::Uncompress::Inflate,
IO::Compress::RawDeflate, IO::Uncompress::RawInflate,
IO::Compress::Bzip2, IO::Uncompress::Bunzip2,
IO::Compress::Lzma, IO::Uncompress::UnLzma,
IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop,
IO::Uncompress::UnLzop, IO::Compress::Lzf,
IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate,
IO::Uncompress::AnyUncompress</p>


<p style="margin-left:11%; margin-top: 1em">IO::Compress::FAQ</p>


<p style="margin-left:11%; margin-top: 1em">File::GlobMapper,
Archive::Zip, Archive::Tar, IO::Zlib</p>

<p style="margin-left:11%; margin-top: 1em">For <small>RFC
1950, 1951</small> and 1952 see
<i>http://www.faqs.org/rfcs/rfc1950.html</i>,
<i>http://www.faqs.org/rfcs/rfc1951.html</i> and
<i>http://www.faqs.org/rfcs/rfc1952.html</i></p>

<p style="margin-left:11%; margin-top: 1em">The <i>zlib</i>
compression library was written by Jean-loup Gailly
<i>gzip@prep.ai.mit.edu</i> and Mark Adler
<i>madler@alumni.caltech.edu</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The primary
site for the <i>zlib</i> compression library is
<i>http://www.zlib.org</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The primary
site for gzip is <i>http://www.gzip.org</i>.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module was
written by Paul Marquess, <i>pmqs@cpan.org</i>.</p>

<h2>MODIFICATION HISTORY
<a name="MODIFICATION HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See the Changes
file.</p>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
2005&minus;2013 Paul Marquess. All rights reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
